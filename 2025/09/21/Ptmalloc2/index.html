

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="SpongeBob">
  <meta name="keywords" content="">
  
    <meta name="description" content="实习的两个月，断断续续和栈相关的pwn题进行鏖战。对栈相关的基本内容已经了解的差不多了，碰到简单的题也能做一做（bushi    在buu第二页首次做到有关heap的pwn题。从以前的师傅那里了解到，heap是pwn里面一个比较大的模块了。在这里记一个笔记，希望能够像好多前辈一样对这块的内容不断总结不断学习，并且这个笔记也越来越完善，架构越来越饱满，万一以后写个blog能挂上去，对那些对二进制安全">
<meta property="og:type" content="article">
<meta property="og:title" content="Ptmalloc2 相关内容介绍">
<meta property="og:url" content="http://spongebob-369.github.io/2025/09/21/Ptmalloc2/index.html">
<meta property="og:site_name" content="SpongeBobの pineapple house">
<meta property="og:description" content="实习的两个月，断断续续和栈相关的pwn题进行鏖战。对栈相关的基本内容已经了解的差不多了，碰到简单的题也能做一做（bushi    在buu第二页首次做到有关heap的pwn题。从以前的师傅那里了解到，heap是pwn里面一个比较大的模块了。在这里记一个笔记，希望能够像好多前辈一样对这块的内容不断总结不断学习，并且这个笔记也越来越完善，架构越来越饱满，万一以后写个blog能挂上去，对那些对二进制安全">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://spongebob-369.github.io/images/Ptmalloc2.png">
<meta property="article:published_time" content="2025-09-21T04:57:58.000Z">
<meta property="article:modified_time" content="2025-09-21T05:22:11.875Z">
<meta property="article:author" content="SpongeBob">
<meta property="article:tag" content="Pwn">
<meta property="article:tag" content="heap">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://spongebob-369.github.io/images/Ptmalloc2.png">
  
  
  
  <title>Ptmalloc2 相关内容介绍 - SpongeBobの pineapple house</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"spongebob-369.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 100vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>SpongeBob&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/images/Ptmalloc2_bg.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Ptmalloc2 相关内容介绍"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-09-21 12:57" pubdate>
          September 21, 2025 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          8.2k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          69 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Ptmalloc2 相关内容介绍</h1>
            
            
              <div class="markdown-body">
                
                <p>实习的两个月，断断续续和栈相关的<code>pwn</code>题进行鏖战。对栈相关的基本内容已经了解的差不多了，碰到简单的题也能做一做（bushi    在buu第二页首次做到有关<code>heap</code>的pwn题。从以前的师傅那里了解到，<code>heap</code>是pwn里面一个比较大的模块了。在这里记一个笔记，希望能够像好多前辈一样对这块的内容不断总结不断学习，并且这个笔记也越来越完善，架构越来越饱满，万一以后写个<code>blog</code>能挂上去，对那些对二进制安全和<code>pwn</code>方向感兴趣的伙伴们有帮助（你在想什么混蛋，怎么会有人看你的blog啊！ 2025.8.28</p>
<h1 id="堆概述"><a href="#堆概述" class="headerlink" title="堆概述"></a>堆概述</h1><p>这里一定要区分进程所在内存的堆和数据结构中的堆是完全不同的两个概念。在程序运行过程中，堆是进程动态分配得到的内存段，是一段线性内存空间，地址从低地址向高地址生长。将为进程动态分配内存的代码段称为<strong>堆管理器</strong>。在Linux系统下包括传统的<code>heap</code>段和<code>Memory Mapping Segment</code>。如下图所示，还是很清楚的。堆与栈隔<code>Memory Mapping Segment</code>相望，实在是别有一番风味（乐</p>
<p><img src="/images/Ptmalloc2_str.png" srcset="/img/loading.gif" lazyload alt="内存结构图"></p>
<p>堆管理器处于用户程序与内核中间，主要做以下工作</p>
<ol>
<li>响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互。</li>
<li>管理用户所释放的内存。一般来说，用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。</li>
</ol>
<p>Linux早期使用Doug Lea作为堆管理器实现堆分配和回收。但是它在面临多线程的时候，不同进程之间会共享进程的堆内存空间。为了保证堆内存的安全性，在每一个进程访问堆内存的时候会上锁，虽然安全性得以保证，但是也导致了程序的效率低下。同时，如果在多线程使用时，没能正确控制，也可能影响内存分配和回收的正确性。为了解决这个问题，Wolfram Gloger 在 Doug Lea 的基础上进行改进使其可以支持多线程，这个堆分配器就是 <strong><code>ptmalloc</code></strong> 。在 glibc-2.3.x. 之后，<code>glibc</code> 中集成了 <code>ptmalloc2</code>。</p>
<p>目前 Linux 标准发行版中使用的堆分配器是 glibc 中的堆分配器：ptmalloc2。ptmalloc2 主要是通过 malloc&#x2F;free 函数来分配和释放内存块。</p>
<p>需要注意的是，在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想，<strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong>。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</p>
<p>常见的虚拟内存地址空间布局如下：</p>
<p>0x00000000 - 0x08048000 （约128MB）：保留区域</p>
<ul>
<li>这部分地址空间通常包含了一些系统保留的区域，比如 C 运行库的内容等，用户程序不能直接访问，否则会导致段错误（segmentation fault）。</li>
</ul>
<p>0x08048000 - 0xC0000000：用户空间</p>
<ul>
<li>用户空间包含了进程的代码、数据以及堆和栈等，其中：<ul>
<li>.text 段通常从 0x08048000 开始，存放程序的可执行指令。</li>
<li>堆向高地址扩展，用于动态分配内存。</li>
<li>栈向低地址增长，用于存放函数调用的参数、局部变量等。</li>
</ul>
</li>
</ul>
<p>0xC0000000 - 0xFFFFFFFF：内核空间</p>
<ul>
<li>这段地址空间是内核的逻辑地址，用户空间的程序不能直接访问，需要通过系统调用等方式切换到内核态才能访问这部分内核虚拟地址空间。</li>
</ul>
<p>在这种布局下，每个进程都有自己独立的虚拟地址空间，其中用户空间和内核空间各自独立，保证了进程之间的隔离和安全性。</p>
<h2 id="ASLR-机制"><a href="#ASLR-机制" class="headerlink" title="ASLR 机制"></a>ASLR 机制</h2><p>Linux 中的 ASLR（Address Space Layout Randomization）机制通过对栈、内存映射段、堆的起始地址加上随机偏移量来打乱虚拟地址空间布局，从而增加攻击者猜测系统资源地址的难度，提高了系统的安全性。</p>
<p>ASLR 机制会对以下三个部分进行随机化：</p>
<ul>
<li>Random stack offset：Linux 会在进程启动时将栈顶地址随机化，从而防止攻击者通过栈溢出攻击获取程序控制权。</li>
<li>Random mmap offset：Linux 会对每个内存映射段的起始地址进行随机化，从而防止攻击者获取内存映射段的地址，进而执行代码注入等攻击。</li>
<li>Random brk offset：Linux 会对堆的起始地址进行随机化，从而防止攻击者通过堆溢出攻击获取程序控制权。</li>
</ul>
<h2 id="微观结构"><a href="#微观结构" class="headerlink" title="微观结构"></a>微观结构</h2><p>堆的漏洞利用与这些结构密切相关。</p>
<h1 id="堆的一些主要内部结构"><a href="#堆的一些主要内部结构" class="headerlink" title="堆的一些主要内部结构"></a>堆的一些主要内部结构</h1><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h3><p>程序执行过程中，由malloc申请得到的内存叫做chunk，在<code>ptmalloc</code>内部用<code>malloc_chunk</code>结构体表示。当申请的<code>chunk</code>被free后，会被加入到相应的空闲管理列表中。具体结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  This struct declaration is misleading (but accurate and necessary).</span><br><span class="hljs-comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span><br><span class="hljs-comment">  fields at known offsets from a given base. See explanation below.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> &#123;</span><br><br>  INTERNAL_SIZE_T      prev_size;  <span class="hljs-comment">/* Size of previous chunk (if free).  */</span><br>  INTERNAL_SIZE_T      size;       <span class="hljs-comment">/* Size in bytes, including overhead. */</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span>         <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span><br><br>  <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span> <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;;<br><br></code></pre></td></tr></table></figure>

<ul>
<li><code>prev_size</code>，前一个<code>chunk</code>的大小。如果前一个<code>chunk</code>是空闲的话，该字段记录的是前一个<code>chunk</code>的大小（包括<code>chunk</code>头）。否则，该字段可以用来存储物理相邻的前一个<code>chunk</code>的数据。</li>
<li><code>size</code> ，该 <code>chunk</code> 的大小，大小必须是 <code>MALLOC_ALIGNMENT</code> 的整数倍。如果申请的内存大小不是 <code>MALLOC_ALIGNMENT</code> 的整数倍，会被转换满足大小的最小的 <code>MALLOC_ALIGNMENT</code> 的倍数，这通过 <code>request2size()</code> 宏完成。32 位系统中， <code>MALLOC_ALIGNMENT</code> 可能是 <code>4</code> 或 <code>8</code> ；64 位系统中，<code>MALLOC_ALIGNMENT</code> 是 <code>8</code>。 该字段的低三个比特位对 <code>chunk</code> 的大小没有影响，它们从高到低分别表示<ul>
<li><code>NON_MAIN_ARENA</code>，记录当前 <code>chunk</code> 是否不属于主线程，1 表示不属于，0 表示属于。</li>
<li><code>IS_MAPPED</code>，记录当前 <code>chunk</code> 是否是由 mmap 分配的。</li>
<li><code>PREV_INUSE</code>，记录前一个 <code>chunk</code> 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 <code>chunk</code> 的 size 的 P 位为 0 时，我们能通过 <code>prev_size</code> 字段来获取上一个 <code>chunk</code> 的大小以及地址。这也方便进行空闲 <code>chunk</code> 之间的合并。</li>
</ul>
</li>
<li><code>fd</code>, <code>bk</code>。<code>chunk</code> 处于分配状态时，从 fd 字段开始是用户的数据。 <code>chunk</code> 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下：下一个&#x2F;上一个（非物理相邻）的空闲的<code>chunk</code>。</li>
<li><code>fd_nextsize</code>，<code>bk_nextsize</code>。<code>chunk</code>空闲的时候才使用，用于较大的<code>chunk</code>。<ul>
<li>fd_nextsize指向前一个与当前<code>chunk</code>大小不同的第一个空闲块，不包含bin的头指针。</li>
<li>bk_nextsize指向后一个与当前<code>chunk</code>大小不同的第一个空闲块，不包含bin的头指针。</li>
</ul>
</li>
</ul>
<p>关键点：</p>
<ol>
<li><p>当一个 <code>chunk</code> 正在被使用时，与它物理相邻的下一个chunk（高地址）块的 <code>prev_size</code> 字段无效，可以被当前chunk所使用，这就是 <code>chunk</code> 中的空间复用。</p>
</li>
<li><p>被释放的 <code>chunk</code> 被记录在链表中结构可以理解为：</p>
<p> prev_size</p>
<p> size</p>
<p> forword pointer to next chunk in free list</p>
<p> back pointer to previous chunk in free list</p>
<p> Unused space(maybe 0 bytes long)</p>
</li>
<li><p>如果一个chunk处于 <code>free</code> 状态，会有两个地方记录他的大小：</p>
<ol>
<li>当前chunk的size字段。</li>
<li>下一个chunk的prev_size字段。</li>
</ol>
</li>
</ol>
<p>用户最小申请的内存大小必须是 2 * SIZE_SZ 的最小整数倍。</p>
<h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2><p>用户释放掉的chunk并不会马上归还给系统，<code>ptmalloc</code>会统一管理<code>heap</code>和<code>mmap</code>映射区域的空闲chunk。当用户再一次请求分配内存时，ptmalloc 分配器会试图在空闲的 chunk 中挑选一块合适的给用户。这样可以避免频繁的系统调用，降低内存分配的开销。</p>
<p>ptmalloc采用分箱式的方法对空闲的<code>chunk</code>进行管理。分为四类：fastbin，smallbin，unsorted bin， large bin。</p>
<p><code>bins</code> 主要用于索引不同 bin 的 fd 和 bk。</p>
<p>为了简化在双链接列表中的使用，每个<code>bin</code>的<code>header</code>都设置为<code>malloc_chunk</code>类型。这样可以避免<code>header</code>类型及其特殊处理。但是，为了节省空间和提高局部性，只分配<code>bin</code>的<code>fd/bk</code>指针，然后使用<code>repositioning tricks</code>将这些指针视为一个<code>malloc_chunk*</code>的字段。</p>
<p>数组中的 bin 依次如下</p>
<ol>
<li>第一个为 unsorted bin，字如其面，这里面的 <code>chunk</code> 没有进行排序，存储的 <code>chunk</code> 比较杂。</li>
<li>索引从 2 到 63 的 bin 称为 small bin，同一个 small bin 链表中的 <code>chunk</code> 的大小相同。两个相邻索引的 small bin 链表中的 <code>chunk</code> 大小相差的字节数为 <strong>2 个机器字长</strong>，即 32 位相差 8 字节，64 位相差 16 字节。</li>
<li>small bins 后面的 bin 被称作 large bins。large bins 中的每一个 bin 都包含一定范围内的 chunk，其中的 chunk 按 fd 指针的顺序从大到小排列。相同大小的 chunk 同样按照最近使用顺序排列。</li>
</ol>
<p>此外，上述这些 bin 的排布都会遵循一个原则：<strong>任意两个物理相邻的空闲 chunk 不能在一起</strong>。</p>
<p>所以，bin 的存储本质是**：**</p>
<ol>
<li><strong>管理结构（链表头）</strong>：在 <code>malloc_state</code>（也称为 arena header）结构体中，有一个专门的数组（如 <code>bins[128]</code>），这个数组的每个元素就是一个链表的头指针。</li>
<li><strong>链表节点（Chunks）</strong>：真正的空闲 chunk 散落在堆（heap）的各个位置。它们通过内部的 <code>fd</code> 和 <code>bk</code> 指针在逻辑上被串联起来，形成了 bin 链表。</li>
</ol>
<p>并不是所有的<code>chunk</code>被释放后就立即被放到bin中。ptmalloc为了提高分配的速度，会把一些小的<code>chunk</code>先放到<code>fast bins</code>的容器内。而且，fastbin容器中的<code>chunk</code>的使用标记总是被置位的，所以不满足上面的原则。</p>
<h3 id="Fast-Bin"><a href="#Fast-Bin" class="headerlink" title="Fast Bin"></a>Fast Bin</h3><p>需要注意的是，并不是所有的 <code>chunk</code> 被释放后就立即被放到 bin 中。ptmalloc 为了提高分配的速度，会把一些小的 <code>chunk</code> 先放到 fast bins 的容器内。而且，fastbin 容器中的 <code>chunk</code> 的使用标记总是被置位的，所以不满足上面的原则。</p>
<p>为了更加高效地利用 fast bin，glibc 采用单向链表对其中的每个 bin 进行组织，并且<strong>每个 bin 采取 LIFO 策略</strong>，最近释放的 <code>chunk</code> 会更早地被分配，所以会更加适合于局部性。也就是说，当用户需要的 <code>chunk</code> 的大小小于 fastbin 的最大大小时， ptmalloc 会首先判断 fastbin 中相应的 bin 中是否有对应大小的空闲块，如果有的话，就会直接从这个 bin 中获取 chunk。如果没有的话，ptmalloc 才会做接下来的一系列操作。</p>
<p>需要特别注意的是，fastbin 范围的 <code>chunk</code> 的 inuse 始终被置为 1。因此它们不会和其它被释放的 <code>chunk</code> 合并。</p>
<p>malloc_consolidate 函数可以将 fastbin 中所有能和其它 <code>chunk</code> 合并的 <code>chunk</code> 合并在一起。具体地参见后续的详细函数的分析。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Chunks in fastbins keep their inuse bit set, so they cannot be consolidated with other free chunks. malloc_consolidate releases all chunks in fastbins and consolidates them with other free chunks. */</span><br><br></code></pre></td></tr></table></figure>

<h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><p>small bins中每个<code>chunk</code>的大小与其所在的<code>bin</code>的<code>index</code>关系为：<code>chunk_size = 2 * SIZE_SZ * index</code><br>2～63，总共有62个循环双向链表。每个链表中存储的<code>chunk</code>大小都一致。<code>small bins</code>中每个<code>bin</code>对应的链表采用<code>FIFO</code>的规则，所以同一个链表中先被释放的<code>chunk</code>会被先分配出去。</p>
<h3 id="Large-Bin"><a href="#Large-Bin" class="headerlink" title="Large Bin"></a>Large Bin</h3><p>large bins 中一共包括63个bin。每个bin中的<code>chunk</code>的大小不一致，而是处于一定区间范围内。</p>
<h3 id="Unsorted-Bin"><a href="#Unsorted-Bin" class="headerlink" title="Unsorted Bin"></a>Unsorted Bin</h3><p>unsorted bin 可以视为空闲<code>chunk</code>回归其所属<code>bin</code>之前的缓冲区。只有一个链表，其中的<code>chunk</code>处于乱序状态，主要有两个来源：</p>
<ul>
<li>一个较大的<code>chunk</code>被分割成两半后，如果剩下的部分大于<code>MINSIZE</code>，就会被放到<code>unsorted bin</code>中</li>
<li>释放一个不属于<code>fast bin</code>的<code>chunk</code>，如果不与<code>top chunk</code>相邻，就会被放到<code>unsorted bin</code>中。</li>
</ul>
<p>采用的遍历顺序是：FIFO</p>
<h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h3><p>程序第一次进行 <code>malloc</code> 的时候，heap会被分成两块，一块给用户，剩下的那块就是top chunk，可以看作当前堆物理地址最高的top。该 chunk 不属于任何一个bin，当所有的bin都无法满足用户申请的大小时，就从 top chunk取，然后将剩下的部分作为新的 <code>top chunk</code> 。</p>
<h2 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h2><p><code>arena</code> 是 <code>glibc</code> 用来管理堆内存的独立、并行的数据结构。当程序调用 <code>malloc</code> 申请内存时， <code>glibc</code> 不会直接向操作系统请求小块内存，而是从一个或者多个 <code>Arena</code> 中分配。</p>
<p>分配器状态（malloc_state）的实例，负责一组 heap&#x2F;segment 的管理（bins、top chunk、fastbins、mutex、统计等）。多线程下多个 arena 并行减少锁竞争。</p>
<p>这里需要理清楚 <code>arena</code> <code>bin</code> <code>chunk</code> 之间的关系：</p>
<p>它们的关系：<strong>arena 包含若干 bin 和管理元数据；bin 链表里连着 chunk；chunk 属于创建它的 arena（来自该 arena 管理的 heap&#x2F;segment）</strong>。</p>
<h2 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h2><p>程序刚开始执行的时候，每个线程是没有heap区域的，当申请内存时，用该结构来记录堆的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span></span><br><span class="hljs-class">&#123;</span><br>  mstate ar_ptr; <span class="hljs-comment">/* Arena for this heap. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span> *<span class="hljs-title">prev</span>;</span> <span class="hljs-comment">/* Previous heap. */</span><br>  <span class="hljs-type">size_t</span> size;   <span class="hljs-comment">/* Current size in bytes. */</span><br>  <span class="hljs-type">size_t</span> mprotect_size; <span class="hljs-comment">/* Size in bytes that has been mprotected</span><br><span class="hljs-comment">                           PROT_READ|PROT_WRITE.  */</span><br>  <span class="hljs-comment">/* Make sure the following data is properly aligned, particularly</span><br><span class="hljs-comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span><br><span class="hljs-comment">     MALLOC_ALIGNMENT. */</span><br>  <span class="hljs-type">char</span> pad[<span class="hljs-number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];<br>&#125; heap_info;<br></code></pre></td></tr></table></figure>

<h2 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h2><p>该结构用于管理堆，记录每个 arena 当前申请的内存的具体状态。一个 <code>arena</code> 对应一个 <code>malloc_state</code> 。</p>
<p>比如说是否有空闲 chunk，有什么大小的空闲 chunk 等等。无论是 thread arena 还是 main arena，它们都只有一个 malloc state 结构。由于 thread 的 arena 可能有多个，malloc state 结构会在最新申请的 arena 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/* Serialize access.  */</span><br>  <span class="hljs-type">mutex_t</span> mutex;<br><br>  <span class="hljs-comment">/* Flags (formerly in max_fast).  */</span><br>  <span class="hljs-type">int</span> flags;<br><br>  <span class="hljs-comment">/* Fastbins */</span><br>  mfastbinptr fastbinsY[NFASTBINS];<br><br>  <span class="hljs-comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span><br>  mchunkptr top;<br><br>  <span class="hljs-comment">/* The remainder from the most recent split of a small request */</span><br>  mchunkptr last_remainder;<br><br>  <span class="hljs-comment">/* Normal bins packed as described above */</span><br>  mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<br><br>  <span class="hljs-comment">/* Bitmap of bins */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> binmap[BINMAPSIZE];<br><br>  <span class="hljs-comment">/* Linked list */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next</span>;</span><br><br>  <span class="hljs-comment">/* Linked list for free arenas.  Access to this field is serialized</span><br><span class="hljs-comment">     by free_list_lock in arena.c.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next_free</span>;</span><br><br>  <span class="hljs-comment">/* Number of threads attached to this arena.  0 if the arena is on</span><br><span class="hljs-comment">     the free list.  Access to this field is serialized by</span><br><span class="hljs-comment">     free_list_lock in arena.c.  */</span><br>  INTERNAL_SIZE_T attached_threads;<br><br>  <span class="hljs-comment">/* Memory allocated from the system in this arena.  */</span><br>  INTERNAL_SIZE_T system_mem;<br>  INTERNAL_SIZE_T max_system_mem;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这里面的 <code>bins</code> 结构是 <code>mchunkptr</code> ，对应的是一个 <code>malloc_chunk</code> </p>
<p><strong>注意，main arena 的 malloc_state 并不是 heap segment 的一部分，而是一个全局变量，存储在 libc.so 的数据段。</strong></p>
<h2 id="深入理解堆的实现"><a href="#深入理解堆的实现" class="headerlink" title="深入理解堆的实现"></a>深入理解堆的实现</h2><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><p>用来讲一个双向链表（只存储空闲的 <code>chunk</code> )中的一个元素取出来用于</p>
<ul>
<li>malloc<ul>
<li>从恰好大小合适的 <code>large bin</code> 中获取 <code>chunk</code><ul>
<li>fastbin 与 smallbin 没有使用unlink，漏洞经常出现在这里。</li>
<li>依次遍历处理 <code>unsorted bin</code> 时也没有使用 <code>unlink</code> 。</li>
</ul>
</li>
<li>从 比请求的chunk所在的bin大的bin中取chunk</li>
</ul>
</li>
<li>free<ul>
<li>后向合并，合并物理相邻低地址空闲chunk</li>
<li>前向合并，合并物理相邻高地址空闲chunk（除了top chunk）</li>
</ul>
</li>
<li>malloc_consolidate<ul>
<li>后向合并，合并物理相邻低地址空闲chunk</li>
<li>前向合并，合并物理相邻高地址空闲chunk（除了top chunk）</li>
</ul>
</li>
<li>realloc<ul>
<li>前向扩展，合并物理响铃高地址空闲chunk（除了top chunk）</li>
</ul>
</li>
</ul>
<p>unlink的源码在 <code>glibc</code> 中是以宏定义的形式实现的，从 <code>bin</code> 列表中取出一个 <code>chunk</code> ，实际上就是一个双向链表操作。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \</span><br><span class="hljs-meta">      malloc_printerr (<span class="hljs-string">&quot;corrupted size vs. prev_size&quot;</span>);			      \</span><br><span class="hljs-meta">    FD = P-&gt;fd;								      \</span><br><span class="hljs-meta">    BK = P-&gt;bk;								      \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))		      \</span><br><span class="hljs-meta">      malloc_printerr (<span class="hljs-string">&quot;corrupted double-linked list&quot;</span>);			      \</span><br><span class="hljs-meta">    <span class="hljs-keyword">else</span> &#123;								      \</span><br><span class="hljs-meta">        FD-&gt;bk = BK;							      \</span><br><span class="hljs-meta">        BK-&gt;fd = FD;							      \</span><br><span class="hljs-meta">        <span class="hljs-keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))			      \</span><br><span class="hljs-meta">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;		      \</span><br><span class="hljs-meta">	    <span class="hljs-keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)	      \</span><br><span class="hljs-meta">		|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span><br><span class="hljs-meta">	      malloc_printerr (<span class="hljs-string">&quot;corrupted double-linked list (not small)&quot;</span>);   \</span><br><span class="hljs-meta">            <span class="hljs-keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;				      \</span><br><span class="hljs-meta">                <span class="hljs-keyword">if</span> (P-&gt;fd_nextsize == P)				      \</span><br><span class="hljs-meta">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;		      \</span><br><span class="hljs-meta">                <span class="hljs-keyword">else</span> &#123;							      \</span><br><span class="hljs-meta">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;			      \</span><br><span class="hljs-meta">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;			      \</span><br><span class="hljs-meta">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;			      \</span><br><span class="hljs-meta">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;			      \</span><br><span class="hljs-meta">                  &#125;							      \</span><br><span class="hljs-meta">              &#125; <span class="hljs-keyword">else</span> &#123;							      \</span><br><span class="hljs-meta">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;		      \</span><br><span class="hljs-meta">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;		      \</span><br><span class="hljs-meta">              &#125;								      \</span><br><span class="hljs-meta">          &#125;								      \</span><br><span class="hljs-meta">      &#125;									      \</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure>

<p>不过要注意几点：</p>
<ol>
<li>定义中会先检查FD，BK是否合法，防止攻击者简单篡改 <code>chunk</code> 的fd的bk指针。</li>
<li>会检查该 <code>chunk</code> 块的 <code>size</code> 和他的下一块 <code>chunk</code> 中的 <code>prev_size</code> 是否相同。（实际上是定义检查。</li>
</ol>
<p>可以从源码看出， <code>chunk</code> 块 <code>P</code> 本的 <code>fd</code> 指针和 <code>bk</code> 指针并没有发生改变，这个地方</p>
<ul>
<li>libc 地址<ul>
<li>P 位于双向链表头部，bk 泄漏</li>
<li>P 位于双向链表尾部，fd 泄漏</li>
<li>双向链表只包含一个空闲 chunk 时，P 位于双向链表中，fd 和 bk 均可以泄漏</li>
</ul>
</li>
<li>泄漏堆地址，双向链表包含多个空闲 chunk<ul>
<li>P 位于双向链表头部，fd 泄漏</li>
<li>P 位于双向链表中，fd 和 bk 均可以泄漏</li>
<li>P 位于双向链表尾部，bk 泄漏</li>
</ul>
</li>
</ul>
<p>这里的头部说的是 bin 的 fd指向的chunk，即最新加入的chunk。尾部说的是bin的 bk 指向的chunk，即最早加入的chunk。</p>
<h2 id="堆初始化"><a href="#堆初始化" class="headerlink" title="堆初始化"></a>堆初始化</h2><p>堆初始化是在用户第一次申请内存时执行 malloc_consolidate 再执行 malloc_init_state 实现的。这里不做过多讲解。可以参见 <code>malloc_state</code> 相关函数。</p>
<h2 id="申请内存块"><a href="#申请内存块" class="headerlink" title="申请内存块"></a>申请内存块</h2><h3 id="lib-malloc函数"><a href="#lib-malloc函数" class="headerlink" title="__lib_malloc函数"></a>__lib_malloc函数</h3><p>我们写 <code>C</code> 语言的时候，使用 <code>malloc</code> 来让系统分配内存。 <code>glibc</code> 中通过 <code>__lib_malloc</code> 实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<br>__libc_malloc (<span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  mstate ar_ptr;<br>  <span class="hljs-type">void</span> *victim;<br><br>  <span class="hljs-type">void</span> *(*hook) (<span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__malloc_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br><br>  arena_get (ar_ptr, bytes);<br><br>  victim = _int_malloc (ar_ptr, bytes);<br>  <span class="hljs-comment">/* Retry with another arena only if we were able to find a usable arena</span><br><span class="hljs-comment">     before.  */</span><br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      LIBC_PROBE (memory_malloc_retry, <span class="hljs-number">1</span>, bytes);<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<br>      victim = _int_malloc (ar_ptr, bytes);<br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<br>    (<span class="hljs-type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);<br><br>  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||<br>          ar_ptr == arena_for_chunk (mem2chunk (victim)));<br>  <span class="hljs-keyword">return</span> victim;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里的变量 <code>mstate</code> 就是 <code>malloc_state</code> 。 <code>__malloc_hook</code> 是一个自定义的 <code>malloc</code> 钩子，可以用来用户自定义修改堆分配函数并且进行测试。如果存在，就执行 <code>hook</code> 函数。</p>
<p>如果没有用户自定义的钩子函数，就寻找一个 <code>arena</code> 来分配内存，然后调用 <code>_int_malloc</code> 函数去申请对应的内存。如果申请失败，会调用 <code>arena_get_retry</code> 再次申请一个 <code>arena</code> 然后重新分配内存。如果申请到了内存，最后还得解锁，并且判断当前状态：</p>
<ul>
<li>要么没有申请到内存</li>
<li>要么是 mmap 的内存</li>
<li><strong>要么申请到的内存必须在其所分配的 arena 中</strong></li>
</ul>
<p>最后返回内存。</p>
<h3 id="int-malloc函数"><a href="#int-malloc函数" class="headerlink" title="_ int_ malloc函数"></a>_ int_ malloc函数</h3><p><code>_int_malloc</code> 函数是 <code>__lib_malloc</code> 函数中的核心函数。下面对其代码进行拆解分析：</p>
<p>首先定义了一堆变量，相关的用处都在注释中给了出来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br>_int_malloc (mstate av, <span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  INTERNAL_SIZE_T nb;               <span class="hljs-comment">/* normalized request size */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx;                 <span class="hljs-comment">/* associated bin index */</span><br>  mbinptr bin;                      <span class="hljs-comment">/* associated bin */</span><br><br>  mchunkptr victim;                 <span class="hljs-comment">/* inspected/selected chunk */</span><br>  INTERNAL_SIZE_T size;             <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-type">int</span> victim_index;                 <span class="hljs-comment">/* its bin index */</span><br><br>  mchunkptr remainder;              <span class="hljs-comment">/* remainder from a split */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> remainder_size;     <span class="hljs-comment">/* its size */</span><br><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> block;               <span class="hljs-comment">/* bit map traverser */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bit;                 <span class="hljs-comment">/* bit map traverser */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-built_in">map</span>;                 <span class="hljs-comment">/* current word of binmap */</span><br><br>  mchunkptr fwd;                    <span class="hljs-comment">/* misc temp for linking */</span><br>  mchunkptr bck;                    <span class="hljs-comment">/* misc temp for linking */</span><br><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errstr = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>

<p>将原本要申请的内存 <code>bytes</code> 进行处理，变成符合要求的内部的 <code>chunk</code> 大小，并且存入 <code>nb</code> 中。然后查询是否有 <code>arena</code> ，没有的话通过系统调用 <code>mmap</code> 一个 <code>chunk</code> 返回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">     Convert request size to internal form by adding SIZE_SZ bytes</span><br><span class="hljs-comment">     overhead plus possibly more to obtain necessary alignment and/or</span><br><span class="hljs-comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span><br><span class="hljs-comment">     size. Also, checked_request2size traps (returning 0) request sizes</span><br><span class="hljs-comment">     that are so large that they wrap around zero when padded and</span><br><span class="hljs-comment">     aligned.</span><br><span class="hljs-comment">   */</span><br><br>  checked_request2size (bytes, nb);<br><br>  <span class="hljs-comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span><br><span class="hljs-comment">     mmap.  */</span><br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (av == <span class="hljs-literal">NULL</span>))<br>    &#123;<br>      <span class="hljs-type">void</span> *p = sysmalloc (nb, av);<br>      <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>	alloc_perturb (p, bytes);<br>      <span class="hljs-keyword">return</span> p;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>如果 <code>chunk</code> 的尺寸在 <code>fastbin</code> 中，首先检查是否有对应的 <code>bin</code> 。这里是从 <code>fastbin</code> 的头开始遍历。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">     If the size qualifies as a fastbin, first check corresponding bin.</span><br><span class="hljs-comment">     This code is safe to execute even if av is not yet initialized, so we</span><br><span class="hljs-comment">     can try it without checking, which saves some time on this fast path.</span><br><span class="hljs-comment">   */</span><br><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (get_max_fast ()))<br>    &#123;<br>	    <span class="hljs-comment">// fastbin的下标</span><br>      idx = fastbin_index (nb);<br>      <span class="hljs-comment">// 获得fastbin的头指针</span><br>      mfastbinptr *fb = &amp;fastbin (av, idx);<br>      <span class="hljs-comment">// 令 chunk指针先为头，从头开始遍历</span><br>      mchunkptr pp = *fb;<br>      <span class="hljs-keyword">do</span><br>        &#123;<br>          victim = pp;<br>          <span class="hljs-keyword">if</span> (victim == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>      <span class="hljs-keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))<br>             != victim);<br>      <span class="hljs-comment">// 利用fastbin_index 计算 chunk 的索引。</span><br>      <span class="hljs-keyword">if</span> (victim != <span class="hljs-number">0</span>)<br>        &#123;<br>          <span class="hljs-keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="hljs-number">0</span>))<br>            &#123;<br>              errstr = <span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>;<br>            errout:<br>              malloc_printerr (check_action, errstr, chunk2mem (victim), av);<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            &#125;<br>          <span class="hljs-comment">// 细致的检查</span><br>          check_remalloced_chunk (av, victim, nb);<br>          <span class="hljs-comment">// 将获取的到chunk转换为mem模式</span><br>          <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>          <span class="hljs-comment">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span><br>          alloc_perturb (p, bytes);<br>          <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>如果获取的内存块处于 <code>small bin</code> 的范围内</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   If a small request, check regular bin.  Since these &quot;smallbins&quot;</span><br><span class="hljs-comment">   hold one size each, no searching within bins is necessary.</span><br><span class="hljs-comment">   (For a large request, we need to wait until unsorted chunks are</span><br><span class="hljs-comment">   processed to find best fit. But for small ones, fits are exact</span><br><span class="hljs-comment">   anyway, so we can check now, which is faster.)</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>  &#123;<br>   <span class="hljs-comment">// 获得smallbin的下标</span><br>    idx = smallbin_index (nb);<br>    <span class="hljs-comment">// 获取对应 small bin 中的 chunk 指针</span><br>    bin = bin_at (av, idx);<br>		<span class="hljs-comment">// 获取smallbin的最后一个chunk，如果和bin相等，则说明bin为空。</span><br>    <span class="hljs-keyword">if</span> ((victim = last (bin)) != bin)<br>      &#123;<span class="hljs-comment">// 如果不相等，有两种情况</span><br>       <span class="hljs-comment">//第一种，small bin还没有初始化</span><br>        <span class="hljs-keyword">if</span> (victim == <span class="hljs-number">0</span>) <span class="hljs-comment">/* initialization check */</span><br>          malloc_consolidate (av);<br>        <span class="hljs-keyword">else</span><br>          &#123;<span class="hljs-comment">//第二种情况，存在空闲的chunk</span><br>            bck = victim-&gt;bk;<br>            <span class="hljs-comment">//检查前一块的fd是否为当前块</span><br>					<span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>            &#123;<br>                errstr = <span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;<br>                <span class="hljs-keyword">goto</span> errout;<br>            &#125;<br>            <span class="hljs-comment">// 设标志位 inuse </span><br>            set_inuse_bit_at_offset (victim, nb);<br>            <br>            bin-&gt;bk = bck;<br>            bck-&gt;fd = bin;<br>					<span class="hljs-comment">// 如果不是 main_arena，设置对应的标志</span><br>            <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>              victim-&gt;size |= NON_MAIN_ARENA;<br>            <span class="hljs-comment">// 检查分配好内存的chunk</span><br>            check_malloced_chunk (av, victim, nb);<br>            <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>            <span class="hljs-comment">// 这里具体查了下，检查是否设置了perturb_byte，如果是，就是将取到的chunk进行非零字符填充 </span><br>            alloc_perturb (p, bytes)<br>            <span class="hljs-keyword">return</span> p;<br>          &#125;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，就会考虑是不是 large bin。但是，其实在 large bin 中并没有直接去扫描对应 bin 中的 chunk，而是先利用 malloc_consolidate（参见 malloc_state 相关函数） 函数处理 fast bin 中的 chunk，将有可能能够合并的 chunk 先进行合并后放到 unsorted bin 中，不能够合并的就直接放到 unsorted bin 中，然后再在下面的大循环中进行相应的处理。为什么不直接从相应的 bin 中取出 large chunk 呢？这是 ptmalloc 的机制，它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span><br>  &#123;<span class="hljs-comment">// 获取 largebin的下标</span><br>    idx = largebin_index (nb);<br>    <span class="hljs-keyword">if</span> (have_fastchunks (av))<br>      malloc_consolidate (av);<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>接下来是一个大的循环，还是分步进行理解：</p>
<p>在这个循环中，首先考虑从 <code>unsorted bin</code> 进行取 <code>chunk</code> ，然后才会去 <code>large bin</code> 中找，但是对于 small bin chunk 的请求会有所例外。可以看到如果在 <code>smallbin_range</code> 中的话，那么我们首先考虑 last remainder，可以看一下我给的注释部分，这里有一个 <code>last remainder</code> 的概念：malloc使用，那么切割之后剩余的chunk就被称为“last remainder”。如果在bins链中存在freechunk时，当我们去maloc的时候，mal0c的请求大小比freechunk的大小，那么arena就会切制这个freechunk给</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (;; )<br>  &#123;<br>    <span class="hljs-type">int</span> iters = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<br>      &#123;<br>        bck = victim-&gt;bk;<br>        <span class="hljs-keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>            || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<br>          malloc_printerr (check_action, <span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>,<br>                           chunk2mem (victim), av);<br>        size = chunksize (victim);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">           If a small request, try to use last remainder if it is the</span><br><span class="hljs-comment">           only chunk in unsorted bin.  This helps promote locality for</span><br><span class="hljs-comment">           runs of consecutive small requests. This is the only</span><br><span class="hljs-comment">           exception to best-fit, and applies only when there is</span><br><span class="hljs-comment">           no exact fit for a small chunk.</span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-keyword">if</span> (in_smallbin_range (nb) &amp;&amp;<br>            bck == unsorted_chunks (av) &amp;&amp;<br>            victim == av-&gt;last_remainder &amp;&amp;<br>            (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>          &#123;<br>            <span class="hljs-comment">/* split and reattach remainder */</span><br>            <span class="hljs-comment">// split之后剩余的尺寸。</span><br>            remainder_size = size - nb;<br>            <span class="hljs-comment">// split之后的位置</span><br>            remainder = chunk_at_offset (victim, nb);<br>            <span class="hljs-comment">// 修改末端的位置</span><br>            unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;<br>            av-&gt;last_remainder = remainder;<br>            remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);<br>            <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>              &#123;<br>                remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>              &#125;<br>            <span class="hljs-comment">// 设置victim的头部，</span><br>            set_head (victim, nb | PREV_INUSE |<br>                      (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>            <span class="hljs-comment">// 设置remainder的头部</span><br>            set_head (remainder, remainder_size | PREV_INUSE);<br>            set_foot (remainder, remainder_size);<br><br>            check_malloced_chunk (av, victim, nb);<br>            <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>            alloc_perturb (p, bytes);<br>            <span class="hljs-keyword">return</span> p;<br>          &#125;<br>        <span class="hljs-comment">/* remove from unsorted list */</span><br>        unsorted_chunks (av)-&gt;bk = bck;<br>        bck-&gt;fd = unsorted_chunks (av);<br></code></pre></td></tr></table></figure>

<p>现在就要取走的话，当 <code>size</code> 正好和在 <code>unsorted bin</code> 找到的 <code>chunk</code> 块匹配的时候，就直接取走，不走后面的流程（先放入bin中）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Take now instead of binning if exact fit */</span><br><br>         <span class="hljs-keyword">if</span> (size == nb)<br>           &#123;<br>             set_inuse_bit_at_offset (victim, size);<br>             <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>               victim-&gt;size |= NON_MAIN_ARENA;<br>             check_malloced_chunk (av, victim, nb);<br>             <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>             alloc_perturb (p, bytes);<br>             <span class="hljs-keyword">return</span> p;<br>           &#125;<br></code></pre></td></tr></table></figure>

<p>将取出来的 <code>chunk</code> 放到相应的 <code>bin</code> 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* place chunk in bin */</span><br><br><span class="hljs-keyword">if</span> (in_smallbin_range(size)) &#123;<br>    victim_index = smallbin_index(size);<br>    bck          = bin_at(av, victim_index);<br>    fwd          = bck-&gt;fd;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// large bin 范围</span><br>    victim_index = largebin_index(size);<br>    bck          = bin_at(av, victim_index); <span class="hljs-comment">// 当前 large bin 的头部</span><br>    fwd          = bck-&gt;fd;<br><br>    <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>    <span class="hljs-comment">/* 从这里我们可以总结出，largebin 以 fd_nextsize 递减排序。</span><br><span class="hljs-comment">       同样大小的 chunk，后来的只会插入到之前同样大小的 chunk 后，</span><br><span class="hljs-comment">       而不会修改之前相同大小的fd/bk_nextsize，这也很容易理解，</span><br><span class="hljs-comment">       可以减低开销。此外，bin 头不参与 nextsize 链接。*/</span><br>    <span class="hljs-comment">// 如果 large bin 链表不空</span><br>    <span class="hljs-keyword">if</span> (fwd != bck) &#123;<br>        <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>        <span class="hljs-comment">// 加速比较，应该不仅仅有这个考虑，因为链表里的 chunk 都会设置该位。</span><br>        size |= PREV_INUSE;<br>        <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>        <span class="hljs-comment">// bck-&gt;bk 存储着相应 large bin 中最小的chunk。</span><br>        <span class="hljs-comment">// 如果遍历的 chunk 比当前最小的还要小，那就只需要插入到链表尾部。</span><br>        <span class="hljs-comment">// 判断 bck-&gt;bk 是不是在 main arena。</span><br>        assert(chunk_main_arena(bck-&gt;bk));<br>        <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt;<br>            (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) chunksize_nomask(bck-&gt;bk)) &#123;<br>            <span class="hljs-comment">// 令 fwd 指向 large bin 头</span><br>            fwd = bck;<br>            <span class="hljs-comment">// 令 bck 指向 largin bin 尾部 chunk</span><br>            bck = bck-&gt;bk;<br>            <span class="hljs-comment">// victim 的 fd_nextsize 指向 largin bin 的第一个 chunk</span><br>            victim-&gt;fd_nextsize = fwd-&gt;fd;<br>            <span class="hljs-comment">// victim 的 bk_nextsize 指向原来链表的第一个 chunk 指向的 bk_nextsize</span><br>            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>            <span class="hljs-comment">// 原来链表的第一个 chunk 的 bk_nextsize 指向 victim</span><br>            <span class="hljs-comment">// 原来指向链表第一个 chunk 的 fd_nextsize 指向 victim</span><br>            fwd-&gt;fd-&gt;bk_nextsize =<br>                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 当前要插入的 victim 的大小大于最小的 chunk</span><br>            <span class="hljs-comment">// 判断 fwd 是否在 main arena</span><br>            assert(chunk_main_arena(fwd));<br>            <span class="hljs-comment">// 从链表头部开始找到不比 victim 大的 chunk</span><br>            <span class="hljs-keyword">while</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size &lt; chunksize_nomask(fwd)) &#123;<br>                fwd = fwd-&gt;fd_nextsize;<br>                assert(chunk_main_arena(fwd));<br>            &#125;<br>            <span class="hljs-comment">// 如果找到了一个和 victim 一样大的 chunk，</span><br>            <span class="hljs-comment">// 那就直接将 chunk 插入到该chunk的后面，并不修改 nextsize 指针。</span><br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size ==<br>                (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) chunksize_nomask(fwd))<br>                <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                fwd = fwd-&gt;fd;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果找到的chunk和当前victim大小不一样</span><br>                <span class="hljs-comment">// 那么就需要构造 nextsize 双向链表了</span><br>                victim-&gt;fd_nextsize              = fwd;<br>                victim-&gt;bk_nextsize              = fwd-&gt;bk_nextsize;<br>                fwd-&gt;bk_nextsize                 = victim;<br>                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>            &#125;<br>            bck = fwd-&gt;bk;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 如果空的话，直接简单使得 fd_nextsize 与 bk_nextsize 构成一个双向链表即可。</span><br>        victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最终取出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 放到对应的 bin 中，构成 bck&lt;--&gt;victim&lt;--&gt;fwd。</span><br>mark_bin(av, victim_index);<br>victim-&gt;bk = bck;<br>victim-&gt;fd = fwd;<br>fwd-&gt;bk    = victim;<br>bck-&gt;fd    = victim;<br></code></pre></td></tr></table></figure>

<p>while最多迭代1w次后退出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-comment">// #define MAX_ITERS 10000</span><br>    <span class="hljs-keyword">if</span> (++iters &gt;= MAX_ITERS) <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="各类-Bin-的结构和用途"><a href="#各类-Bin-的结构和用途" class="headerlink" title="各类 Bin 的结构和用途"></a><strong>各类 Bin 的结构和用途</strong></h2><ul>
<li><strong>快速链（Fastbin）</strong>：专用于非常小的块（默认小于 mp_.max_fast，32 位系统约 64B，64 位约 128B）。Fastbin 由 10 个 LIFO 栈（单向链表）组成，每个栈只保存固定大小的块，释放时不会合并邻块 。Fastbin 分配速度极快，通过简单地将 freed 块放入对应链表头来实现。注意，Fastbin 的块直到下一次 malloc 调用会被合并（malloc_consolidate）才进行真正合并处理。</li>
<li><strong>未分类链（Unsorted Bin）</strong>：一个链表（循环双链表），存放最新释放的块（大小不限） 。当块释放后（且非 Fastbin 范围内），先将其合并前后相邻空闲块，然后入 “未分类” 链表。其作用是“缓冲区”，让 malloc 有机会快速重用最近释放的块 。在 malloc 时，Unsorted Bin 会被扫描：若找到合适大小的块则立即使用，否则将扫描到的块重新放入对应的 Small&#x2F;Large bin 。</li>
<li><strong>小块链（Small Bin）</strong>：管理固定大小的小空闲块。glibc 默认有 62 个小块链（32 位最多 512B，64 位最多 1024B，每个链保存一个特定大小范围内的块） 。小块链索引公式由 smallbin_index(sz) 定义，每个链中的块大小相等。分配时只做精确匹配：如果请求大小落在小范围内且对应 Small Bin 非空，就直接取出一个块 。这种方式速度快、无搜寻开销。小块链内的空闲块数量和堆碎片化较易控制，因为大小完全一致。</li>
<li><strong>大块链（Large Bin）</strong>：管理比小块链更大的块。glibc 默认有 63 个大块链 。每个大块链保存大小在一定范围的块（范围不等，且会跨越大跨度，见 glibc 源码中的 largebin_index(sz) 逻辑 ）。大块链保持按块大小降序排列（最大的块在链表头） 。分配时，大于小块阈值的请求会在对应大块链中查找 <em>最适合</em> 的块：首先利用二级索引链（fd_nextsize 指针）找到第一个大于等于请求大小的块，如果有剩余则切分余下部分，否则整个块拿出。如果首选链没有合适块，则按大小位图（binmap）从下一条链开始依次扫描找到可用块 。</li>
<li><strong>Tcache（线程缓存）</strong>：glibc 2.26 起增加的优化，每线程维护 64 个小块缓存列表。分配时先检查 tcache，有可用块就直接返回，避免锁竞争；释放时优先放入 tcache。tcache 属于“栈”结构，加速常用小对象的重用（此处不深入详述）。在源码逻辑里，tcache 检查发生在进入 _int_malloc 之前 。</li>
</ul>
<h2 id="malloc-分配流程概览"><a href="#malloc-分配流程概览" class="headerlink" title="malloc 分配流程概览"></a><strong>malloc 分配流程概览</strong></h2><p>调用 malloc(size) 时，glibc 执行如下主要步骤：</p>
<ol>
<li><strong>初始化 Arena</strong>：首次调用时调用 ptmalloc_init()，为主 Arena 初始化 malloc_state 结构，包括设置 top 块指针、各空闲链表头指向自身等 。</li>
<li><strong>规范化请求大小</strong>：将用户请求加上头部开销并对齐，得到内部块大小 nb &#x3D; request2size(size) 。若 nb 溢出（或为 0），则返回 ENOMEM。</li>
<li><strong>选择 Arena</strong>：如果是单线程或主 Arena 可用，直接使用 &amp;main_arena；多线程时根据 size 和线程绑定策略选取或创建一个 Arena （涉及 arena_get 等函数）。</li>
<li><strong>Fastbin 路径</strong>：若 nb &lt;&#x3D; mp_.max_fast（即 nb 在 Fastbin 支持范围内），检查对应的 fastbin 列表 。如果非空，则立即取出链表头块，并返回该块 。这一步是不需锁定全局链表的快速路径。</li>
<li><strong>Small Bin 路径</strong>：如果 nb 属于小块范围（in_smallbin_range(nb) 为真），计算其小块索引 idx&#x3D;smallbin_index(nb) 。如果对应 Small Bin 的链表非空，就直接取出链表尾（last(bin)）的块作为分配结果 ，并把该块从链表中摘除。取出后需设置 PREV_INUSE 位，并标记为已分配块。</li>
<li><strong>Fastbin 合并</strong>：如果以上未成功且当前请求较大，检查 av-&gt;have_fastchunks 标志。如果 fastbin 链表有待处理的块（来自之前的释放），则调用 malloc_consolidate(av)，将所有 Fastbin 中的块全部合并并转入 Unsorted bin 。这样可以避免以后碎片累积。然后恢复刚才判断 idx（因为可能影响后续 Small&#x2F;Large 路径）。</li>
<li><strong>Unsorted Bin 处理</strong>：现在检查 Unsorted Bin（对应 bins[1]） 。对于 Unsorted Bin 中的每个块，逐个检查是否符合请求：<ul>
<li>若某个块大小正好等于 nb，则立即用它（并从 Unsorted 链表摘除返回） 。</li>
<li>若是小请求且 Unsorted Bin 中仅余最后一个块 last_remainder，且它足够大，允许切分，就用它的一部分：将前 nb 字节分配给用户，剩余部分作为新的 Unsorted Bin 块 。</li>
<li>否则（当前块不正好合适），将该块从 Unsorted Bin 摘除并插入到其<strong>正确的大小 Bin</strong>中：如果其大小仍在小块范围，则入小块链；否则按其大小计算大块索引插入大块链中（并保持链表大小排序） 。这种做法保证每个块在被 malloc 再次利用前至少在 Unsorted Bin 暂留一次 。</li>
</ul>
</li>
<li><strong>Large Bin 路径</strong>：如果请求属于大块范围（!in_smallbin_range(nb)）且上一步未分配到块，则查找大块链中最适合的块。首先在计算得到的目标大块链中查找第一个尺寸 ≥ nb 的块，利用 fd_nextsize 跳表加速。若找到，则将其摘出：如果剩余不足一个最小块，则直接用整块；否则同样分裂出一个余块，将余块重新插入 Unsorted Bin 。</li>
<li><strong>遍历所有 Bin</strong>：若仍未找到合适块，则从下一个 Bin 开始（索引+1），根据 BinMap 位图迅速跳过空链表，线性扫描剩余大小的所有 Bin，寻找第一个非空链表中的适合块 。找到后同样摘出并分配（必要时切分、余块入 Unsorted）。</li>
<li><strong>使用 Top Chunk</strong>：如果以上所有 Bin 都没有可用块，最后尝试使用 av-&gt;top（Arena 的顶端空闲块）。如果 top-&gt;size &gt;&#x3D; nb + MINSIZE，则将 top 切分出一个前部给请求（设置为已分配），剩下部分仍作新 top 。</li>
<li><strong>系统扩展</strong>：若 top 也不足，或者 top 刚好被耗尽（空间小于 MINSIZE），则调用 sysmalloc(nb, av) 扩展堆空间 。sysmalloc 通常通过 sbrk&#x2F;morecore 增加一段连续内存（根据页大小对齐），并可能触发透明大页优化 。如果 sbrk 失败或请求很大超出阈值，则备用地使用 mmap 分配一段新的内存区域。新分配的区域会被标记为 mmapped chunk，后续释放时会 munmap。</li>
<li><strong>返回</strong>：最后，将分配到的块首地址（跳过 chunk 头部）返回给用户。整个过程中会设置合适的标志位（PREV_INUSE、Arena 标识等），并在必要时检查内部一致性（调试模式下）。</li>
</ol>
<h2 id="释放内存块"><a href="#释放内存块" class="headerlink" title="释放内存块"></a>释放内存块</h2><p>和申请内存块差不多，这里就不进行详细的源码分析了，只梳理大概的逻辑～</p>
<p>先检查是否有自定义的钩子函数，如果有就用用户自定义的。没有就进入默认的 <code>_int_free</code> 函数。再进入之前还会做一些操作和检查，包括：如果释放内存为0，直接返回。如果这个内存时 <code>mmap</code> 得到的，则释放 <code>mmap</code> 得到的内存。</p>
<h3 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a><code>_int_free</code></h3><p>自定义一些变量，检查都合格之后。判断当前的 bin 是否在 <code>fast bin</code> 的范围内，在的话就插入到 <code>fastbin</code> 的头部，即成为对应 <code>fastbin</code> 链表的第一个 <code>free chunk</code> 。</p>
<p>注意：只有不是 <code>fast bin</code> 的情况下才会触发 <code>unlink</code> 。</p>
<p>为了避免 <code>heap</code> 中有太多零零碎碎的内存块，会对 <code>chunk</code> 进行合并，合并之后可以用来应对更大的内存块请求。合并的主要顺序为：</p>
<ul>
<li>先考虑物理低地址空闲块</li>
<li>后考虑物理高地址空闲块。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Pwn/" class="category-chain-item">Pwn</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Pwn/" class="print-no-link">#Pwn</a>
      
        <a href="/tags/heap/" class="print-no-link">#heap</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Ptmalloc2 相关内容介绍</div>
      <div>http://spongebob-369.github.io/2025/09/21/Ptmalloc2/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>SpongeBob</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>September 21, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/09/14/2025-FordID-CTF/" title="2025 FordID CTF">
                        <span class="hidden-mobile">2025 FordID CTF</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
